<!DOCTYPE html>
<html lang="en"><head><title>Emacs and Pairs</title><meta charset="utf-8" /><meta content="width=device-width,initial-scale=1.0,user-scalable=yes" name="viewport" /><meta content="noodp,noydir" name="robots" /><meta property="og:title" content="Emacs and Pairs" /><meta property="og:type" content="article" /><meta property="og:url" content="http://ebzzry.io/emacs-pairs.html" /><meta property="og:image" content="http://ebzzry.io/static/ico/android-chrome-512x512.png" /><meta content="A journal about computing, human predilections, and random krakaboom." name="description" /><meta content="ebzzry, rommel, martinez, rommel martinez, y, y combinator, lambda, lambda calculus, lisp, scheme, racket, clojure, haskell, fallacies, symbols, marks, symbols and marks, emacs, emacs hacks, emacs tutorials, emacs commands, emacs basics, dired, retrospect, livefrog, usync, essays, english, esperanto, verb tenses, git, github, primer, introduction, linux, macos, kvm, frog, ugarit, gpg, ssh, division by zero, communicate, human, communicate like a human, krakaboom, human predilections, predilections, computing, inspiration, quotes, famous quotes, words, emem" name="keywords" /><link href="static/ico/apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180" /><link href="static/ico/favicon-16x16.png" rel="icon" sizes="16x16" type="image/png" /><link href="static/ico/favicon-32x32.png" rel="icon" sizes="32x32" type="image/png" /><link href="static/ico/manifest.json" rel="manifest" /><link color="#5bbad5" href="static/ico/safari-pinned-tab.svg" rel="mask-icon" /><meta content="#ffffff" name="theme-color" /><style media="all" type="text/css">html {    color: #333;    font-size: 1em;    font-family: Georgia, Cambria, Palatino, "Palatino Linotype", "Times New Roman", Times, serif;    line-height: 1.45;    text-align: left:    width: 100%;    max-width: 40em;    margin: 0 auto 0 auto;    padding: 0;}body {    border-top: hidden;    border-bottom: hidden;    padding: 0 1.5em 1em 1.5em;    margin: 0;}#content {    -webkit-column-count: 1;    -moz-column-count: 1;    column-count: 1;}code {    font-size: 0.9em;    font-family: "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Lucida Console", "Courier New", Courier, monospace;    color: black;    display: inline-block;    font-weight: bold;}pre code {    font-size: 1em;    font-family: monospace;    line-height: 1.3em;    overflow: auto;    font-weight: normal;}kbd {    font-size: 1.1em;    padding: 0.1em 0.6em;    border: 1px solid #ccc;    font-family: monospace;    background-color: #f7f7f7;    color: #333;    -moz-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    -webkit-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    -moz-border-radius: 3px;    -webkit-border-radius: 3px;    border-radius: 3px;    display: inline-block;    margin: 0 0.1em;    text-shadow: 0 1px 0 #fff;    white-space: nowrap;}h1, h2, h3, h4, h5, h6 {    font-family: Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans", Tahoma, Geneva, Helvetica, Arial, sans-serif;    margin-bottom: 0;}h1 {    font-size: 2.5em;    text-align: center;    border-bottom: 6px solid black;}h2 {    font-size: 2.0em;    text-align: left;    border-bottom: 2px solid black;}h3 {    font-size: 1.6em;    text-align: left;    border-bottom: 1px solid lightgrey;}h4 {    font-size: 1.5em;    text-align: left;}h5 {    font-size: 1.3em;    text-align: left;}ul, ol {    padding-left: 2em;}ul li {    list-style-type: square;}ul li li {    list-style-type: disc;}ul li li li {    list-style-type: circle;}ol li {    list-style-type: decimal;}p, para, b, strong, i, em, emph {    font-size: 1em;}blockquote {    font-size: 1.2em;    font-style: italic;    margin-left: 2em;}b, strong {    font-weight: bold;}i, em, emph {    font-style: italic;}table {    margin: 0.5em;    border-spacing: 0;    border-collapse: collapse;}th, td {    border: 1px solid lightgray;    padding-top: 0;    padding-bottom: 0;    padding-left: 0.45em;    padding-right: 0.45em;}.text-right {    text-align: right;}.text-small {    font-size: small;}.text-x-small {    font-size: x-small;}.banner {    display: block;    width: 100%;    margin-left: auto;    margin-right: auto;}.footer {    text-align: right;    float: right;    max-width: 18em;}.cc {    border-width: 0}</style><style media="all" type="text/css">/* Ewan Themes -- based 99.99% from Tomorrow Night Theme *//* http://jmblog.github.com/color-themes-for-google-code-highlightjs *//* Original theme - https://github.com/chriskempson/tomorrow-theme *//* http://jmblog.github.com/color-themes-for-google-code-highlightjs *//* Tomorrow Comment */.hljs-comment {  color: #969896;}/* Tomorrow Red */.hljs-variable,.hljs-attribute,.hljs-tag,.hljs-regexp,.ruby .hljs-constant,.xml .hljs-tag .hljs-title,.xml .hljs-pi,.xml .hljs-doctype,.html .hljs-doctype,.css .hljs-id,.css .hljs-class,.css .hljs-pseudo {  color: #cc6666;}/* Tomorrow Orange */.hljs-number,.hljs-preprocessor,.hljs-pragma,.hljs-built_in,.hljs-literal,.hljs-params,.hljs-constant {  color: #de935f;}/* Tomorrow Yellow */.ruby .hljs-class .hljs-title,.css .hljs-rule .hljs-attribute {  color: #f0c674;}/* Tomorrow Green */.hljs-string,.hljs-value,.hljs-inheritance,.hljs-header,.hljs-name,.ruby .hljs-symbol,.xml .hljs-cdata {  color: #b5bd68;}/* Tomorrow Aqua */.hljs-title,.css .hljs-hexcolor {  color: #8abeb7;}/* Tomorrow Blue */.hljs-function,.python .hljs-decorator,.python .hljs-title,.ruby .hljs-function .hljs-title,.ruby .hljs-title .hljs-keyword,.perl .hljs-sub,.javascript .hljs-title,.coffeescript .hljs-title {  color: #81a2be;}/* Tomorrow Purple */.hljs-keyword,.javascript .hljs-function {  color: #b294bb;}.hljs {  display: block;  overflow-x: auto;  background: #1d1f21;  color: #c5c8c6;  padding: 0.5em;  -webkit-text-size-adjust: none;}.coffeescript .javascript,.javascript .xml,.tex .hljs-formula,.xml .javascript,.xml .vbscript,.xml .css,.xml .hljs-cdata {  opacity: 0.5;}pre code {    font-size: 1.1em;    font-family: monospace;    line-height: 1.3em;    overflow: auto;}</style></head><body><div id="content"><h1>Emacs and Pairs</h1><p><center>August 15, 2015</center> <center>Updated: March 13, 2017</center></p><p>In this post, I’ll exclusively talk about <i>smartparens</i> — a package that you wish you should have used, earlier, presuming you don’t use it yet. If you’re new to it, read along; if not, this may be a good refresher.</p><p><i>smartparens</i> is one of those packages that drastically improves, and changes how one uses Emacs. It’s like having cybernetic limbs — it makes you jump higher, and punch harder.</p><p>Take note, though, that the name is a misnomer, as it not only handles parentheses. It handles just about anything that pairs, and it performs those functions stellarly.</p><h2>Table of contents</h2><ul><li><a href='#installation'>Installation</a></li><li><a href='#configuration'>Configuration</a></li><li><a href='#usage'>Usage</a><ul><li><a href='#basics'>Basics</a></li><li><a href='#navigation'>Navigation</a><ul><li><a href='#startsandends'>Starts and ends</a></li><li><a href='#traversinglists'>Traversing lists</a></li><li><a href='#blockmovements'>Block movements</a></li><li><a href='#toplevel'>Top-level-ish traversal</a></li><li><a href='#freeform'>Free-form movements</a></li></ul></li><li><a href='#manipulation'>Manipulation</a><ul><li><a href='#wrapping'>Wrapping</a></li><li><a href='#unwrapping'>Unwrapping</a></li><li><a href='#slurpandbarf'>Slurp and barf</a></li><li><a href='#swapping'>Swapping</a></li><li><a href='#killing'>Killing</a></li></ul></li></ul></li><li><a href='#keys'>Keys</a></li><li><a href='#closing'>Closing remarks</a></li></ul><h2>Installation <a name="installation"></a></h2><p>Installing smartparens is straightforward:</p><pre><code>M-x package-install RET smartparens RET
</code></pre><h2>Configuration <a name="configuration"></a></h2><p>Let’s enable smartparens on startup, and hook it with some major hooks:</p><pre><code class="lisp">&#40;use-package smartparens-config
    :ensure smartparens
    :config
    &#40;progn
      &#40;show-smartparens-global-mode t&#41;&#41;&#41;

&#40;add-hook 'prog-mode-hook 'turn-on-smartparens-strict-mode&#41;
&#40;add-hook 'markdown-mode-hook 'turn-on-smartparens-strict-mode&#41;
</code></pre><h2>Usage <a name="usage"></a></h2><p>Managing paired characters like parentheses, braces, brackets, quotation marks, angle brackets, and other conceivable pair-able characters has always been a pain. Other packages solve that problem partially. However, they it still miss several points. In the code snippets below, the <code>&#95;</code> symbol will be used to represent point:</p><h3>Basics <a name="basics"></a></h3><p>In smartparens, when you input a pair-able character:</p><pre><code class="clojure">
&#40;defn foo &#41;
          ̅
</code></pre><p>the matching pair gets inserted, too, and point is positioned inside the pair:</p><pre><code class="clojure">
&#40;defn foo &#91;&#93;&#41;
           ̅
</code></pre><h3>Navigation <a name="navigation"></a></h3><h4>Starts and ends <a name="startsandends"></a></h4><p>If you have the expression:</p><pre><code class="clojure">
&#40;let &#91;x &quot;foo bar baz ... blah&quot;&#93;&#41;
                         ̅
</code></pre><p>and you want to move point to the start of the string:</p><pre><code class="clojure">
&#40;let &#91;x &quot;foo bar baz ... blah&quot;&#93;&#41;
         ̅
</code></pre><p>Execute <code>sp-beginning-of-sexp</code>. I bound it to <kbd>C-M-a</kbd>.</p><p>Conversely, to move point to the end of the expression:</p><pre><code class="clojure">
&#40;let &#91;x &quot;foo bar baz ... blah&quot;&#93;&#41;
                             ̅
</code></pre><p>Execute <code>sp-end-of-sexp</code>. I bound it to <kbd>C-M-e</kbd>.</p><h4>Traversing lists <a name="traversinglists"></a></h4><p>If you have the expression:</p><pre><code class="lisp">
&#40;defun format-date &#40;format&#41;
  &#40;let &#40;&#40;system-time-locale &quot;en&#95;US.UTF-8&quot;&#41;&#41;
    &#40;insert &#40;format-time-string format&#41;&#41;&#41;&#41; ̅

</code></pre><p>and you want to move point to <strong>insert</strong>:</p><pre><code class="lisp">
&#40;defun format-date &#40;format&#41;
  &#40;let &#40;&#40;system-time-locale &quot;en&#95;US.UTF-8&quot;&#41;&#41;
    &#40;insert &#40;format-time-string format&#41;&#41;&#41;&#41;
     ̅
</code></pre><p>Execute <code>sp-down-sexp</code>. I bound it to <kbd>C-down</kbd>.</p><p>If you have the expression:</p><pre><code class="clojure">
&#40;str &quot;foo&quot; &quot;bar baz qux&quot;&#41;
    ̅
</code></pre><p>and you want to move point after <strong>)</strong>:</p><pre><code class="clojure">
&#40;str &quot;foo&quot; &quot;bar baz qux&quot;&#41;
                         ̅
</code></pre><p>Execute <code>sp-up-sexp</code>. I bound it to <kbd>C-up</kbd>.</p><p>If you have the expression:</p><pre><code class="clojure">
&#40;defn foo &#91;bar&#93; &#40;let &#91;x 0&#93; x&#41;&#41;
                ̅
</code></pre><p>and you want to move point to <strong>]</strong>:</p><pre><code class="clojure">
&#40;defn foo &#91;bar&#93; &#40;let &#91;x 0&#93; x&#41;&#41;
              ̅
</code></pre><p>Execute <code>sp-backward-down-sexp</code>. I bound it to <kbd>M-down</kbd>.</p><p>If you have the expression:</p><pre><code class="lisp">
&#40;insert &#40;format-time-string format&#41;&#41;
                           ̅
</code></pre><p>and you want to move point to <strong>(format</strong>:</p><pre><code class="lisp">
&#40;insert &#40;format-time-string format&#41;&#41;
        ̅
</code></pre><p>Execute <code>sp-backward-up-sexp</code>. I bound it to <kbd>M-up</kbd>.</p><h4>Block movements <a name="blockmovements"></a></h4><p>If you have the expression:</p><pre><code class="clojure">
&#40;:require &#91;clojure.string :as s&#93;&#41;
          ̅
</code></pre><p>and you want to move point after <strong>]</strong>:</p><pre><code class="clojure">
&#40;:require &#91;clojure.string :as s&#93;&#41;
                                ̅
</code></pre><p>Execute <code>sp-forward-sexp</code>. I bound it to <kbd>C-M-f</kbd></p><p>Conversely, to move it to <strong>[</strong>:</p><pre><code class="clojure">
&#40;:require &#91;clojure.string :as s&#93;&#41;
          ̅
</code></pre><p>Execute <code>sp-backward-sexp</code>. I bound it to <kbd>C-M-b</kbd>.</p><h4>Top-level-ish traversal <a name="toplevel"></a></h4><p>If you have the expression:</p><pre><code class="clojure">
&#40;defn blah
  &quot;Returns blah of foo.&quot;
  &#91;foo&#93;                 ̅
  &#41;

</code></pre><p>and you want to move point to <strong>[</strong>:</p><pre><code class="clojure">
&#40;defn blah
  &quot;Returns blah of foo.&quot;
  &#91;foo&#93;
  ̅&#41;

</code></pre><p>Execute <code>sp-next-sexp</code>. I bound it to <kbd>C-M-n</kbd>.</p><p>Conversely, to move it back:</p><pre><code class="clojure">
&#40;defn blah
  &quot;Returns blah of foo.&quot;
  &#91;foo&#93;                 ̅
  &#41;

</code></pre>Execute <code>sp-previous-sexp</code>. I bound it to <kbd>C-M-p</kbd>.<h4>Free-form movements <a name="freeform"></a></h4><p>If you have the expression:</p><pre><code class="clojure">
&#40;defn blah &#91;&#93; &#40;let &#91;x 0 y 1&#93; &#40;+ x 1&#41;&#41;&#41;
               ̅
</code></pre><p>and you want to move point to <strong>blah</strong>:</p><pre><code class="clojure">
&#40;defn blah &#91;&#93; &#40;let &#91;x 0 y 1&#93; &#40;+ x 1&#41;&#41;&#41;
      ̅
</code></pre><p>Execute, <code>sp-backward-symbol</code>. I bound it to <kbd>C-S-b</kbd>.</p><p>Conversely, if you have the expression:</p><pre><code class="clojure">
&#40;defn blah &#91;&#93; &#40;let &#91;x 0 y 1&#93; &#40;+ x 1&#41;&#41;&#41;
            ̅
</code></pre><p>and you want to move point just after <strong>(let</strong>:</p><pre><code class="clojure">
&#40;defn blah &#91;&#93; &#40;let &#91;x 0 y 1&#93; &#40;+ x 1&#41;&#41;&#41;
                  ̅
</code></pre><p>Execute <code>sp-forward-symbol</code>. I bound it to <kbd>C-S-f</kbd>.</p><p>What they do is that they navigate around expressions as if delimiters, like parens, brackets, and braces do not exist.</p><h3>Manipulation <a name="manipulation"></a></h3><h4>Wrapping <a name="wrapping"></a></h4><p>If you have the expression:</p><pre><code class="javascript">
var mods = &quot;vars&quot;;
           ̅
</code></pre><p>and you want <strong>"vars"</strong> to be surrounded by <strong>[</strong>, and <strong>]</strong>:</p><pre><code class="javascript">
var mods = &#91;&quot;vars&quot;&#93;;
            ̅
</code></pre><p>Press <kbd>C-M-Space</kbd> followed by <kbd>[</kbd>, the whole region becomes surrounded by matching <strong>[</strong>, and <strong>]</strong>. It also applies to keys like <code>&#40;</code>, <code>{</code>, <code>&quot;</code>, <code>'</code>, <code>&#42;</code>, <code>&#95;</code>, etc, depending on the mode that you’re using.</p><p>Alternatively, define wrapping functions:</p><pre><code class="lisp">&#40;defmacro def-pairs &#40;pairs&#41;
  `&#40;progn
     ,@&#40;loop for &#40;key . val&#41; in pairs
          collect
            `&#40;defun ,&#40;read &#40;concat
                            &quot;wrap-with-&quot;
                            &#40;prin1-to-string key&#41;
                            &quot;s&quot;&#41;&#41;
                 &#40;&amp;optional arg&#41;
               &#40;interactive &quot;p&quot;&#41;
               &#40;sp-wrap-with-pair ,val&#41;&#41;&#41;&#41;&#41;

&#40;def-pairs &#40;&#40;paren . &quot;&#40;&quot;&#41;
            &#40;bracket . &quot;&#91;&quot;&#41;
            &#40;brace . &quot;{&quot;&#41;
            &#40;single-quote . &quot;'&quot;&#41;
            &#40;double-quote . &quot;\&quot;&quot;&#41;
            &#40;back-quote . &quot;`&quot;&#41;&#41;&#41;
</code></pre><p>These have the advantage of not requiring a region to operate on. I bound the first three functions to <kbd>C-c (</kbd>, <kbd>C-c [</kbd>, and <kbd>C-c {</kbd>, respectively. So, if you have the expression:</p><pre><code class="clojure">
&#40;defn foo args &#40;let &#91;x 0&#93; &#40;inc x&#41;&#41;&#41;
          ̅
</code></pre><p>and you want to surround <strong>args</strong> with <strong>[<strong> and </strong>]</strong>:</p><pre><code class="clojure">
&#40;defn foo &#91;args&#93; &#40;let &#91;x 0&#93; &#40;inc x&#41;&#41;&#41;
           ̅
</code></pre><p>Press <kbd>C-c [</kbd>.</p><p>Sometimes, we inadvertently delete one of the pair characters — this results in an unbalanced expression. smartparens prevents us from doing that. If you hit <kbd>Backspace</kbd> in this expression:</p><pre><code class="javascript">
var mods = &#91;&quot;vars&quot;&#93;;
            ̅
</code></pre><p>Nothing will happen. smartparens saves us a lot of trouble, here.</p><h4>Unwrapping <a name="unwrapping"></a></h4><p>If you have the expression:</p><pre><code class="clojure">
&#40;foo &#40;bar x y z&#41;&#41;
     ̅
</code></pre><p>and you want to unwrap the <strong>bar</strong> expression, removing the parentheses around <strong>foo</strong>:</p><pre><code class="clojure">
foo &#40;bar x y z&#41;
    ̅
</code></pre><p>Execute <code>sp-backward-unwrap-sexp</code>. I bound it to <kbd>M-[</kbd></p><p>Conversely, if you want to unwrap the <strong>bar</strong> expression, removing the parentheses around <strong>bar</strong>:</p><pre><code class="clojure">
&#40;foo bar x y z&#41;
     ̅
</code></pre><p>Execute <code>sp-unwrap-sexp</code>. I bound it to <kbd>M-]</kbd>.</p><h4>Slurp and barf <a name="slurpandbarf"></a></h4><p>If you have the expression:</p><pre><code class="clojure">
&#91;foo bar&#93; baz
        ̅
</code></pre><p>and you want <strong>baz</strong> to be part of <strong>foo</strong> and <strong>bar</strong>:</p><pre><code class="clojure">
&#91;foo bar baz&#93;
        ̅
</code></pre><p>Execute <code>sp-forward-slurp-sexp</code>. I bound it to <kbd>C-right</kbd>.</p><p>Conversely, if you want to remove <strong>baz</strong>:</p><pre><code class="clojure">
&#91;foo bar&#93; baz
        ̅
</code></pre><p>Execute <code>sp-forward-barf-sexp</code>. I bound it to <kbd>M-right</kbd>.</p><p>If you have the expression:</p><pre><code class="clojure">
blah &#91;foo bar&#93;
             ̅
</code></pre><p>and you want <strong>blah</strong> to be part of <strong>foo</strong> and <strong>bar</strong>:</p><pre><code class="clojure">
&#91;blah foo bar&#93;
             ̅
</code></pre><p>Execute <code>sp-backward-slurp-sexp</code>. I bound it to <kbd>C-left</kbd>.</p><p>Conversely, if you want to remove <strong>blah</strong>:</p><pre><code class="clojure">
blah &#91;foo bar&#93;
             ̅
</code></pre><p>Execute <code>sp-backward-barf-sexp</code>. I bound it to <kbd>M-left</kbd>.</p><h4>Swapping <a name="swapping"></a></h4><p>If you have the expression:</p><pre><code class="clojure">
&quot;foo&quot; &quot;bar&quot;
      ̅
</code></pre><p>and you want <strong>"foo"</strong> and <strong>"bar"</strong> to switch places:</p><pre><code class="clojure">
&quot;bar&quot; &quot;foo&quot;
      ̅
</code></pre><p>Execute <code>sp-transpose-sexp</code>. I bound it to <kbd>C-M-t</kbd>.</p><h4>Killing <a name="killing"></a></h4><p>If you have the expression:</p><pre><code class="clojure">
&#40;let &#91;x &quot;xxx&quot; y &quot;y yy yyy&quot; z 0&#93;&#41;
               ̅
</code></pre><p>and you want to kill just <strong>"y yy yyy"</strong>:</p><pre><code class="clojure">
&#40;let &#91;x &quot;xxx&quot; y z 0&#93;&#41;
               ̅
</code></pre><p>Execute <code>sp-kill-sexp</code>. I bound it to <kbd>C-M-k</kbd>.</p><p>If you want to kill <strong>"y yy yyy" z 0</strong>:</p><pre><code class="clojure">
&#40;let &#91;x &quot;xxx&quot; y&#93;&#41;
               ̅
</code></pre><p>Execute <code>sp-kill-hybrid-sexp</code>. I bound it to <kbd>C-k</kbd>.</p><p>If you have the expression:</p><pre><code class="clojure">
&#40;:require &#91;clojure.string :as s&#93;&#41;
                                ̅
</code></pre><p>and you want to kill <strong>[clojure.string :as s]</strong>:</p><pre><code class="clojure">
&#40;:require &#41;
          ̅
</code></pre><p>Execute <code>sp-backward-kill-sexp</code>. I bound it to <kbd>M-k</kbd></p><h2>Keys <a name="keys"></a></h2><p>The following snippet summarizes the key bindings used in this article. I use <strong>bind-keys</strong> to conveniently map my keys. I discussed about it, in an <a href='emacs-hacks-2.html'>earlier</a> article.</p><pre><code class="lisp">&#40;bind-keys
 :map smartparens-mode-map
 &#40;&quot;C-M-a&quot; . sp-beginning-of-sexp&#41;
 &#40;&quot;C-M-e&quot; . sp-end-of-sexp&#41;

 &#40;&quot;C-&lt;down&gt;&quot; . sp-down-sexp&#41;
 &#40;&quot;C-&lt;up&gt;&quot;   . sp-up-sexp&#41;
 &#40;&quot;M-&lt;down&gt;&quot; . sp-backward-down-sexp&#41;
 &#40;&quot;M-&lt;up&gt;&quot;   . sp-backward-up-sexp&#41;

 &#40;&quot;C-M-f&quot; . sp-forward-sexp&#41;
 &#40;&quot;C-M-b&quot; . sp-backward-sexp&#41;

 &#40;&quot;C-M-n&quot; . sp-next-sexp&#41;
 &#40;&quot;C-M-p&quot; . sp-previous-sexp&#41;

 &#40;&quot;C-S-f&quot; . sp-forward-symbol&#41;
 &#40;&quot;C-S-b&quot; . sp-backward-symbol&#41;

 &#40;&quot;C-&lt;right&gt;&quot; . sp-forward-slurp-sexp&#41;
 &#40;&quot;M-&lt;right&gt;&quot; . sp-forward-barf-sexp&#41;
 &#40;&quot;C-&lt;left&gt;&quot;  . sp-backward-slurp-sexp&#41;
 &#40;&quot;M-&lt;left&gt;&quot;  . sp-backward-barf-sexp&#41;

 &#40;&quot;C-M-t&quot; . sp-transpose-sexp&#41;
 &#40;&quot;C-M-k&quot; . sp-kill-sexp&#41;
 &#40;&quot;C-k&quot;   . sp-kill-hybrid-sexp&#41;
 &#40;&quot;M-k&quot;   . sp-backward-kill-sexp&#41;
 &#40;&quot;C-M-w&quot; . sp-copy-sexp&#41;
 &#40;&quot;C-M-d&quot; . delete-sexp&#41;

 &#40;&quot;M-&lt;backspace&gt;&quot; . backward-kill-word&#41;
 &#40;&quot;C-&lt;backspace&gt;&quot; . sp-backward-kill-word&#41;
 &#40;&#91;remap sp-backward-kill-word&#93; . backward-kill-word&#41;

 &#40;&quot;M-&#91;&quot; . sp-backward-unwrap-sexp&#41;
 &#40;&quot;M-&#93;&quot; . sp-unwrap-sexp&#41;

 &#40;&quot;C-x C-t&quot; . sp-transpose-hybrid-sexp&#41;

 &#40;&quot;C-c &#40;&quot;  . wrap-with-parens&#41;
 &#40;&quot;C-c &#91;&quot;  . wrap-with-brackets&#41;
 &#40;&quot;C-c {&quot;  . wrap-with-braces&#41;
 &#40;&quot;C-c '&quot;  . wrap-with-single-quotes&#41;
 &#40;&quot;C-c \&quot;&quot; . wrap-with-double-quotes&#41;
 &#40;&quot;C-c &#95;&quot;  . wrap-with-underscores&#41;
 &#40;&quot;C-c `&quot;  . wrap-with-back-quotes&#41;&#41;
</code></pre><h2>Closing remarks <a name="closing"></a></h2><p>The plethora of commands in smartparens may be daunting at first, but the investement in time in learning them, will be minimal compared to benefits that you will reap.</p><p>smartparens is the brainchild of <a href='mailto:matus.goljer@gmail.com'>Matus Goljer</a>. For more information on smartparens, go to <a href="https://github.com/Fuco1/smartparens">https://github.com/Fuco1/smartparens</a>. If you like this project, you can donate <a href='https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=CEYP5YVHDRX8C'>here</a>.</p><hr/><div class="footer"><div class="text-small"><a href='index.html'>Home</a>  <a href='about.html'>About</a>  <a href='quotes.html'>Quotes</a>  <a href='words.html'>Words</a>  <a href='https://github.com/ebzzry/ebzzry.github.io'>Source</a></div><div class="text-x-small">Site created with <a href='https://github.com/ebzzry/emem'>emem</a></div><p><div class="text-x-small"> <a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" class="cc" src="images/cc4-88x31.png" /></a><br> This work by <a xmlns:cc="http://creativecommons.org/ns#" href="http://ebzzry.io" property="cc:attributionName" rel="cc:attributionURL">Rommel M. Martinez</a> is licensed under a<br> <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Common Attribution 4.0 International License</a>. </div></p><p></div></p><p><script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-93746003-1', 'auto'); ga('send', 'pageview'); </script></p></div><script src="static/js/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>