<!DOCTYPE html>
<html lang="en"><head><title>Emacs and Pairs</title><meta charset="utf-8" /><meta content="width=device-width,initial-scale=1.0,user-scalable=yes" name="viewport" /><meta content="noodp,noydir" name="robots" /><meta content="Emacs and Pairs" name="description" /><meta content="emacs, pairs, smartparens, paredit, parentheses, brackets, braces, configuration, setup, settings" name="keywords" /><meta content="Emacs and Pairs" property="og:title" /><meta content="article" property="og:type" /><meta content="https://ebzzry.io/en/emacs-pairs/" property="og:url" /><meta content="https://ebzzry.io/static/ico/android-chrome-512x512.png" property="og:image" /><link href="/static/ico/apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180" /><link href="/static/ico/favicon-16x16.png" rel="icon" sizes="16x16" type="image/png" /><link href="/static/ico/favicon-32x32.png" rel="icon" sizes="32x32" type="image/png" /><link href="/static/ico/manifest.json" rel="manifest" /><link color="#5bbad5" href="/static/ico/safari-pinned-tab.svg" rel="mask-icon" /><meta content="#ffffff" name="theme-color" /><style media="all" type="text/css">html {    color: #333;    font-size: 1em;    font-family: Georgia, Cambria, Palatino, "Palatino Linotype", "Times New Roman", Times, serif;    line-height: 1.45;    text-align: left:    width: 100%;    max-width: 40em;    margin: 0 auto 0 auto;    padding: 0;}body {    border-top: hidden;    border-bottom: hidden;    padding: 0 1.5em 1em 1.5em;    margin: 0;}#content {    -webkit-column-count: 1;    -moz-column-count: 1;    column-count: 1;}code {    font-size: 0.9em;    font-family: "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Lucida Console", "Courier New", Courier, monospace;    color: black;    display: inline-block;    font-weight: bold;}pre code {    font-size: 1em;    font-family: monospace;    line-height: 1.3em;    overflow: auto;    font-weight: normal;}kbd {    font-size: 1.1em;    padding: 0.1em 0.6em;    border: 1px solid #ccc;    font-family: monospace;    background-color: #f7f7f7;    color: #333;    -moz-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    -webkit-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    -moz-border-radius: 3px;    -webkit-border-radius: 3px;    border-radius: 3px;    display: inline-block;    margin: 0 0.1em;    text-shadow: 0 1px 0 #fff;    white-space: nowrap;}h1, h2, h3, h4, h5, h6 {    font-family: Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans", Tahoma, Geneva, Helvetica, Arial, sans-serif;    margin-bottom: 0;}h1 {    font-size: 2.5em;    text-align: center;    border-bottom: 6px solid black;}h2 {    font-size: 2.0em;    text-align: left;    border-bottom: 2px solid black;}h3 {    font-size: 1.6em;    text-align: left;    border-bottom: 1px solid lightgrey;}h4 {    font-size: 1.5em;    text-align: left;}h5 {    font-size: 1.3em;    text-align: left;}ul, ol {    padding-left: 2em;}ul li {    list-style-type: square;}ul li li {    list-style-type: disc;}ul li li li {    list-style-type: circle;}ol li {    list-style-type: decimal;}p, para, b, strong, i, em, emph {    font-size: 1em;}blockquote {    font-size: 1.2em;    font-style: italic;    margin-left: 2em;}b, strong {    font-weight: bold;}i, em, emph {    font-style: italic;}table {    margin: 0.5em;    border-spacing: 0;    border-collapse: collapse;}th, td {    border: 1px solid lightgray;    padding-top: 0;    padding-bottom: 0;    padding-left: 0.45em;    padding-right: 0.45em;}.text-right {    text-align: right;}.text-small {    font-size: small;}.text-x-small {    font-size: x-small;}.banner {    display: block;    width: 100%;    margin-left: auto;    margin-right: auto;}.footer {    text-align: right;    float: right;    max-width: 18em;}.cc {    border-width: 0}.center {    text-align: center;}</style><style media="all" type="text/css">/* Ewan Themes -- based 99.99% from Tomorrow Night Theme *//* http://jmblog.github.com/color-themes-for-google-code-highlightjs *//* Original theme - https://github.com/chriskempson/tomorrow-theme *//* http://jmblog.github.com/color-themes-for-google-code-highlightjs *//* Tomorrow Comment */.hljs-comment {  color: #969896;}/* Tomorrow Red */.hljs-variable,.hljs-attribute,.hljs-tag,.hljs-regexp,.ruby .hljs-constant,.xml .hljs-tag .hljs-title,.xml .hljs-pi,.xml .hljs-doctype,.html .hljs-doctype,.css .hljs-id,.css .hljs-class,.css .hljs-pseudo {  color: #cc6666;}/* Tomorrow Orange */.hljs-number,.hljs-preprocessor,.hljs-pragma,.hljs-built_in,.hljs-literal,.hljs-params,.hljs-constant {  color: #de935f;}/* Tomorrow Yellow */.ruby .hljs-class .hljs-title,.css .hljs-rule .hljs-attribute {  color: #f0c674;}/* Tomorrow Green */.hljs-string,.hljs-value,.hljs-inheritance,.hljs-header,.hljs-name,.ruby .hljs-symbol,.xml .hljs-cdata {  color: #b5bd68;}/* Tomorrow Aqua */.hljs-title,.css .hljs-hexcolor {  color: #8abeb7;}/* Tomorrow Blue */.hljs-function,.python .hljs-decorator,.python .hljs-title,.ruby .hljs-function .hljs-title,.ruby .hljs-title .hljs-keyword,.perl .hljs-sub,.javascript .hljs-title,.coffeescript .hljs-title {  color: #81a2be;}/* Tomorrow Purple */.hljs-keyword,.javascript .hljs-function {  color: #b294bb;}.hljs {  display: block;  overflow-x: auto;  background: #1d1f21;  color: #c5c8c6;  padding: 0.5em;  -webkit-text-size-adjust: none;}.coffeescript .javascript,.javascript .xml,.tex .hljs-formula,.xml .javascript,.xml .vbscript,.xml .css,.xml .hljs-cdata {  opacity: 0.5;}pre code {    font-size: 1.1em;    font-family: monospace;    line-height: 1.3em;    overflow: auto;}</style></head><body><div id="content"><h1>Emacs and Pairs</h1><p><div class="center">August 15, 2015</div> <div class="center">Last updated: March 31, 2017</div></p><blockquote><p>The white noise that beats within the white darkness is the rhythm of life; it is that pulse which never truly left the stage.<br> ―Ergo Proxy, Ergo Proxy </p></blockquote><p>In this article, I’ll exclusively talk about <i>smartparens</i>—a package that you wish you should have used, earlier, presuming you don’t use it yet. If you’re new to it, read along; if not, this may be a good refresher.</p><p><i>smartparens</i> is one of those packages that drastically improves, and changes how one uses Emacs. It’s like having cybernetic limbs—it makes you jump higher and punch harder.</p><p>Take note, though, that the name is a misnomer, as it not only handles parentheses. It handles just about anything that pairs, and it performs those functions stellarly.</p><h2>Table of contents</h2><ul><li><a href='#installation'>Installation</a></li><li><a href='#configuration'>Configuration</a></li><li><a href='#usage'>Usage</a><ul><li><a href='#basics'>Basics</a></li><li><a href='#navigation'>Navigation</a><ul><li><a href='#startsandends'>Starts and ends</a></li><li><a href='#traversinglists'>Traversing lists</a></li><li><a href='#blockmovements'>Block movements</a></li><li><a href='#toplevel'>Top-level-ish traversal</a></li><li><a href='#freeform'>Free-form movements</a></li></ul></li><li><a href='#manipulation'>Manipulation</a><ul><li><a href='#wrapping'>Wrapping</a></li><li><a href='#unwrapping'>Unwrapping</a></li><li><a href='#slurpandbarf'>Slurp and barf</a></li><li><a href='#swapping'>Swapping</a></li><li><a href='#killing'>Killing</a></li></ul></li></ul></li><li><a href='#keys'>Keys</a></li><li><a href='#closing'>Closing remarks</a></li></ul><h2><a name="installation"></a> Installation</h2><p>Installing smartparens is straightforward:</p><pre><code>M-x package-install RET smartparens RET
</code></pre><h2><a name="configuration"></a> Configuration</h2><p>Let’s enable smartparens on startup, and hook it with some major hooks:</p><pre><code class="lisp">&#40;use-package smartparens-config
    :ensure smartparens
    :config
    &#40;progn
      &#40;show-smartparens-global-mode t&#41;&#41;&#41;

&#40;add-hook 'prog-mode-hook 'turn-on-smartparens-strict-mode&#41;
&#40;add-hook 'markdown-mode-hook 'turn-on-smartparens-strict-mode&#41;
</code></pre><h2><a name="usage"></a> Usage</h2><p>Managing paired characters like parentheses, braces, brackets, quotation marks, angle brackets, and other conceivable pair-able characters has always been a pain. Other packages solve that problem partially. However, they it still miss several points.</p><p>In the code snippets below, the <code>&#94;</code> symbol will be used to represent point:</p><h3><a name="basics"></a> Basics</h3><p>In smartparens, when you input a pair-able character:</p><pre><code class="clojure">
&#40;defn foo &#41;
          &#94;
</code></pre><p>the matching pair gets inserted, too, and point is positioned inside the pair:</p><pre><code class="clojure">
&#40;defn foo &#91;&#93;&#41;
           &#94;
</code></pre><h3><a name="navigation"></a> Navigation</h3><h4><a name="startsandends"></a> Starts and ends</h4><p>If you have the expression:</p><pre><code class="clojure">
&#40;let &#91;x &quot;foo bar baz ... blah&quot;&#93;&#41;
                         &#94;
</code></pre><p>and you want to move point to the start of the string:</p><pre><code class="clojure">
&#40;let &#91;x &quot;foo bar baz ... blah&quot;&#93;&#41;
         &#94;
</code></pre><p>Execute <code>sp-beginning-of-sexp</code>. I bound it to <kbd>C-M-a</kbd>.</p><p>Conversely, to move point to the end of the expression:</p><pre><code class="clojure">
&#40;let &#91;x &quot;foo bar baz ... blah&quot;&#93;&#41;
                             &#94;
</code></pre><p>Execute <code>sp-end-of-sexp</code>. I bound it to <kbd>C-M-e</kbd>.</p><h4><a name="traversinglists"></a> Traversing lists</h4><p>If you have the expression:</p><pre><code class="lisp">
&#40;defun format-date &#40;format&#41;
  &#40;let &#40;&#40;system-time-locale &quot;en&#95;US.UTF-8&quot;&#41;&#41;
    &#40;insert &#40;format-time-string format&#41;&#41;&#41;&#41; &#94;

</code></pre><p>and you want to move point to <code>insert</code>:</p><pre><code class="lisp">
&#40;defun format-date &#40;format&#41;
  &#40;let &#40;&#40;system-time-locale &quot;en&#95;US.UTF-8&quot;&#41;&#41;
    &#40;insert &#40;format-time-string format&#41;&#41;&#41;&#41;
     &#94;
</code></pre><p>Execute <code>sp-down-sexp</code>. I bound it to <kbd>C-down</kbd>.</p><p>If you have the expression:</p><pre><code class="clojure">
&#40;str &quot;foo&quot; &quot;bar baz qux&quot;&#41;
    &#94;
</code></pre><p>and you want to move point after <code>&#41;</code>:</p><pre><code class="clojure">
&#40;str &quot;foo&quot; &quot;bar baz qux&quot;&#41;
                         &#94;
</code></pre><p>Execute <code>sp-up-sexp</code>. I bound it to <kbd>C-up</kbd>.</p><p>If you have the expression:</p><pre><code class="clojure">
&#40;defn foo &#91;bar&#93; &#40;let &#91;x 0&#93; x&#41;&#41;
                &#94;
</code></pre><p>and you want to move point to the preceeding <code>&#93;</code>:</p><pre><code class="clojure">
&#40;defn foo &#91;bar&#93; &#40;let &#91;x 0&#93; x&#41;&#41;
              &#94;
</code></pre><p>Execute <code>sp-backward-down-sexp</code>. I bound it to <kbd>M-down</kbd>.</p><p>If you have the expression:</p><pre><code class="lisp">
&#40;insert &#40;format-time-string format&#41;&#41;
                           &#94;
</code></pre><p>and you want to move point to <code>&#40;format</code>:</p><pre><code class="lisp">
&#40;insert &#40;format-time-string format&#41;&#41;
        &#94;
</code></pre><p>Execute <code>sp-backward-up-sexp</code>. I bound it to <kbd>M-up</kbd>.</p><h4><a name="blockmovements"></a> Block movements</h4><p>If you have the expression:</p><pre><code class="clojure">
&#40;:require &#91;clojure.string :as s&#93;&#41;
          &#94;
</code></pre><p>and you want to move point after <code>&#93;</code>:</p><pre><code class="clojure">
&#40;:require &#91;clojure.string :as s&#93;&#41;
                                &#94;
</code></pre><p>Execute <code>sp-forward-sexp</code>. I bound it to <kbd>C-M-f</kbd></p><p>Conversely, to move it back to <code>&#91;</code>:</p><pre><code class="clojure">
&#40;:require &#91;clojure.string :as s&#93;&#41;
          &#94;
</code></pre><p>Execute <code>sp-backward-sexp</code>. I bound it to <kbd>C-M-b</kbd>.</p><h4><a name="toplevel"></a> Top-level-ish traversal</h4><p>If you have the expression:</p><pre><code class="clojure">
&#40;defn blah
  &quot;Returns blah of foo.&quot;
  &#91;foo&#93;                 &#94;
  &#41;

</code></pre><p>and you want to move point to <code>&#91;</code>:</p><pre><code class="clojure">
&#40;defn blah
  &quot;Returns blah of foo.&quot;
  &#91;foo&#93;
  &#94;&#41;

</code></pre><p>Execute <code>sp-next-sexp</code>. I bound it to <kbd>C-M-n</kbd>.</p><p>Conversely, to move it back:</p><pre><code class="clojure">
&#40;defn blah
  &quot;Returns blah of foo.&quot;
  &#91;foo&#93;                 &#94;
  &#41;

</code></pre>Execute <code>sp-previous-sexp</code>. I bound it to <kbd>C-M-p</kbd>.<h4><a name="freeform"></a> Free-form movements</h4><p>If you have the expression:</p><pre><code class="clojure">
&#40;defn blah &#91;&#93; &#40;let &#91;x 0 y 1&#93; &#40;+ x 1&#41;&#41;&#41;
               &#94;
</code></pre><p>and you want to move point to <code>blah</code>:</p><pre><code class="clojure">
&#40;defn blah &#91;&#93; &#40;let &#91;x 0 y 1&#93; &#40;+ x 1&#41;&#41;&#41;
      &#94;
</code></pre><p>Execute, <code>sp-backward-symbol</code>. I bound it to <kbd>C-S-b</kbd>.</p><p>Conversely, if you have the expression:</p><pre><code class="clojure">
&#40;defn blah &#91;&#93; &#40;let &#91;x 0 y 1&#93; &#40;+ x 1&#41;&#41;&#41;
            &#94;
</code></pre><p>and you want to move point just after <code>&#40;let</code>:</p><pre><code class="clojure">
&#40;defn blah &#91;&#93; &#40;let &#91;x 0 y 1&#93; &#40;+ x 1&#41;&#41;&#41;
                  &#94;
</code></pre><p>Execute <code>sp-forward-symbol</code>. I bound it to <kbd>C-S-f</kbd>.</p><p>What they do is that they navigate around expressions as if delimiters, like parens, brackets, and braces do not exist.</p><h3><a name="manipulation"></a> Manipulation</h3><h4><a name="wrapping"></a> Wrapping</h4><p>If you have the expression:</p><pre><code class="javascript">
var mods = &quot;vars&quot;;
           &#94;
</code></pre><p>and you want <code>&quot;vars&quot;</code> to be surrounded by <code>&#91;</code> and <code>&#93;</code>:</p><pre><code class="javascript">
var mods = &#91;&quot;vars&quot;&#93;;
            &#94;
</code></pre><p>Pressing <kbd>C-M-Space</kbd> or <kbd>ESC C-Space</kbd> followed by <kbd>[</kbd> will make the whole region become surrounded by matching <code>&#91;</code> and <code>&#93;</code>.  It also applies to keys like <code>&#40;</code>, <code>{</code>, <code>&quot;</code>, <code>'</code>, <code>&#42;</code>, <code>&#95;</code>, etc, depending on the mode that you’re using.</p><p>Alternatively, you may define wrapping functions:</p><pre><code class="lisp">&#40;defmacro def-pairs &#40;pairs&#41;
  `&#40;progn
     ,@&#40;loop for &#40;key . val&#41; in pairs
          collect
            `&#40;defun ,&#40;read &#40;concat
                            &quot;wrap-with-&quot;
                            &#40;prin1-to-string key&#41;
                            &quot;s&quot;&#41;&#41;
                 &#40;&amp;optional arg&#41;
               &#40;interactive &quot;p&quot;&#41;
               &#40;sp-wrap-with-pair ,val&#41;&#41;&#41;&#41;&#41;

&#40;def-pairs &#40;&#40;paren . &quot;&#40;&quot;&#41;
            &#40;bracket . &quot;&#91;&quot;&#41;
            &#40;brace . &quot;{&quot;&#41;
            &#40;single-quote . &quot;'&quot;&#41;
            &#40;double-quote . &quot;\&quot;&quot;&#41;
            &#40;back-quote . &quot;`&quot;&#41;&#41;&#41;
</code></pre><p>These have the advantage of not requiring a region to operate on. I bound the first three functions to <kbd>C-c (</kbd>, <kbd>C-c [</kbd>, and <kbd>C-c {</kbd>, respectively. So, if you have the expression:</p><pre><code class="clojure">
&#40;defn foo args &#40;let &#91;x 0&#93; &#40;inc x&#41;&#41;&#41;
          &#94;
</code></pre><p>and you want to surround <code>args</code> with <code>&#91;</code> and <code>&#93;</code>:</p><pre><code class="clojure">
&#40;defn foo &#91;args&#93; &#40;let &#91;x 0&#93; &#40;inc x&#41;&#41;&#41;
           &#94;
</code></pre><p>Press <kbd>C-c [</kbd>.</p><p>Sometimes, we inadvertently delete one of the pair characters—this results in an unbalanced expression. smartparens prevents us from doing that. If you hit <kbd>Backspace</kbd> in this expression:</p><pre><code class="javascript">
var mods = &#91;&quot;vars&quot;&#93;;
            &#94;
</code></pre><p>Nothing will happen. smartparens saves us a lot of trouble, here.</p><h4><a name="unwrapping"></a> Unwrapping</h4><p>If you have the expression:</p><pre><code class="clojure">
&#40;foo &#40;bar x y z&#41;&#41;
     &#94;
</code></pre><p>and you want to unwrap the <code>bar</code> expression, removing the parentheses around <code>foo</code>:</p><pre><code class="clojure">
foo &#40;bar x y z&#41;
    &#94;
</code></pre><p>Execute <code>sp-backward-unwrap-sexp</code>. I bound it to <kbd>M-[</kbd></p><p>Conversely, if you want to unwrap the <code>bar</code> expression, removing the parentheses around <code>bar</code>:</p><pre><code class="clojure">
&#40;foo bar x y z&#41;
     &#94;
</code></pre><p>Execute <code>sp-unwrap-sexp</code>. I bound it to <kbd>M-]</kbd>.</p><h4><a name="slurpandbarf"></a> Slurp and barf</h4><p>If you have the expression:</p><pre><code class="clojure">
&#91;foo bar&#93; baz
        &#94;
</code></pre><p>and you want <code>baz</code> to become part of <code>foo</code> and <code>bar</code>:</p><pre><code class="clojure">
&#91;foo bar baz&#93;
        &#94;
</code></pre><p>Execute <code>sp-forward-slurp-sexp</code>. I bound it to <kbd>C-right</kbd>.</p><p>Conversely, if you want to remove <code>baz</code>:</p><pre><code class="clojure">
&#91;foo bar&#93; baz
        &#94;
</code></pre><p>Execute <code>sp-forward-barf-sexp</code>. I bound it to <kbd>M-right</kbd>.</p><p>If you have the expression:</p><pre><code class="clojure">
blah &#91;foo bar&#93;
             &#94;
</code></pre><p>and you want <code>blah</code> to become part of <code>foo</code> and <code>bar</code>:</p><pre><code class="clojure">
&#91;blah foo bar&#93;
             &#94;
</code></pre><p>Execute <code>sp-backward-slurp-sexp</code>. I bound it to <kbd>C-left</kbd>.</p><p>Conversely, if you want to remove <code>blah</code>:</p><pre><code class="clojure">
blah &#91;foo bar&#93;
             &#94;
</code></pre><p>Execute <code>sp-backward-barf-sexp</code>. I bound it to <kbd>M-left</kbd>.</p><h4><a name="swapping"></a> Swapping</h4><p>If you have the expression:</p><pre><code class="clojure">
&quot;foo&quot; &quot;bar&quot;
      &#94;
</code></pre><p>and you want <code>&quot;foo&quot;</code> and <code>&quot;bar&quot;</code> to trade places:</p><pre><code class="clojure">
&quot;bar&quot; &quot;foo&quot;
      &#94;
</code></pre><p>Execute <code>sp-transpose-sexp</code>. I bound it to <kbd>C-M-t</kbd>.</p><h4><a name="killing"></a> Killing</h4><p>If you have the expression:</p><pre><code class="clojure">
&#40;let &#91;x &quot;xxx&quot; y &quot;y yy yyy&quot; z 0&#93;&#41;
               &#94;
</code></pre><p>and you want to kill just <code>&quot;y yy yyy&quot;</code>:</p><pre><code class="clojure">
&#40;let &#91;x &quot;xxx&quot; y z 0&#93;&#41;
               &#94;
</code></pre><p>Execute <code>sp-kill-sexp</code>. I bound it to <kbd>C-M-k</kbd>.</p><p>If you want to kill <code>&quot;y yy yyy&quot; z 0</code>:</p><pre><code class="clojure">
&#40;let &#91;x &quot;xxx&quot; y&#93;&#41;
               &#94;
</code></pre><p>Execute <code>sp-kill-hybrid-sexp</code>. I bound it to <kbd>C-k</kbd>.</p><p>If you have the expression:</p><pre><code class="clojure">
&#40;:require &#91;clojure.string :as s&#93;&#41;
                                &#94;
</code></pre><p>and you want to kill <code>&#91;clojure.string :as s&#93;</code>:</p><pre><code class="clojure">
&#40;:require &#41;
          &#94;
</code></pre><p>Execute <code>sp-backward-kill-sexp</code>. I bound it to <kbd>M-k</kbd></p><h2><a name="keys"></a> Keys</h2><p>The following snippet summarizes the key bindings used in this article. I use <code>bind-keys</code> to conveniently map my keys. I discussed about it, in an <a href='/en/emacs-tips-2'>earlier</a> article.</p><pre><code class="lisp">&#40;bind-keys
 :map smartparens-mode-map
 &#40;&quot;C-M-a&quot; . sp-beginning-of-sexp&#41;
 &#40;&quot;C-M-e&quot; . sp-end-of-sexp&#41;

 &#40;&quot;C-&lt;down&gt;&quot; . sp-down-sexp&#41;
 &#40;&quot;C-&lt;up&gt;&quot;   . sp-up-sexp&#41;
 &#40;&quot;M-&lt;down&gt;&quot; . sp-backward-down-sexp&#41;
 &#40;&quot;M-&lt;up&gt;&quot;   . sp-backward-up-sexp&#41;

 &#40;&quot;C-M-f&quot; . sp-forward-sexp&#41;
 &#40;&quot;C-M-b&quot; . sp-backward-sexp&#41;

 &#40;&quot;C-M-n&quot; . sp-next-sexp&#41;
 &#40;&quot;C-M-p&quot; . sp-previous-sexp&#41;

 &#40;&quot;C-S-f&quot; . sp-forward-symbol&#41;
 &#40;&quot;C-S-b&quot; . sp-backward-symbol&#41;

 &#40;&quot;C-&lt;right&gt;&quot; . sp-forward-slurp-sexp&#41;
 &#40;&quot;M-&lt;right&gt;&quot; . sp-forward-barf-sexp&#41;
 &#40;&quot;C-&lt;left&gt;&quot;  . sp-backward-slurp-sexp&#41;
 &#40;&quot;M-&lt;left&gt;&quot;  . sp-backward-barf-sexp&#41;

 &#40;&quot;C-M-t&quot; . sp-transpose-sexp&#41;
 &#40;&quot;C-M-k&quot; . sp-kill-sexp&#41;
 &#40;&quot;C-k&quot;   . sp-kill-hybrid-sexp&#41;
 &#40;&quot;M-k&quot;   . sp-backward-kill-sexp&#41;
 &#40;&quot;C-M-w&quot; . sp-copy-sexp&#41;
 &#40;&quot;C-M-d&quot; . delete-sexp&#41;

 &#40;&quot;M-&lt;backspace&gt;&quot; . backward-kill-word&#41;
 &#40;&quot;C-&lt;backspace&gt;&quot; . sp-backward-kill-word&#41;
 &#40;&#91;remap sp-backward-kill-word&#93; . backward-kill-word&#41;

 &#40;&quot;M-&#91;&quot; . sp-backward-unwrap-sexp&#41;
 &#40;&quot;M-&#93;&quot; . sp-unwrap-sexp&#41;

 &#40;&quot;C-x C-t&quot; . sp-transpose-hybrid-sexp&#41;

 &#40;&quot;C-c &#40;&quot;  . wrap-with-parens&#41;
 &#40;&quot;C-c &#91;&quot;  . wrap-with-brackets&#41;
 &#40;&quot;C-c {&quot;  . wrap-with-braces&#41;
 &#40;&quot;C-c '&quot;  . wrap-with-single-quotes&#41;
 &#40;&quot;C-c \&quot;&quot; . wrap-with-double-quotes&#41;
 &#40;&quot;C-c &#95;&quot;  . wrap-with-underscores&#41;
 &#40;&quot;C-c `&quot;  . wrap-with-back-quotes&#41;&#41;
</code></pre><h2><a name="closing"></a> Closing remarks</h2><p>The plethora of commands in smartparens may be daunting at first, but the investement in time in learning them, will be minimal compared to benefits that you will reap.</p><p>smartparens is the brainchild of <a href='mailto:matus.goljer@gmail.com'>Matus Goljer</a>. For more information on smartparens, go to <a href='https://github.com/Fuco1/smartparens'>here</a>. If you like this project, you may donate <a href='https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=CEYP5YVHDRX8C'>here</a>.</p><hr/><div class="footer"><p><div class="text-small"> <a href='/en'>Home</a> · <a href='/en/about'>About</a> · <a href='/en/quotes'>Quotes</a> · <a href='/en/reflections'>Reflections</a> · <a href='https://github.com/ebzzry/ebzzry.github.io'>Source</a> </div> <div class="text-x-small"> Created with <a href='https://github.com/ebzzry/emem'>emem</a> </div></p><p><div class="text-x-small"> <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/deed.en"><img alt="Creative Commons Attribution-ShareAlike 4.0 International License" class="cc" src="/bildoj/cc4-sa-88x31.png" /></a><br> Licensed under the <a rel="license" href="https://creativecommons.org/licenses/by-sa/4.0/deed.en">CC BY-SA 4.0 License.</a><br> </div></p><p></div></p></div><script src="/static/js/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create', 'UA-93746003-1', 'auto');ga('send', 'pageview');</script></body></html>