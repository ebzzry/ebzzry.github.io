<!DOCTYPE html>
<html lang="en"><head><title>How I Roll with Git</title><meta charset="utf-8" /><meta content="width=device-width,initial-scale=1.0,user-scalable=yes" name="viewport" /><meta content="noodp,noydir" name="robots" /><link rel='apple-touch-icon' sizes='180x180' href='/images/ico/apple-touch-icon.png'><link rel='icon' type='image/png' sizes='32x32' href='/images/ico/favicon-32x32.png'><link rel='icon' type='image/png' sizes='16x16' href='/images/ico/favicon-16x16.png'><link rel='manifest' href='/images/ico/site.webmanifest'><link rel='mask-icon' href='/images/ico/safari-pinned-tab.svg' color='#5bbad5'><link rel='shortcut icon' href='/images/ico/favicon.ico'> <meta name='msapplication-TileColor' content='#da532c'> <meta name='msapplication-config' content='/images/ico/browserconfig.xml'> <meta name='theme-color' content='#ffffff'><meta content="How I Roll with Git" name="description" /><meta content="git, shell, zsh, linux, mac, windows, setup, configuration" name="keywords" /><meta content="How I Roll with Git" property="og:title" /><meta content="article" property="og:type" /><meta content="https://ebzzry.com/en/git/" property="og:url" /><meta content="https://ebzzry.com/images/ico/android-chrome-512x512.png" property="og:image" /><style media="all" type="text/css">html {    color: #333;    font-size: 1em;    font-family: Georgia, Cambria, Palatino, "Palatino Linotype", "Times New Roman", Times, serif;    line-height: 1.45;    text-align: left:    width: 100%;    max-width: 40em;    margin: 0 auto 0 auto;    padding: 0;}body {    border-top: hidden;    border-bottom: hidden;    padding: 0 1.5em 1em 1.5em;    margin: 0;}#content {    -webkit-column-count: 1;    -moz-column-count: 1;    column-count: 1;}code {    font-size: 0.9em;    font-family: "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Lucida Console", "Courier New", Courier, monospace;    color: black;    display: inline-block;    font-weight: bold;}pre code {    font-size: 1em;    font-family: monospace;    line-height: 1.3em;    overflow: auto;    font-weight: normal;}kbd {    font-size: 1.1em;    padding: 0.1em 0.6em;    border: 1px solid #ccc;    font-family: monospace;    background-color: #f7f7f7;    color: #333;    -moz-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    -webkit-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    -moz-border-radius: 3px;    -webkit-border-radius: 3px;    border-radius: 3px;    display: inline-block;    margin: 0 0.1em;    text-shadow: 0 1px 0 #fff;    white-space: nowrap;}h1, h2, h3, h4, h5, h6 {    font-family: Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans", Tahoma, Geneva, Helvetica, Arial, sans-serif;    margin-bottom: 0;}h1 {    font-size: 2.5em;    text-align: center;    border-bottom: 6px solid black;}h2 {    font-size: 2.0em;    text-align: left;    border-bottom: 2px solid black;}h3 {    font-size: 1.6em;    text-align: left;    border-bottom: 1px solid lightgrey;}h4 {    font-size: 1.5em;    text-align: left;}h5 {    font-size: 1.3em;    text-align: left;}ul, ol {    padding-left: 2em;}ul li {    list-style-type: square;}ul li li {    list-style-type: disc;}ul li li li {    list-style-type: circle;}ol li {    list-style-type: decimal;}p, para, b, strong, i, em, emph {    font-size: 1em;}blockquote {    font-size: 1.2em;    font-style: italic;    margin-left: 2em;}b, strong {    font-weight: bold;}i, em, emph {    font-style: italic;}table {    margin: 0.5em;    border-spacing: 0;    border-collapse: collapse;}th, td {    border: 1px solid lightgray;    padding-top: 0;    padding-bottom: 0;    padding-left: 0.45em;    padding-right: 0.45em;}.text-right {    text-align: right;}.text-small {    font-size: small;}.text-x-small {    font-size: x-small;}.banner {    display: block;    width: 100%;    margin-left: auto;    margin-right: auto;}.footer {    text-align: right;    float: right;    max-width: 18em;}.cc {    border-width: 0}.center {    text-align: center;}</style><style media="all" type="text/css">html { max-width: 50em; } .footer { max-width: 24em }</style><style media="all" type="text/css">/* Ewan Themes -- based 99.99% from Tomorrow Night Theme *//* http://jmblog.github.com/color-themes-for-google-code-highlightjs *//* Original theme - https://github.com/chriskempson/tomorrow-theme *//* http://jmblog.github.com/color-themes-for-google-code-highlightjs *//* Tomorrow Comment */.hljs-comment {  color: #969896;}/* Tomorrow Red */.hljs-variable,.hljs-attribute,.hljs-tag,.hljs-regexp,.ruby .hljs-constant,.xml .hljs-tag .hljs-title,.xml .hljs-pi,.xml .hljs-doctype,.html .hljs-doctype,.css .hljs-id,.css .hljs-class,.css .hljs-pseudo {  color: #cc6666;}/* Tomorrow Orange */.hljs-number,.hljs-preprocessor,.hljs-pragma,.hljs-built_in,.hljs-literal,.hljs-params,.hljs-constant {  color: #de935f;}/* Tomorrow Yellow */.ruby .hljs-class .hljs-title,.css .hljs-rule .hljs-attribute {  color: #f0c674;}/* Tomorrow Green */.hljs-string,.hljs-value,.hljs-inheritance,.hljs-header,.hljs-name,.ruby .hljs-symbol,.xml .hljs-cdata {  color: #b5bd68;}/* Tomorrow Aqua */.hljs-title,.css .hljs-hexcolor {  color: #8abeb7;}/* Tomorrow Blue */.hljs-function,.python .hljs-decorator,.python .hljs-title,.ruby .hljs-function .hljs-title,.ruby .hljs-title .hljs-keyword,.perl .hljs-sub,.javascript .hljs-title,.coffeescript .hljs-title {  color: #81a2be;}/* Tomorrow Purple */.hljs-keyword,.javascript .hljs-function {  color: #b294bb;}.hljs {  display: block;  overflow-x: auto;  background: #1d1f21;  color: #c5c8c6;  padding: 0.5em;  -webkit-text-size-adjust: none;}.coffeescript .javascript,.javascript .xml,.tex .hljs-formula,.xml .javascript,.xml .vbscript,.xml .css,.xml .hljs-cdata {  opacity: 0.5;}pre code {    font-size: 1.1em;    font-family: monospace;    line-height: 1.3em;    overflow: auto;}</style></head><body><div id="content"><h1>How I Roll with Git</h1><p><div class="center"><a href='/eo/gito/'>Esperanto</a> • English</div> <div class="center">Last updated: September 19, 2024</div></p><blockquote><p>Conversely, those with persistence can ignore what others think. They can press on in their own world, oblivious to the opinions of those around them.<br> —Daigo Umehara </p></blockquote><p><img src="/images/site/simon-berger-6te9SupeW1g-unsplash-1008x250.webp" style="display: block; width: 100%; margin-left: auto; margin-right: auto;" alt="simon-berger-6te9SupeW1g-unsplash" title="simon-berger-6te9SupeW1g-unsplash"/></p><h2><a name="toc">Table of contents</a></h2><ul><li><a href='#introduction'>Introduction</a></li><li><a href='#short'>Short commands</a><ul><li><a href='#aliases'>Aliases</a></li><li><a href='#alternative'>Alternative</a></li></ul></li><li><a href='#configuration'>Configuration</a><ul><li><a href='#basefunction'>Base function</a></li><li><a href='#commands1'>Important commands</a></li><li><a href='#commands2'>Other commands</a></li></ul></li><li><a href='#all'>Putting them all together</a></li><li><a href='#closing'>Closing remarks</a></li></ul><h2><a name="introduction">Introduction</a></h2><p>In my toolbox are terminal simulator, shell, editor, browser, compiler, and git. When I encountered git several years ago, it became one of my most used tools. Because of its speed and range of use, it became as if my third arm.</p><p>Because I use Emacs, I also have <a href='https://magit.vc/'>Magit</a>. However, in this article I will talk about how I use git daily on the command line.</p><p>The commands and functions that we are going to have are for Zsh and Bash. It is possible that they also work on other shells, however, I haven’t tested them.</p><h2><a name="short">Short commands</a></h2><p>With git, if we want to see the status of a repository, we use the following command:</p><pre><code>git status</code></pre><p>However, there are many occasions when we want to use a shorter version:</p><pre><code>git s</code></pre><p>We use the shorter command maybe because we want to save typing time or it is physically easier instead of typing the whole command. In this section, I will talk about the existing methods to use shorter commands.</p><h3><a name="aliases">Aliases</a></h3><p>Git already has faculties for defining short commands. Example, if instead of</p><pre><code>git clone</code></pre><p>we use</p><pre><code>git c</code></pre><p>we define an alias for the <code>clone</code> command using the alias system of git. We can do that using two methods.</p><p>The first method is directly with the command line:</p><pre><code>git config --global alias.c clone</code></pre><p>The second method is using the configuration file, which is found it <code>&#126;/.gitconfig</code>. Put the following text in that file:</p><pre><code>&#91;alias&#93;
  c = clone
</code></pre><p>We can also use arbitrary commands inside the <code>alias</code> clause. There are two methods to do that.</p><p>The first method is directly as if a shell command:</p><pre><code>&#91;alias&#93;
  hello = &quot;! echo hello world&quot;
</code></pre><p>If we run the command</p><pre><code>git hello</code></pre><p>it will seem as if the following command was ran:</p><pre><code>echo hello world</code></pre><p>Consequently, the output is</p><pre><code>hello world</code></pre><p>The second method is with defining shell functions:</p><pre><code>&#91;alias&#93;
  hi = &quot;! hi &#40;&#41; { echo hi world; }; hi&quot;
</code></pre><p>If we run the command</p><pre><code>git hi</code></pre><p>it will seem as if the command command was ran:</p><pre><code>hi &#40;&#41; { echo hi world; }
hi</code></pre><p>With it, a shell function with the name <code>hi</code> was first defined, then we call that function. So, the output is:</p><pre><code>hi world</code></pre><h3><a name="alternative">Alternative</a></h3><p>While those methods are already fine with many users, they do not suffice with me, because those methods do not have access to my full shell environment. There are other shell functions in my configuration that I want to call. More importantly, the it is limited only in the environment of the git configuration.</p><p>What I use instead is that I defined a shell function, wherein, I can call them with false aliases and with valid git commands. With that system, if I use the following command:</p><pre><code>git clone</code></pre><p>Git behaves just like as it was. However, if I use the following command:</p><pre><code>git abc</code></pre><p>I will call the subcommand <code>abc</code> which I defined. Even if I have defined an alias with the same name in <code>&#126;/.gitconfig</code> this subcommand will run with a higher priority.</p><h2><a name="configuration">Configuration</a></h2><p>In this section are the definitions which we need to put in the Zsh and Bash configuration files. I have them in <code>&#126;/.zshenv</code> and <code>&#126;/.bashrc</code>, respectively.</p><h3><a name="basefunction">Base function</a></h3><p>Here is the base function:</p><pre><code>function git &#40;&#41; {
  local git= self= op=

  if &#91;&#91; -n &quot;${BASH}&quot; &#93;&#93;; then
    git=$&#40;which git&#41;
    self=${FUNCNAME}
  elif &#91;&#91; -n &quot;${ZSH&#95;NAME}&quot; &#93;&#93;; then
    git=$&#40;whence -p git&#41;
    self=$0
  else
    echo &quot;Meh&quot;
    return 1
  fi

  if &#91;&#91; $# -eq 0 &#93;&#93;; then
    if &#91;&#91; -n &quot;${BASH}&quot; &#93;&#93;; then
      type &quot;${self}&quot; | less
    elif &#91;&#91; -n &quot;${ZSH&#95;NAME}&quot; &#93;&#93;; then
      which &quot;${self}&quot; | less
    else
      echo &quot;Meh&quot;
      return 1
    fi
  else
    op=&quot;$1&quot;
    shift

    case &quot;${op}&quot; in
      # commands here
      &#40;&#42;&#41; =git &quot;${op}&quot; &quot;$@&quot; ;;
    esac
  fi
}
</code></pre><p>If there are no commands for git:</p><pre><code>git</code></pre><p>the definition of function itself will be displayed.</p><p>The subcommands will live in the area marked <code># commands here</code>. The fallback marked with <code>&#42;</code> means that if there is no appropriate subcommand, git will use its internal command.</p><h3><a name="commands1">Important commands</a></h3><p>Here are the most important commands that we need to have.</p><p><strong>Main operations</strong></p><pre><code>      &#40;s&#41; &quot;${git}&quot; status ;;
      &#40;c&#41; &quot;${git}&quot; clone &quot;$@&quot; ;;
      &#40;h&#41; &quot;${git}&quot; show &quot;$@&quot; ;;
      &#40;mv&#41; &quot;${git}&quot; mv &quot;$@&quot; ;;
      &#40;mv!&#41; &quot;${git}&quot; mv -f &quot;$@&quot; ;;
      &#40;me&#41; &quot;${git}&quot; merge &quot;$@&quot; ;;
      &#40;ta&#41; &quot;${git}&quot; tag &quot;$@&quot; ;;
      &#40;bl&#41; &quot;${git}&quot; blame &quot;$@&quot; ;;

      &#40;a&#41; &quot;${git}&quot; add &quot;$@&quot; ;;
      &#40;au&#41; &quot;${self}&quot; a -u ;;
      &#40;a.&#41; &quot;${self}&quot; a . ;;
      &#40;aum&#41; &quot;${self}&quot; au; &quot;${self}&quot; cim &quot;$@&quot; ;;
      &#40;a.m&#41; &quot;${self}&quot; a.; &quot;${self}&quot; cim &quot;$@&quot; ;;
      &#40;a.x&#41; &quot;${self}&quot; a.m &quot;x&quot; ;;
      &#40;aux&#41; &quot;${self}&quot; aum &quot;x&quot; ;;
      &#40;auxx&#41; &quot;${self}&quot; aux; &quot;${self}&quot; rs 2 ;;
      &#40;au.x&#41; &quot;${self}&quot; a.x; &quot;${self}&quot; rs 2 ;;
      &#40;auxx!&#41; &quot;${self}&quot; auxx; &quot;${self}&quot; oo! ;;

      &#40;cl&#41; &quot;${git}&quot; clean &quot;$@&quot; ;;
      &#40;cl!&#41; &quot;${self}&quot; cl -f ;;

      &#40;ci&#41; &quot;${git}&quot; commit &quot;$@&quot; ;;
      &#40;cia&#41; &quot;${self}&quot; ci --amend &quot;$@&quot; ;;
      &#40;cim&#41; &quot;${self}&quot; ci --message &quot;$@&quot; ;;

      &#40;co&#41; &quot;${git}&quot; checkout &quot;$@&quot; ;;
      &#40;com&#41; &quot;${self}&quot; co main ;;
      &#40;cot&#41; &quot;${self}&quot; co trunk ;;
      &#40;co!&#41; &quot;${self}&quot; co --force &quot;$@&quot; ;;
      &#40;cob&#41; &quot;${self}&quot; co -b &quot;$@&quot; ;;

      &#40;ls&#41; &quot;${git}&quot; ls-files &quot;$@&quot; ;;
      &#40;lsm&#41; &quot;${self}&quot; ls -m ;;
      &#40;lsd&#41; &quot;${self}&quot; ls -d ;;
      &#40;lsdrm&#41; &quot;${self}&quot; lsd | xargs &quot;${git}&quot; rm ;;

      &#40;rt&#41; &quot;${git}&quot; reset &quot;$@&quot; ;;
      &#40;rt!&#41; &quot;${self}&quot; rt --hard &quot;$@&quot; ;;
      &#40;rv&#41; &quot;${git}&quot; revert &quot;$@&quot; ;;

      &#40;g&#41; &quot;${git}&quot; grep &quot;$@&quot; ;;
      &#40;gi&#41; &quot;${self}&quot; g -i &quot;$@&quot; ;;

      &#40;f&#41; &quot;${git}&quot; fetch &quot;$@&quot; ;;
      &#40;fa&#41; &quot;${self}&quot; f --all &quot;$@&quot; ;;

      &#40;rm&#41; &quot;${git}&quot; rm &quot;$@&quot; ;;
      &#40;rmr&#41; &quot;${self}&quot; rm -r &quot;$@&quot; ;;
      &#40;rm!&#41; &quot;${self}&quot; rm -rf &quot;$@&quot; ;;
</code></pre><p><strong>Pushing and pulling</strong></p><pre><code>      &#40;ph&#41; &quot;${git}&quot; push &quot;$@&quot; ;;
      &#40;phu&#41; &quot;${self}&quot; ph -u &quot;$@&quot; ;;
      &#40;ph!&#41; &quot;${self}&quot; ph --force &quot;$@&quot; ;;
      &#40;pho&#41; &quot;${self}&quot; phu origin &quot;$@&quot; ;;
      &#40;phoo&#41; &quot;${self}&quot; phu origin &quot;$&#40;git brh&#41;&quot; ;;
      &#40;phd&#41; &quot;${self}&quot; ph --delete &quot;$@&quot; ;;
      &#40;phdo&#41; &quot;${self}&quot; phd origin &quot;$&#40;git brh&#41;&quot; ;;
      &#40;oo&#41; &quot;${self}&quot; ph origin &quot;$&#40;git brh&#41;&quot; ;;
      &#40;oo!&#41; &quot;${self}&quot; ph! origin &quot;$&#40;git brh&#41;&quot; ;;

      &#40;pl&#41; &quot;${git}&quot; pull &quot;$@&quot; ;;
      &#40;pl!&#41; &quot;${self}&quot; pl --force &quot;$@&quot; ;;
      &#40;plr&#41; &quot;${self}&quot; pl --rebase &quot;$@&quot; ;;
      &#40;plro&#41; &quot;${self}&quot; plr origin &quot;$@&quot; ;;
      &#40;plroo&#41; &quot;${self}&quot; plr origin &quot;$&#40;git brh&#41;&quot; ;;
      &#40;plru&#41; &quot;${self}&quot; plr upstream &quot;$@&quot; ;;
      &#40;plruo&#41; &quot;${self}&quot; plr upstream &quot;$&#40;git brh&#41;&quot; ;;
</code></pre><p><strong>Branches and diffs</strong></p><pre><code>      &#40;br&#41; &quot;${git}&quot; branch &quot;$@&quot; ;;
      &#40;bra&#41; &quot;${self}&quot; br -a ;;
      &#40;brm&#41; &quot;${self}&quot; br -m &quot;$@&quot; ;;
      &#40;brmh&#41; &quot;${self}&quot; brm &quot;$&#40;git brh&#41;&quot; ;;
      &#40;brd&#41; &quot;${self}&quot; br -d &quot;$@&quot; ;;
      &#40;brD&#41; &quot;${self}&quot; br -D &quot;$@&quot; ;;
      &#40;brh&#41; &quot;${git}&quot; rev-parse --abbrev-ref HEAD ;;

      &#40;d&#41; &quot;${git}&quot; diff &quot;$@&quot; ;;
      &#40;dc&#41; &quot;${git}&quot; diff --cached &quot;$@&quot; ;;
      &#40;dh&#41; &quot;${self}&quot; d HEAD ;;
      &#40;dhw&#41; &quot;${self}&quot; d --word-diff=color ;;
</code></pre><p><strong>Logs</strong></p><pre><code>      &#40;l&#41; &quot;${git}&quot; log &quot;$@&quot; ;;
      &#40;l1&#41; &quot;${self}&quot; l -1 --pretty=%B ;;
      &#40;lo&#41; &quot;${self}&quot; l --oneline ;;
      &#40;lp&#41; &quot;${self}&quot; l --patch ;;
      &#40;lp1&#41; &quot;${self}&quot; lp -1 ;;
      &#40;lpw&#41; &quot;${self}&quot; lp --word-diff=color ;;
</code></pre><h3><a name="commands2">Other commands</a></h3><p>Here are other commands that we also need to define:</p><p><strong>Initialization and push helpers</strong></p><pre><code>      &#40;i&#41; touch .gitignore; &quot;${git}&quot; init; &quot;${self}&quot; a.; &quot;${self}&quot; cim &quot;$@&quot; ;;
      &#40;i!&#41; &quot;${self}&quot; i &quot;&#91;top-level&#93; make initial commit&quot; ;;

      &#40;oo&#41; &quot;${self}&quot; ph origin &quot;$&#40;git brh&#41;&quot; ;;
      &#40;oo!&#41; &quot;${self}&quot; ph! origin &quot;$&#40;git brh&#41;&quot; ;;
</code></pre><p>Whenever I create new repositories, I use the following command:</p><pre><code>git i 'Initial commit'</code></pre><p>What the <code>oo</code> subcommand does is that code will be pushed to the remote named <code>origin</code> under the name of the current branch. For example, if the current branch is <code>trunk</code>, then I run the following command:</p><pre><code>git oo</code></pre><p>the command becomes</p><pre><code>git ph origin trunk</code></pre><p><strong>Rebasing</strong></p><pre><code>      &#40;rb&#41; &quot;${git}&quot; rebase &quot;$@&quot; ;;
      &#40;rbi&#41; &quot;${self}&quot; rb --interactive &quot;$@&quot; ;;
      &#40;rbc&#41; &quot;${self}&quot; rb --continue &quot;$@&quot; ;;
      &#40;rbs&#41; &quot;${self}&quot; rb --skip &quot;$@&quot; ;;
      &#40;rba&#41; &quot;${self}&quot; rb --abort &quot;$@&quot; ;;
      &#40;rbs&#41; &quot;${self}&quot; rb --skip &quot;$@&quot; ;;
      &#40;rbi!&#41; &quot;${self}&quot; rbi --root &quot;$@&quot; ;;

      &#40;ri&#41; &quot;${self}&quot; rbi HEAD&#126;&quot;$1&quot; ;;
      &#40;rs&#41; &quot;${self}&quot; rt --soft HEAD&#126;&quot;$1&quot; &amp;&amp; &quot;${self}&quot; cim &quot;$&#40;git log --format=%B --reverse HEAD..HEAD@{1} | head -1&#41;&quot; ;;
</code></pre><p>I use the subcommand <code>rs</code> whenever I need to squash non-interactively. The argument is a digit indicating how many commits do we want to squash. For example, if I want to squash the last two commits, I run the following command:</p><pre><code>git rs 2</code></pre><p><strong>Adding</strong></p><pre><code>      &#40;a&#41; &quot;${git}&quot; add &quot;$@&quot; ;;
      &#40;au&#41; &quot;${self}&quot; a -u ;;
      &#40;a.&#41; &quot;${self}&quot; a . ;;
      &#40;aum&#41; &quot;${self}&quot; au; &quot;${self}&quot; cim &quot;$@&quot; ;;
      &#40;a.m&#41; &quot;${self}&quot; a.; &quot;${self}&quot; cim &quot;$@&quot; ;;
      &#40;a.x&#41; &quot;${self}&quot; a.m &quot;x&quot; ;;
      &#40;aux&#41; &quot;${self}&quot; aum &quot;x&quot; ;;
      &#40;auxx&#41; &quot;${self}&quot; aux; &quot;${self}&quot; rs 2 ;;
      &#40;au.x&#41; &quot;${self}&quot; a.x; &quot;${self}&quot; rs 2 ;;
      &#40;auxx!&#41; &quot;${self}&quot; auxx; &quot;${self}&quot; oo! ;;
</code></pre><p>The subcommand <code>aum</code> becomes a shorthand for <code>au</code> and <code>cm</code> in order. I use the command <code>auxx</code> whenever I make small changes but I don’t want to add a new visible entry in the commit log.</p><p><strong>Remote repositories</strong></p><pre><code>      &#40;re&#41; &quot;${git}&quot; remote &quot;$@&quot; ;;
      &#40;rea&#41; &quot;${self}&quot; re add &quot;$@&quot; ;;
      &#40;reao&#41; &quot;${self}&quot; rea origin &quot;$@&quot; ;;
      &#40;reau&#41; &quot;${self}&quot; rea upstream &quot;$@&quot; ;;
      &#40;rer&#41; &quot;${self}&quot; re remove &quot;$@&quot; ;;
      &#40;ren&#41; &quot;${self}&quot; re rename &quot;$@&quot; ;;
      &#40;rero&#41; &quot;${self}&quot; rer origin &quot;$@&quot; ;;
      &#40;reru&#41; &quot;${self}&quot; rer upstream &quot;$@&quot; ;;
      &#40;res&#41; &quot;${self}&quot; re show &quot;$@&quot; ;;
      &#40;reso&#41; &quot;${self}&quot; res origin ;;
      &#40;resu&#41; &quot;${self}&quot; res upstream ;;
</code></pre><p><strong>Revisions, filters, and stash</strong></p><pre><code>      &#40;rl&#41; &quot;${git}&quot; rev-list &quot;$@&quot; ;;
      &#40;rla&#41; &quot;${self}&quot; rl --all &quot;$@&quot; ;;
      &#40;rl0&#41; &quot;${self}&quot; rl --max-parents=0 HEAD ;;

      &#40;cp&#41; &quot;${git}&quot; cherry-pick &quot;$@&quot; ;;
      &#40;cpc&#41; &quot;${self}&quot; cp --continue &quot;$@&quot; ;;
      &#40;cpa&#41; &quot;${self}&quot; cp --abort &quot;$@&quot; ;;

      &#40;fr&#41; &quot;${git}&quot; filter-repo &quot;$@&quot; ;;
      &#40;fr!&#41; &quot;${git}&quot; filter-repo --force &quot;$@&quot; ;;

      &#40;rp&#41; &quot;${git}&quot; rev-parse &quot;$@&quot; ;;
      &#40;rph&#41; &quot;${self}&quot; rp HEAD ;;

      &#40;st&#41; &quot;${git}&quot; stash &quot;$@&quot; ;;
      &#40;stp&#41; &quot;${self}&quot; st pop &quot;$@&quot; ;;
</code></pre><p>Whenever I want to change to change a text from all commit messages, for example I want to change word <code>dog</code> to <code>cat</code>, I run the following command:</p><pre><code>git fr! --replace-message &lt;&#40;echo 'dog==&gt;cat'&#41;</code></pre><p>Whenever I want to completely remove a file from a repository, for example <code>file.dat</code>, I run the following command:</p><pre><code>git fr! --invert-paths --path file.dat</code></pre><p>Whenever I want to change the email address in the commits, for example, from <code>dog@world.com</code> to <code>cat@world.com</code>, I run the following command:</p><pre><code>git fbe 'export GIT&#95;AUTHOR&#95;EMAIL=&quot;cat@world.com&quot;; export GIT&#95;COMMITTER&#95;EMAIL=&quot;cat@world.com&quot;' --tag-name-filter cat -- --branches --tags</code></pre><pre><code>    git fr! --email-callback 'return email.replace&#40;b&quot;dog@world.com&quot;, b&quot;cat@world.com&quot;&#41;'
</code></pre><br /><p>I then run the following command to make sure that the changes appear in the remote repository:</p><pre><code>git oo!</code></pre><p><strong>Subtrees and submodules</strong></p><pre><code>      &#40;subt&#41; &quot;${git}&quot; subtree &quot;$@&quot; ;;
      &#40;subta&#41; &quot;${self}&quot; subt add &quot;$@&quot; ;;
      &#40;subtph&#41; &quot;${self}&quot; subt push &quot;$@&quot; ;;
      &#40;subtpl&#41; &quot;${self}&quot; subt pull &quot;$@&quot; ;;

      &#40;subm&#41; &quot;${git}&quot; submodule &quot;$@&quot; ;;
      &#40;subms&#41; &quot;${self}&quot; subm status &quot;$@&quot; ;;
      &#40;submy&#41; &quot;${self}&quot; subm summary &quot;$@&quot; ;;
      &#40;submu&#41; &quot;${self}&quot; subm update &quot;$@&quot; ;;
      &#40;subma&#41; &quot;${self}&quot; subm add &quot;$@&quot; ;;
      &#40;submi&#41; &quot;${self}&quot; subm init &quot;$@&quot; ;;

      &#40;ref&#41; &quot;${git}&quot; reflog &quot;$@&quot; ;;
</code></pre><p><strong>Descriptions</strong></p><pre><code>      &#40;de&#41; &quot;${git}&quot; describe &quot;$@&quot; ;;
      &#40;det&#41; &quot;${self}&quot; de --tags &quot;$@&quot; ;;
</code></pre><h2><a name="all">Putting them all together</a></h2><p>Here are all the definitions in one location:</p><pre><code>function git {
  local git= self= op=

  if &#91;&#91; -n &quot;${BASH}&quot; &#93;&#93;; then
    git=$&#40;which git&#41;
    self=${FUNCNAME}
  elif &#91;&#91; -n &quot;${ZSH&#95;NAME}&quot; &#93;&#93;; then
    git=$&#40;whence -p git&#41;
    self=$0
  else
    echo &quot;Ve.&quot;
    return 1
  fi

  if &#91;&#91; $# -eq 0 &#93;&#93;; then
    if &#91;&#91; -n &quot;${BASH}&quot; &#93;&#93;; then
      type &quot;${self}&quot; | less
    elif &#91;&#91; -n &quot;${ZSH&#95;NAME}&quot; &#93;&#93;; then
      which &quot;${self}&quot; | less
    else
      echo &quot;Meh&quot;
      return 1
    fi
  else
    op=&quot;$1&quot;
    shift

    case &quot;${op}&quot; in
      &#40;i&#41; touch .gitignore; &quot;${git}&quot; init; &quot;${self}&quot; a.; &quot;${self}&quot; cim &quot;$@&quot; ;;
      &#40;i!&#41; &quot;${self}&quot; i &quot;&#91;supro&#93; pravalorizu novdeponejon&quot; ;;

      &#40;s&#41; &quot;${git}&quot; status ;;
      &#40;c&#41; &quot;${git}&quot; clone &quot;$@&quot; ;;
      &#40;h&#41; &quot;${git}&quot; show &quot;$@&quot; ;;
      &#40;mv&#41; &quot;${git}&quot; mv &quot;$@&quot; ;;
      &#40;mv!&#41; &quot;${git}&quot; mv -f &quot;$@&quot; ;;
      &#40;me&#41; &quot;${git}&quot; merge &quot;$@&quot; ;;
      &#40;ta&#41; &quot;${git}&quot; tag &quot;$@&quot; ;;
      &#40;bl&#41; &quot;${git}&quot; blame &quot;$@&quot; ;;

      &#40;a&#41; &quot;${git}&quot; add &quot;$@&quot; ;;
      &#40;au&#41; &quot;${self}&quot; a -u ;;
      &#40;a.&#41; &quot;${self}&quot; a . ;;
      &#40;aum&#41; &quot;${self}&quot; au; &quot;${self}&quot; cim &quot;$@&quot; ;;
      &#40;a.m&#41; &quot;${self}&quot; a.; &quot;${self}&quot; cim &quot;$@&quot; ;;
      &#40;a.x&#41; &quot;${self}&quot; a.m &quot;x&quot; ;;
      &#40;aux&#41; &quot;${self}&quot; aum &quot;x&quot; ;;
      &#40;auxx&#41; &quot;${self}&quot; aux; &quot;${self}&quot; rs 2 ;;
      &#40;au.x&#41; &quot;${self}&quot; a.x; &quot;${self}&quot; rs 2 ;;
      &#40;auxx!&#41; &quot;${self}&quot; auxx; &quot;${self}&quot; oo! ;;

      &#40;cl&#41; &quot;${git}&quot; clean &quot;$@&quot; ;;
      &#40;cl!&#41; &quot;${self}&quot; cl -f ;;

      &#40;ci&#41; &quot;${git}&quot; commit &quot;$@&quot; ;;
      &#40;cia&#41; &quot;${self}&quot; ci --amend &quot;$@&quot; ;;
      &#40;cim&#41; &quot;${self}&quot; ci --message &quot;$@&quot; ;;

      &#40;co&#41; &quot;${git}&quot; checkout &quot;$@&quot; ;;
      &#40;com&#41; &quot;${self}&quot; co main ;;
      &#40;cot&#41; &quot;${self}&quot; co trunk ;;
      &#40;co!&#41; &quot;${self}&quot; co --force &quot;$@&quot; ;;
      &#40;cob&#41; &quot;${self}&quot; co -b &quot;$@&quot; ;;

      &#40;ls&#41; &quot;${git}&quot; ls-files &quot;$@&quot; ;;
      &#40;lsm&#41; &quot;${self}&quot; ls -m ;;
      &#40;lsd&#41; &quot;${self}&quot; ls -d ;;
      &#40;lsdrm&#41; &quot;${self}&quot; lsd | xargs &quot;${git}&quot; rm ;;

      &#40;rt&#41; &quot;${git}&quot; reset &quot;$@&quot; ;;
      &#40;rt!&#41; &quot;${self}&quot; rt --hard &quot;$@&quot; ;;
      &#40;rv&#41; &quot;${git}&quot; revert &quot;$@&quot; ;;

      &#40;g&#41; &quot;${git}&quot; grep &quot;$@&quot; ;;
      &#40;gi&#41; &quot;${self}&quot; g -i &quot;$@&quot; ;;

      &#40;f&#41; &quot;${git}&quot; fetch &quot;$@&quot; ;;
      &#40;fa&#41; &quot;${self}&quot; f --all &quot;$@&quot; ;;

      &#40;fr&#41; &quot;${git}&quot; filter-repo &quot;$@&quot; ;;
      &#40;fr!&#41; &quot;${git}&quot; filter-repo --force &quot;$@&quot; ;;

      &#40;rm&#41; &quot;${git}&quot; rm &quot;$@&quot; ;;
      &#40;rmr&#41; &quot;${self}&quot; rm -r &quot;$@&quot; ;;
      &#40;rm!&#41; &quot;${self}&quot; rm -rf &quot;$@&quot; ;;

      &#40;rb&#41; &quot;${git}&quot; rebase &quot;$@&quot; ;;
      &#40;rbi&#41; &quot;${self}&quot; rb --interactive &quot;$@&quot; ;;
      &#40;rbc&#41; &quot;${self}&quot; rb --continue &quot;$@&quot; ;;
      &#40;rbs&#41; &quot;${self}&quot; rb --skip &quot;$@&quot; ;;
      &#40;rba&#41; &quot;${self}&quot; rb --abort &quot;$@&quot; ;;
      &#40;rbs&#41; &quot;${self}&quot; rb --skip &quot;$@&quot; ;;
      &#40;rbi!&#41; &quot;${self}&quot; rbi --root &quot;$@&quot; ;;

      &#40;ri&#41; &quot;${self}&quot; rbi HEAD&#126;&quot;$1&quot; ;;
      &#40;rs&#41; &quot;${self}&quot; rt --soft HEAD&#126;&quot;$1&quot; &amp;&amp; &quot;${self}&quot; cim &quot;$&#40;git log --format=%B --reverse HEAD..HEAD@{1} | head -1&#41;&quot; ;;

      &#40;ph&#41; &quot;${git}&quot; push &quot;$@&quot; ;;
      &#40;phu&#41; &quot;${self}&quot; ph -u &quot;$@&quot; ;;
      &#40;ph!&#41; &quot;${self}&quot; ph --force &quot;$@&quot; ;;
      &#40;pho&#41; &quot;${self}&quot; phu origin &quot;$@&quot; ;;
      &#40;phoo&#41; &quot;${self}&quot; phu origin &quot;$&#40;git brh&#41;&quot; ;;
      &#40;phd&#41; &quot;${self}&quot; ph --delete &quot;$@&quot; ;;
      &#40;phdo&#41; &quot;${self}&quot; phd origin &quot;$&#40;git brh&#41;&quot; ;;
      &#40;oo&#41; &quot;${self}&quot; ph origin &quot;$&#40;git brh&#41;&quot; ;;
      &#40;oo!&#41; &quot;${self}&quot; ph! origin &quot;$&#40;git brh&#41;&quot; ;;

      &#40;pl&#41; &quot;${git}&quot; pull &quot;$@&quot; ;;
      &#40;pl!&#41; &quot;${self}&quot; pl --force &quot;$@&quot; ;;
      &#40;plr&#41; &quot;${self}&quot; pl --rebase &quot;$@&quot; ;;
      &#40;plro&#41; &quot;${self}&quot; plr origin &quot;$@&quot; ;;
      &#40;plroo&#41; &quot;${self}&quot; plr origin &quot;$&#40;git brh&#41;&quot; ;;
      &#40;plru&#41; &quot;${self}&quot; plr upstream &quot;$@&quot; ;;
      &#40;plruo&#41; &quot;${self}&quot; plr upstream &quot;$&#40;git brh&#41;&quot; ;;

      &#40;l&#41; &quot;${git}&quot; log &quot;$@&quot; ;;
      &#40;l1&#41; &quot;${self}&quot; l -1 --pretty=%B ;;
      &#40;lo&#41; &quot;${self}&quot; l --oneline ;;
      &#40;lp&#41; &quot;${self}&quot; l --patch ;;
      &#40;lp1&#41; &quot;${self}&quot; lp -1 ;;
      &#40;lpw&#41; &quot;${self}&quot; lp --word-diff=color ;;

      &#40;br&#41; &quot;${git}&quot; branch &quot;$@&quot; ;;
      &#40;bra&#41; &quot;${self}&quot; br -a ;;
      &#40;brm&#41; &quot;${self}&quot; br -m &quot;$@&quot; ;;
      &#40;brmh&#41; &quot;${self}&quot; brm &quot;$&#40;git brh&#41;&quot; ;;
      &#40;brd&#41; &quot;${self}&quot; br -d &quot;$@&quot; ;;
      &#40;brD&#41; &quot;${self}&quot; br -D &quot;$@&quot; ;;
      &#40;brh&#41; &quot;${git}&quot; rev-parse --abbrev-ref HEAD ;;

      &#40;d&#41; &quot;${git}&quot; diff &quot;$@&quot; ;;
      &#40;dc&#41; &quot;${git}&quot; diff --cached &quot;$@&quot; ;;
      &#40;dh&#41; &quot;${self}&quot; d HEAD ;;
      &#40;dhw&#41; &quot;${self}&quot; d --word-diff=color ;;

      &#40;re&#41; &quot;${git}&quot; remote &quot;$@&quot; ;;
      &#40;rea&#41; &quot;${self}&quot; re add &quot;$@&quot; ;;
      &#40;reao&#41; &quot;${self}&quot; rea origin &quot;$@&quot; ;;
      &#40;reau&#41; &quot;${self}&quot; rea upstream &quot;$@&quot; ;;
      &#40;rer&#41; &quot;${self}&quot; re remove &quot;$@&quot; ;;
      &#40;ren&#41; &quot;${self}&quot; re rename &quot;$@&quot; ;;
      &#40;rero&#41; &quot;${self}&quot; rer origin &quot;$@&quot; ;;
      &#40;reru&#41; &quot;${self}&quot; rer upstream &quot;$@&quot; ;;
      &#40;res&#41; &quot;${self}&quot; re show &quot;$@&quot; ;;
      &#40;reso&#41; &quot;${self}&quot; res origin ;;
      &#40;resu&#41; &quot;${self}&quot; res upstream ;;

      &#40;rl&#41; &quot;${git}&quot; rev-list &quot;$@&quot; ;;
      &#40;rla&#41; &quot;${self}&quot; rl --all &quot;$@&quot; ;;
      &#40;rl0&#41; &quot;${self}&quot; rl --max-parents=0 HEAD ;;

      &#40;cp&#41; &quot;${git}&quot; cherry-pick &quot;$@&quot; ;;
      &#40;cpc&#41; &quot;${self}&quot; cp --continue &quot;$@&quot; ;;
      &#40;cpa&#41; &quot;${self}&quot; cp --abort &quot;$@&quot; ;;

      &#40;rp&#41; &quot;${git}&quot; rev-parse &quot;$@&quot; ;;
      &#40;rph&#41; &quot;${self}&quot; rp HEAD ;;

      &#40;st&#41; &quot;${git}&quot; stash &quot;$@&quot; ;;
      &#40;stp&#41; &quot;${self}&quot; st pop &quot;$@&quot; ;;

      &#40;subt&#41; &quot;${git}&quot; subtree &quot;$@&quot; ;;
      &#40;subta&#41; &quot;${self}&quot; subt add &quot;$@&quot; ;;
      &#40;subtph&#41; &quot;${self}&quot; subt push &quot;$@&quot; ;;
      &#40;subtpl&#41; &quot;${self}&quot; subt pull &quot;$@&quot; ;;

      &#40;subm&#41; &quot;${git}&quot; submodule &quot;$@&quot; ;;
      &#40;subms&#41; &quot;${self}&quot; subm status &quot;$@&quot; ;;
      &#40;submy&#41; &quot;${self}&quot; subm summary &quot;$@&quot; ;;
      &#40;submu&#41; &quot;${self}&quot; subm update &quot;$@&quot; ;;
      &#40;subma&#41; &quot;${self}&quot; subm add &quot;$@&quot; ;;
      &#40;submi&#41; &quot;${self}&quot; subm init &quot;$@&quot; ;;

      &#40;ref&#41; &quot;${git}&quot; reflog &quot;$@&quot; ;;

      &#40;de&#41; &quot;${git}&quot; describe &quot;$@&quot; ;;
      &#40;det&#41; &quot;${self}&quot; de --tags &quot;$@&quot; ;;

      &#40;&#42;&#41; &quot;${git}&quot; &quot;${op}&quot; &quot;$@&quot; ;;
    esac
  fi
}
</code></pre><p>I must mention, that if we already have the function above in the shell configuration and we have the following alias in <code>&#126;/.gitconfig</code>:</p><pre><code>&#91;alias&#93;
  ls = &quot;! echo hello world&quot;
</code></pre><p>then we run the following command</p><pre><code>git ls</code></pre><p>the list of files managed by git will still appear on the screen, instead of the text <code>hello world</code>.</p><h2><a name="closing">Closing remarks</a></h2><p>So, with that function, I can work with git easily because I only need to think about the short names. Additionally, they have access to my other commands and functions. Since I use <a href='/en/tmux/'>tmux</a>, whenever I need to git, I only need to press a keyboard shortcut to open another tmux window below. There, I can easily use the git commands without changing my view which Magit unfortunately does. Because of it, it also enables me to think separately between code and the management of code.</p><hr/><div class="footer"><p><div class="text-small"> <a href='/en/'>Home</a> • <a href='/en/about/'>About</a> • <a href='/en/quotes/'>Quotes</a> • <a href='/en/reflections/'>Reflections</a> • <a href='https://github.com/ebzzry/ebzzry.github.io'>Source</a> • <a href='https://creativecommons.org/publicdomain/zero/1.0/deed.en'>License</a> </div></p><p><div class="text-x-small"> Made with ❤️ by Rommel Martínez </div></p><p></div></p></div><script src="/static/js/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>