<!DOCTYPE html>
<html lang="en"><head><title>A Lambda Calculus Primer</title><meta charset="utf-8" /><meta content="width=device-width,initial-scale=1.0,user-scalable=yes" name="viewport" /><meta content="noodp,noydir" name="robots" /><link rel='apple-touch-icon' sizes='180x180' href='/images/ico/apple-touch-icon.png'><link rel='icon' type='image/png' sizes='32x32' href='/images/ico/favicon-32x32.png'><link rel='icon' type='image/png' sizes='16x16' href='/images/ico/favicon-16x16.png'><link rel='manifest' href='/images/ico/site.webmanifest'><link rel='mask-icon' href='/images/ico/safari-pinned-tab.svg' color='#5bbad5'><link rel='shortcut icon' href='/images/ico/favicon.ico'> <meta name='msapplication-TileColor' content='#da532c'> <meta name='msapplication-config' content='/images/ico/browserconfig.xml'> <meta name='theme-color' content='#ffffff'><meta content="A Lambda Calculus Primer" name="description" /><meta content="lambda calculus, untyped lambda calculus, compsci, computer science" name="keywords" /><meta content="A Lambda Calculus Primer" property="og:title" /><meta content="article" property="og:type" /><meta content="https://ebzzry.com/en/lambda-calculus/" property="og:url" /><meta content="https://ebzzry.com/images/site/joel-filipe-Wc8k-KryEPM-unsplash-1008x250.jpg" property="og:image" /><style media="all" type="text/css">html {    color: #333;    font-size: 1em;    font-family: Georgia, Cambria, Palatino, "Palatino Linotype", "Times New Roman", Times, serif;    line-height: 1.45;    text-align: left:    width: 100%;    max-width: 40em;    margin: 0 auto 0 auto;    padding: 0;}body {    border-top: hidden;    border-bottom: hidden;    padding: 0 1.5em 1em 1.5em;    margin: 0;}#content {    -webkit-column-count: 1;    -moz-column-count: 1;    column-count: 1;}code {    font-size: 0.9em;    font-family: "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Lucida Console", "Courier New", Courier, monospace;    color: black;    display: inline-block;}pre code {    font-size: 1em;    font-family: monospace;    line-height: 1.3em;    overflow: auto;    font-weight: normal;}kbd {    font-size: 1.1em;    padding: 0.1em 0.6em;    border: 1px solid #ccc;    font-family: monospace;    background-color: #f7f7f7;    color: #333;    -moz-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    -webkit-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    -moz-border-radius: 3px;    -webkit-border-radius: 3px;    border-radius: 3px;    display: inline-block;    margin: 0 0.1em;    text-shadow: 0 1px 0 #fff;    white-space: nowrap;}h1, h2, h3, h4, h5, h6 {    font-family: Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans", Tahoma, Geneva, Helvetica, Arial, sans-serif;    margin-bottom: 0;}h1 {    font-size: 2.5em;    text-align: center;    border-bottom: 6px solid black;}h2 {    font-size: 2.0em;    text-align: left;    border-bottom: 2px solid black;}h3 {    font-size: 1.6em;    text-align: left;    border-bottom: 1px solid lightgrey;}h4 {    font-size: 1.5em;    text-align: left;}h5 {    font-size: 1.3em;    text-align: left;}ul, ol {    padding-left: 2em;}ul li {    list-style-type: square;}ul li li {    list-style-type: disc;}ul li li li {    list-style-type: circle;}ol li {    list-style-type: decimal;}p, para, b, strong, i, em, emph {    font-size: 1em;}blockquote {    font-size: 1.2em;    font-style: italic;    margin-left: 2em;}b, strong {    font-weight: bold;}i, em, emph {    font-style: italic;}table {    margin: 0.5em;    border-spacing: 0;    border-collapse: collapse;}th, td {    border: 1px solid lightgray;    padding-top: 0;    padding-bottom: 0;    padding-left: 0.45em;    padding-right: 0.45em;}.text-right {    text-align: right;}.text-small {    font-size: small;}.text-x-small {    font-size: x-small;}.banner {    display: block;    width: 100%;    margin-left: auto;    margin-right: auto;}.footer {    text-align: right;    float: right;    max-width: 18em;}.cc {    border-width: 0}.center {    text-align: center;}</style><style media="all" type="text/css">/* Ewan Themes -- based 99.99% from Tomorrow Night Theme *//* http://jmblog.github.com/color-themes-for-google-code-highlightjs *//* Original theme - https://github.com/chriskempson/tomorrow-theme *//* http://jmblog.github.com/color-themes-for-google-code-highlightjs *//* Tomorrow Comment */.hljs-comment {  color: #969896;}/* Tomorrow Red */.hljs-variable,.hljs-attribute,.hljs-tag,.hljs-regexp,.ruby .hljs-constant,.xml .hljs-tag .hljs-title,.xml .hljs-pi,.xml .hljs-doctype,.html .hljs-doctype,.css .hljs-id,.css .hljs-class,.css .hljs-pseudo {  color: #cc6666;}/* Tomorrow Orange */.hljs-number,.hljs-preprocessor,.hljs-pragma,.hljs-built_in,.hljs-literal,.hljs-params,.hljs-constant {  color: #de935f;}/* Tomorrow Yellow */.ruby .hljs-class .hljs-title,.css .hljs-rule .hljs-attribute {  color: #f0c674;}/* Tomorrow Green */.hljs-string,.hljs-value,.hljs-inheritance,.hljs-header,.hljs-name,.ruby .hljs-symbol,.xml .hljs-cdata {  color: #b5bd68;}/* Tomorrow Aqua */.hljs-title,.css .hljs-hexcolor {  color: #8abeb7;}/* Tomorrow Blue */.hljs-function,.python .hljs-decorator,.python .hljs-title,.ruby .hljs-function .hljs-title,.ruby .hljs-title .hljs-keyword,.perl .hljs-sub,.javascript .hljs-title,.coffeescript .hljs-title {  color: #81a2be;}/* Tomorrow Purple */.hljs-keyword,.javascript .hljs-function {  color: #b294bb;}.hljs {  display: block;  overflow-x: auto;  background: #1d1f21;  color: #c5c8c6;  padding: 0.5em;  -webkit-text-size-adjust: none;}.coffeescript .javascript,.javascript .xml,.tex .hljs-formula,.xml .javascript,.xml .vbscript,.xml .css,.xml .hljs-cdata {  opacity: 0.5;}pre code {    font-size: 1.1em;    font-family: monospace;    line-height: 1.3em;    overflow: auto;}</style></head><body><div id="content"><h1>A Lambda Calculus Primer</h1><p><div class="center">English ‚àÖ <a href='/eo/lambdokalkulo/'>Esperanto</a></div> <div class="center">Sat Jun 13 04:44:26 2015 +0800</div></p><blockquote><p>You do not really understand something unless you can explain it to your grandmother.<br> ‚ÄîAlbert Einstein </p></blockquote><p><img src="/images/site/joel-filipe-Wc8k-KryEPM-unsplash-1008x250.jpg" style="display: block; width: 100%; margin-left: auto; margin-right: auto;" alt="joel-filipe-Wc8k-KryEPM-unsplash" title="joel-filipe-Wc8k-KryEPM-unsplash"/></p><h2><a name="toc">Table of contents</a></h2><ul><li><a href='#introduction'>Introduction</a><ul><li><a href='#what'>What is it?</a></li><li><a href='#learn'>Do I need to learn it?</a></li><li><a href='#do'>What do we do?</a></li></ul></li><li><a href='#babysteps'>Baby steps</a><ul><li><a href='#functions'>Functions</a></li><li><a href='#variables'>Variables</a></li><li><a href='#application'>Function application</a></li></ul></li><li><a href='#count'>Let‚Äôs count</a><ul><li><a href='#start'>Start</a></li><li><a href='#successor'>Successor</a></li><li><a href='#addition'>Addition</a></li><li><a href='#multiplication'>Multiplication</a></li></ul></li><li><a href='#tff'>Truth, falsity, and friends</a><ul><li><a href='#booleans'>Booleans</a></li><li><a href='#logicalops'>Logical operations</a></li></ul></li><li><a href='#countbackwards'>Let‚Äôs count, backwards!</a><ul><li><a href='#pred'>Predecessor</a></li><li><a href='#subtraction'>Subtraction</a></li></ul></li><li><a href='#closing'>Closing remarks</a></li><li><a href='#references'>References</a></li></ul><h2><a name="introduction">Introduction</a></h2><p>This post is my attempt to do just that, only that the grandmother here is myself. I firmly believe that I won‚Äôt really understand something, unless I can explain it. This post takes a very laid-back approach to do that, and avoids very technical topics, unless warranted.</p><h3><a name="what">What is it?</a></h3><p>Lambda calculus is a minimal system for expressing computation that conforms to universal models of computation, hence making it a universal model of computation. In other words, it can be called as one of simplest programming languages, only that it looks and behaves differently from the ones we contemporarily know. Lambda calculus also forms as the basis for the popular functional programming languages in current use now.</p><h3><a name="learn">Do I need to learn it?</a></h3><p>Yes, and no. If you want to understand the underlying mechanisms of how software works, or if you want to build the next great language, or if you just want to appreciate the elegance of its art, then yes. However, if you just want to fly a plane without knowing how it ticks, then no.</p><h3><a name="do">What do we do?</a></h3><p>When discussing new concepts, it is very important to layout the axioms or the initial ruleset. Think of it as defining new terms in play, and giving them meaning. The context in which these meanings live are important. For example, for the gardener the hose is used to water the plants, while for the fireman, the hose is used to put out the fire. When the gardener, or the fireman grabs the hose, they will not question what is that they are holding, and what is its purpose. They simply believe in their intuition, to determine the meaning of the hose at the time they grabbed it.</p><p>The word <i>high</i> has several meanings. But for all the defined meanings of the word, there is no intrinsic knowledge of the value of the word. We take the meaning as is. We have to agree to use the word in the narrowed context of the users of the word. If we try to deviate from the established meaning of the word, for example, we randomly create a new definition of the word because of whim, chances are it won‚Äôt be accepted. We need to believe in the defined connotative and denotative meanings of the word, for it to have meaning to us. The same holds true for lambda calculus‚Äîwe either accept these axioms and operate in its domain, or we live in Neverland.</p><h2><a name="babysteps">Baby steps</a></h2><h3><a name="functions">Functions</a></h3><p>A central player in lambda calculus is the notion of function. Most of us are familiar with functions in our high-level languages, but functions in lambda calculus are slightly different‚Äîthey need to have at the minimum a single parameter. In most production languages in use now, you can invoke a function that doesn‚Äôt take an argument. They‚Äôre usually used for side-effects. In lambda calculus, however, a bare minimum of one argument is enforced. Here‚Äôs what a minimal function in lambda calculus looks like:</p><pre><code class="scheme">Œªx.x
</code></pre><p>Which is equivalent to:</p><pre><code class="scheme">&#40;Œªz.z&#41;
&#40;Œªc.c&#41;
</code></pre><p>This equivalence is called the Œ±-conversion. The names do not matter, as long as they‚Äôre used consistently. Parentheses may be used to remove ambiguity when applying functions. The function above is equivalent to:</p><pre><code class="scheme">&#40;Œªx.x&#41;
</code></pre><p>The Greek letter <code>Œª</code> denotes that the surrounding context is a function‚Äîor something that can be applied or used. The <code>Œª</code> symbol is used instead of another symbol because of a typesetting issue that is discussed <a href='https://goo.gl/vxMkW4'>here</a>. So, don‚Äôt fret too much about, just use it.</p><p>What comes next after the <code>Œª</code> symbol, before the <code>.</code>, is the parameter. Technically, it can be any symbol. It simply means the name that can be used when applying that function, to refer to its argument.</p><p>The <code>.</code> symbol here, is the separator between the parameter list, and the function body. In the function <code>&#40;Œªx.x&#41;</code>, the body is simply the symbol <code>x</code>.</p><h3><a name="variables">Variables</a></h3><p>In lambda calculus, the symbols that are used inside a function are called variables. Going back to the function you defined above:</p><pre><code class="scheme">&#40;Œªx.x&#41;
</code></pre><p>The parameter <code>x</code> is a variable that is said to be bound, because it sandwiched between <code>Œª</code> and <code>.</code>. However, in the function:</p><pre><code class="scheme">&#40;Œªx.xy&#41;
</code></pre><p>The parameter <code>y</code> is a variable that is said to be free, because it does not live between <code>Œª</code> and <code>.</code>.</p><h3><a name="application">Function application</a></h3><p>To use a function, you must apply it to something. The bound variables are substituted with what they‚Äôre applied to‚Äîa process called Œ≤-reduction.</p><p>For example:</p><pre><code class="scheme">&#40;Œªx.x&#41;y
y
</code></pre><p>Let‚Äôs break it down:</p><ol><li>Apply <code>&#40;Œªx.x&#41;</code> to <code>y</code>:</li><li>Consume the arguments, then substitute all instances of <code>x</code> in the body, with <code>y</code>.</li></ol><p><b>‚ÄúWait, it merely returned the argument y.‚Äù</b> you may say. That is true. The function <code>&#40;Œªx.x&#41;</code> is the identity function‚Äîit is a single-parameter function that returns whatever it was applied to.</p><p>Functions are not limited to be applied to symbols. They can also be applied to other functions:</p><pre><code class="scheme">&#40;Œªx.x&#41;&#40;Œªy.y&#41;
&#40;Œªy.y&#41;
</code></pre><p>In the example above, the identify function is applied to an identity function, returning an identity function.</p><p>Here‚Äôs another application involving free variables:</p><pre><code class="scheme">&#40;Œªa.ab&#41;&#40;Œªy.y&#41;
&#40;Œªy.y&#41;b
b
</code></pre><p>The bound variable <code>a</code> was substituted with <code>&#40;Œªy.y&#41;</code>, which is then applied to the free variable <code>b</code>, resulting to <code>b</code>.</p><p>Take note that this function application:</p><pre><code class="scheme">&#40;Œªx.&#40;Œªy.y&#41;&#41;ab
&#40;Œªy.y&#41;b
b
</code></pre><p>is equivalent to:</p><pre><code class="scheme">&#40;Œªxy.y&#41;ab
b
</code></pre><p>Having multiple parameter names is a shorthand to multiple lambdas, giving the abbreviated version the impression that it consumes multiple arguments at once.</p><p>Inside the body of a function, when two symbols are adjacent to one another, the first symbol is presumed to be a function being applied to the second symbol, minus the parentheses. For example, the following code:</p><pre><code class="scheme">&#40;Œªxy.xy&#41;
</code></pre><p>is equivalent to:</p><pre><code class="scheme">&#40;Œªxy.x&#40;y&#41;&#41;
</code></pre><h2><a name="count">Let‚Äôs count!</a></h2><h3><a name="start">Start</a></h3><p>Since almost everything in lambda calculus is expressed as functions, its take on numbers is unique. Arguably, the most important number in lambda calculus is zero (0), which is expressed as:</p><pre><code class="scheme">&#40;Œªsz.z&#41;
</code></pre><p>For convenience purposes, let‚Äôs label that expression as <code>0</code>, with the <code>‚â°</code> symbol read as <b>‚Äúis identical to‚Äù</b>.</p><pre><code class="scheme">0 ‚â° &#40;Œªsz.z&#41;
</code></pre><p>Building from <code>0</code>, let‚Äôs enumerate the first three counting numbers:</p><pre><code class="scheme">1 ‚â° &#40;Œªsz.s&#40;z&#41;&#41;
2 ‚â° &#40;Œªsz.s&#40;s&#40;z&#41;&#41;&#41;
3 ‚â° &#40;Œªsz.s&#40;s&#40;s&#40;z&#41;&#41;&#41;&#41;
</code></pre><h3><a name="successor">Successor</a></h3><p>The successor of a whole number is defined as the next whole number, counting up. So, the successor of <code>0</code> is <code>1</code>. The definition of the successor function is:</p><pre><code class="scheme">S ‚â° &#40;Œªxyz.y&#40;xyz&#41;&#41;
</code></pre><p>Let‚Äôs try that to <code>0</code>. In the examples below, the <code>=</code> symbol is read as <b>‚Äúis reduced to‚Äù</b>:</p><pre><code class="scheme">S0
‚â° &#40;Œªxyz.y&#40;xyz&#41;&#41;&#40;Œªsz.z&#41;
= &#40;Œªyz.y&#40;&#40;Œªsz.z&#41;yz&#41;&#41;
= &#40;Œªyz.y&#40;&#40;Œªz.z&#41;z&#41;&#41;
= &#40;Œªyz.y&#40;z&#41;&#41;
‚â° 1
</code></pre><p>Let‚Äôs break it down:</p><ol><li>Determine the successor (S) of zero (0).</li><li>Spell out the equivalent functional notation.</li><li>Apply <code>&#40;Œªsz.z&#41;</code> to <code>y</code> substituting the bound variable <code>s</code> to <code>y</code>.</li><li>Apply <code>&#40;Œªz.z&#41;</code> to <code>z</code> substituting the bound variable <code>z</code> to <code>z</code>.</li><li>Evaluation stops and <code>&#40;Œªyz.y&#40;z&#41;&#41;</code> is returned, which is the number 1.</li></ol><h3><a name="addition">Addition</a></h3><p>What if you wanted to perform <code>2+3</code>? Fortunately, the successor function can do that. You express that as <code>2S3</code>, where you replace <code>+</code> as the infix operator. The addition function is defined as:</p><pre><code class="scheme">Name: A
Profile: S ‚â° &#40;Œªxyz.y&#40;xyz&#41;&#41;
Inputs: x, y
Outputs: c
Usage: xAy
</code></pre><p>Let‚Äôs test it out:</p><pre><code class="scheme">2+3 ‚â° 2A3
‚â° &#40;Œªsz.s&#40;sz&#41;&#41;&#40;Œªxyz.y&#40;xyz&#41;&#41;&#40;Œªuv.u&#40;u&#40;uv&#41;&#41;&#41;
= SS3
‚â° &#40;Œªxyz.y&#40;xyz&#41;&#41;&#40;&#40;Œªxyz.y&#40;xyz&#41;&#41;&#40;Œªuv.u&#40;u&#40;uv&#41;&#41;&#41;&#41;
= &#40;Œªxyz.y&#40;xyz&#41;&#41;&#40;Œªyz.y&#40;&#40;Œªuv.u&#40;u&#40;uv&#41;&#41;&#41;yz&#41;&#41;
= &#40;Œªxyz.y&#40;xyz&#41;&#41;&#40;Œªyz.y&#40;y&#40;y&#40;yz&#41;&#41;&#41;&#41;
‚â° S4
= &#40;Œªyz.y&#40;&#40;Œªyz.y&#40;y&#40;y&#40;yz&#41;&#41;&#41;&#41;yz&#41;&#41;
= &#40;Œªyz.y&#40;y&#40;y&#40;y&#40;yz&#41;&#41;&#41;&#41;&#41;
‚â° 5
</code></pre><p>Let‚Äôs break it down:</p><ol><li>State the problem.</li><li>Spell out the equivalent functional notations for <code>2</code>, <code>S</code>, and <code>3</code>.</li><li>Reducing it gives you <code>SS3</code></li><li>The full version of <code>SS3</code>, which corresponds with <code>2S3</code> or two <code>S</code> and a <code>3</code>.</li><li>Reduce it further.</li><li>Reduce even further.</li><li>It is now reduced to <code>S4</code>.</li><li>Apply <code>S</code> to <code>4</code>.</li><li>You now arrive at <code>5</code>.</li></ol><h3><a name="multiplication">Multiplication</a></h3><p>The multiplication function is defined as:</p><pre><code class="scheme">Name: M
Profile: &#40;Œªxyz.x&#40;yz&#41;&#41;
Inputs: a, b
Outputs: c
Usage: Mab
</code></pre><p>Unlike with addition which uses infix syntax, multiplying two numbers follow a prefix syntax. So, to multiply <code>2</code> and <code>3</code>, you say <code>M23</code>.</p><p>Let‚Äôs test that out:</p><pre><code class="scheme">2&#42;3 ‚â° M23
‚â° &#40;Œªabc.a&#40;bc&#41;&#41;&#40;Œªsz.s&#40;sz&#41;&#41;&#40;Œªxy.x&#40;x&#40;xy&#41;&#41;&#41;
= &#40;Œªc.&#40;Œªsz.s&#40;sz&#41;&#41;&#40;&#40;Œªxy.x&#40;x&#40;xy&#41;&#41;&#41;c&#41;
= &#40;Œªcz.&#40;&#40;Œªxy.x&#40;x&#40;xy&#41;&#41;&#41;c&#41;&#40;&#40;&#40;Œªxy.x&#40;x&#40;xy&#41;&#41;&#41;c&#41;z&#41;&#41;
= &#40;Œªcz.&#40;Œªy.c&#40;c&#40;cy&#41;&#41;&#41;&#41;&#40;c&#40;c&#40;cz&#41;&#41;&#41;
= &#40;Œªcz.c&#40;c&#40;c&#40;c&#40;c&#40;cz&#41;&#41;&#41;&#41;&#41;&#41;
‚â° 6
</code></pre><p>Multiplying numbers in lambda calculus is pretty simple and straightforward. But, before you continue to more arithmetic functions, let‚Äôs tackle first truth values and conditionals, which is a prerequisite in learning the other functions.</p><h2><a name="tff">Truth, falsity, and friends</a></h2><h3><a name="booleans">Booleans</a></h3><p>The representations of true and false in lambda calculus, are succinct and elegant:</p><pre><code class="scheme">T ‚â° &#40;Œªxy.x&#41;
F ‚â° &#40;Œªxy.y&#41;
</code></pre><p>In action:</p><pre><code class="scheme">Tab ‚â° &#40;Œªxy.x&#41;ab = a
Fab ‚â° &#40;Œªxy.y&#41;ab = b
</code></pre><h3><a name="logicalops">Logical operations</a></h3><p>The three basic operators: AND, OR, and NOT:</p><pre><code class="scheme">‚àß ‚â° Œªxy.xy&#40;Œªuv.v&#41; ‚â° Œªxy.xyF
‚à® ‚â° Œªxy.x&#40;Œªuv.u&#41;y ‚â° Œªxy.xTy
¬¨ ‚â° Œªx.x&#40;Œªuv.v&#41;&#40;Œªab.a&#41; ‚â° Œªx.xFT
</code></pre><p>Let‚Äôs see if <code>¬¨T</code> is indeed <code>F</code>:</p><pre><code class="scheme">¬¨T
‚â° Œªx.x&#40;Œªuv.v&#41;&#40;Œªab.a&#41;&#40;Œªcd.c&#41;
‚â° TFT
‚â° &#40;Œªcd.c&#41;&#40;Œªuv.v&#41;&#40;Œªab.a&#41;
= &#40;Œªuv.v&#41;
‚â° F
</code></pre><h2><a name="countbackwards">Let‚Äôs count, backwards!</a></h2><h3><a name="pred">Predecessor</a></h3><p>The predecessor of a number is defined as the preceding number determined when counting backwards. The reason why the discussion on the predecessor function is being done separately is that it isn‚Äôt intuitively easy to determine at first, and that knowledge about other functions is important in understanding it.</p><p>Let‚Äôs say you have a pair, something like (y, x), wherein the first element is one step above, or the successor the second element. Since the first element is the successor, that means the second element is the predecessor. Visually:</p><pre><code class="scheme">&#40;z+1, z&#41; = &#40;z, z-1&#41;
</code></pre><p>Therefore,</p><pre><code class="scheme">x = Py iff y = Sx
</code></pre><p>That is, <code>x</code> is the predecessor of <code>y</code>, if and only if, <code>y</code> is the successor of <code>x</code>. So, to determine the predecessor of a number <code>x</code>, you create a pair like above, then select the second element.</p><p>Let‚Äôs define some basic units. A pair looks like:</p><pre><code class="scheme">&#40;Œªz.zab&#41;
</code></pre><p>And the smallest unit of pair is:</p><pre><code class="scheme">&#40;Œªz.z00&#41; ‚â° &#40;Œªz.z&#40;Œªsz.z&#41;&#40;Œªsz.z&#41;&#41;
</code></pre><p>To select the first and second elements of a pair, you use <code>T</code> and <code>F</code>:</p><pre><code class="scheme">&#40;Œªz.zab&#41;&#40;Œªxy.x&#41; ‚â° &#40;Œªz.zab&#41;T = Tab = a
&#40;Œªz.zab&#41;&#40;Œªxy.y&#41; ‚â° &#40;Œªz.zab&#41;F = Fab = b
</code></pre><p>You need a function that takes a pair, then creates a new pair, wherein the first element is the successor of the input‚Äôs first element and the second element is the input's first element:</p><pre><code class="scheme">Name: Q
Profile: &#40;Œªpz.z&#40;S&#40;pT&#41;&#41;&#40;pT&#41;&#41;
Inputs: &#40;a, b&#41;
Outputs: &#40;S&#40;a&#41;, a&#41;
Usage: Q&#40;a,b&#41;
</code></pre><p>Let‚Äôs test that out:</p><pre><code class="scheme">Q&#40;Œªz.z00&#41;
‚â° &#40;Œªpz.z&#40;S&#40;pT&#41;&#41;&#40;pT&#41;&#41;&#40;Œªz.z00&#41;
= &#40;Œªpz.z&#40;S&#40;pT&#41;&#41;&#40;pT&#41;&#41;&#40;Œªz.z&#40;Œªsz.z&#41;&#40;Œªsz.z&#41;&#41;
= &#40;Œªz.z&#40;Œªsz.s&#40;z&#41;&#40;Œªsz.z&#41;&#41;&#41;
‚â° &#40;Œªz.z10&#41;
</code></pre><p>Looks correct. You can now build your predecessor function:</p><pre><code class="scheme">Name: P
Profile: &#40;Œªn.nQ&#40;Œªz.z00&#41;&#41;F
Inputs: N, where N is a natural number
Outputs: N-1
Usage: PN
</code></pre><p>Let‚Äôs test that out:</p><pre><code class="scheme">P1
‚â° &#40;&#40;Œªn.nQ&#40;Œªz.z00&#41;&#41;F&#41;1
‚â° &#40;&#40;Œªn.nQ&#40;Œªz.z00&#41;&#41;F&#41;&#40;Œªsz.s&#40;z&#41;&#41;
= &#40;1Q&#40;Œªz.z00&#41;&#41;F
= &#40;&#40;Œªsz.s&#40;z&#41;&#40;&#40;Œªpz.z&#40;&#40;S&#40;pT&#41;&#41;&#40;pT&#41;&#41;&#41;&#40;Œªz.z&#40;Œªsz.z&#41;&#40;Œªsz.z&#41;&#41;&#41;&#41;&#41;&#40;Œªxy.y&#41;
= &#40;Œªz.&#40;&#40;Œªpz.z&#40;&#40;S&#40;pT&#41;&#41;&#40;pT&#41;&#41;&#41;&#40;Œªz.z&#40;Œªsz.z&#41;&#40;Œªsz.z&#41;&#41;&#41;z&#41;&#40;Œªxy.y&#41;
‚â° &#40;Œªu.&#40;&#40;Œªpz.z&#40;&#40;S&#40;pT&#41;&#41;&#40;pT&#41;&#41;&#41;&#40;Œªz.z&#40;Œªsz.z&#41;&#40;Œªsz.z&#41;&#41;&#41;u&#41;&#40;Œªxy.y&#41;
= &#40;&#40;Œªpz.z&#40;&#40;S&#40;pT&#41;&#41;&#40;pT&#41;&#41;&#41;&#40;Œªz.z&#40;Œªsz.z&#41;&#40;Œªsz.z&#41;&#41;&#41;&#40;Œªxy.y&#41;
= &#40;Œªz.z&#40;&#40;S&#40;&#40;Œªz.z&#40;Œªsz.z&#41;&#40;Œªsz.z&#41;&#41;T&#41;&#40;&#40;Œªz.z&#40;Œªsz.z&#41;&#40;Œªsz.z&#41;&#41;T&#41;&#41;&#41;&#41;&#40;Œªxy.y&#41;
= &#40;Œªz.z&#40;&#40;S&#40;Œªsz.z&#41;&#40;Œªsz.z&#41;&#41;&#41;&#41;&#40;Œªxy.y&#41;
= &#40;Œªz.z&#40;&#40;Œªsz.s&#40;z&#41;&#40;Œªsz.z&#41;&#41;&#41;&#41;&#40;Œªxy.y&#41;
= &#40;Œªxy.y&#41;&#40;&#40;Œªsz.s&#40;z&#41;&#40;Œªsz.z&#41;&#41;&#41;
= &#40;Œªsz.z&#41;
‚â° 0
</code></pre><h3><a name="subtraction">Subtraction</a></h3><p>Now that you have the predecessor function, you can build your subtraction function.</p><pre><code class="scheme">B ‚â° &#40;Œªxy.yPx&#41;
</code></pre><p>Let‚Äôs test that out:</p><pre><code class="scheme">B11
‚â° &#40;Œªxy.yPx&#41; &#40;Œªsz.s&#40;z&#41;&#41; &#40;Œªsz.s&#40;z&#41;&#41;
= &#40;Œªsz.s&#40;z&#41;&#41; &#40;P&#40;Œªsz.s&#40;z&#41;&#41;&#41;
= &#40;Œªsz.s&#40;z&#41;&#41; &#40;Œªsz.z&#41;
= &#40;Œªz.&#40;Œªsz.z&#41;z&#41;
= &#40;Œªz.&#40;Œªz.z&#41;&#41;
‚â° &#40;Œªsz.z&#41;
‚â° 0
</code></pre><h2><a name="closing">Closing remarks</a></h2><p>You‚Äôve just scratched the surface of lambda calculus, but you have just witnessed its immense expressive power, considering how minimal the system is defined.</p><p><i>Thanks to <a href='https://github.com/lucaslugao'>Lucas Lugao</a> for the corrections.</i></p><h2><a name="references">References</a></h2><ul><li><a href="http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf">http://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf</a></li><li><a href="http://www.cse.chalmers.se/research/group/logic/TypesSS05/Extra/geuvers.pdf">http://www.cse.chalmers.se/research/group/logic/TypesSS05/Extra/geuvers.pdf</a></li><li><a href="http://palmstroem.blogspot.com/2012/05/lambda-calculus-for-absolute-dummies.html">http://palmstroem.blogspot.com/2012/05/lambda-calculus-for-absolute-dummies.html</a></li><li><a href="https://goo.gl/ae1hjS">https://goo.gl/ae1hjS</a></li></ul><hr/><div class="footer"><p><div class="text-small"> <a href='/en/'>Home</a> ‚àÖ <a href='/en/about/'>About</a> ‚àÖ <a href='/en/quotes/'>Quotes</a> ‚àÖ <a href='/en/reflections/'>Reflections</a> </div></p><p><div class="text-x-small"> Made in üáµüá≠ with ‚ù§Ô∏è by Rommel Mart√≠nez </div></p><p></div></p></div><script src="/static/js/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>