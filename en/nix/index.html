<!DOCTYPE html>
<html lang="en"><head><title>A Gentle Introduction to the Nix Family</title><meta charset="utf-8" /><meta content="width=device-width,initial-scale=1.0,user-scalable=yes" name="viewport" /><meta content="noodp,noydir" name="robots" /><meta content="A journal about computing, human predilections, and random krakaboom." name="description" /><meta content="ebzzry, rommel, martinez, rommel martinez, english, esperanto, dired, retrospect, livefrog, usync, git, github, kvm, frog, ugarit, journal, blog, krakaboom, y, y combinator, lambda, lambda calculus, lisp, common lisp, scripting, scheme, racket, clojure, haskell, nixos, nixpkgs, nix, fallacies, symbols, marks, symbols and marks, essays, verb tenses, primer, introduction, linux, macos, ssh, division by zero, communicate, human, communicate like a human, human predilections, predilections, computing, inspiration, quotes, famous quotes, words, emem, tutorials, guides, hacks, emacs, emacs basics, emacs hacks, emacs tutorials, emacs commands, emacs tips, emacs tricks, zsh, zsh basics, zsh hacks, zsh tutorials, zsh commands, zsh tips, zsh tricks, tmux, tmux basics, tmux hacks, tmux tutorials, tmux commands, tmux tips, tmux tricks, pedantic pirate, musings" name="keywords" /><meta content="A Gentle Introduction to the Nix Family" property="og:title" /><meta content="article" property="og:type" /><meta content="https://ebzzry.io/en/nix/" property="og:url" /><meta content="https://ebzzry.io/static/ico/android-chrome-512x512.png" property="og:image" /><link href="/static/ico/apple-touch-icon.png" rel="apple-touch-icon" sizes="180x180" /><link href="/static/ico/favicon-16x16.png" rel="icon" sizes="16x16" type="image/png" /><link href="/static/ico/favicon-32x32.png" rel="icon" sizes="32x32" type="image/png" /><link href="/static/ico/manifest.json" rel="manifest" /><link color="#5bbad5" href="/static/ico/safari-pinned-tab.svg" rel="mask-icon" /><meta content="#ffffff" name="theme-color" /><style media="all" type="text/css">html {    color: #333;    font-size: 1em;    font-family: Georgia, Cambria, Palatino, "Palatino Linotype", "Times New Roman", Times, serif;    line-height: 1.45;    text-align: left:    width: 100%;    max-width: 40em;    margin: 0 auto 0 auto;    padding: 0;}body {    border-top: hidden;    border-bottom: hidden;    padding: 0 1.5em 1em 1.5em;    margin: 0;}#content {    -webkit-column-count: 1;    -moz-column-count: 1;    column-count: 1;}code {    font-size: 0.9em;    font-family: "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Lucida Console", "Courier New", Courier, monospace;    color: black;    display: inline-block;    font-weight: bold;}pre code {    font-size: 1em;    font-family: monospace;    line-height: 1.3em;    overflow: auto;    font-weight: normal;}kbd {    font-size: 1.1em;    padding: 0.1em 0.6em;    border: 1px solid #ccc;    font-family: monospace;    background-color: #f7f7f7;    color: #333;    -moz-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    -webkit-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    -moz-border-radius: 3px;    -webkit-border-radius: 3px;    border-radius: 3px;    display: inline-block;    margin: 0 0.1em;    text-shadow: 0 1px 0 #fff;    white-space: nowrap;}h1, h2, h3, h4, h5, h6 {    font-family: Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans", Tahoma, Geneva, Helvetica, Arial, sans-serif;    margin-bottom: 0;}h1 {    font-size: 2.5em;    text-align: center;    border-bottom: 6px solid black;}h2 {    font-size: 2.0em;    text-align: left;    border-bottom: 2px solid black;}h3 {    font-size: 1.6em;    text-align: left;    border-bottom: 1px solid lightgrey;}h4 {    font-size: 1.5em;    text-align: left;}h5 {    font-size: 1.3em;    text-align: left;}ul, ol {    padding-left: 2em;}ul li {    list-style-type: square;}ul li li {    list-style-type: disc;}ul li li li {    list-style-type: circle;}ol li {    list-style-type: decimal;}p, para, b, strong, i, em, emph {    font-size: 1em;}blockquote {    font-size: 1.2em;    font-style: italic;    margin-left: 2em;}b, strong {    font-weight: bold;}i, em, emph {    font-style: italic;}table {    margin: 0.5em;    border-spacing: 0;    border-collapse: collapse;}th, td {    border: 1px solid lightgray;    padding-top: 0;    padding-bottom: 0;    padding-left: 0.45em;    padding-right: 0.45em;}.text-right {    text-align: right;}.text-small {    font-size: small;}.text-x-small {    font-size: x-small;}.banner {    display: block;    width: 100%;    margin-left: auto;    margin-right: auto;}.footer {    text-align: right;    float: right;    max-width: 18em;}.cc {    border-width: 0}.center {    text-align: center;}</style><style media="all" type="text/css">/* Ewan Themes -- based 99.99% from Tomorrow Night Theme *//* http://jmblog.github.com/color-themes-for-google-code-highlightjs *//* Original theme - https://github.com/chriskempson/tomorrow-theme *//* http://jmblog.github.com/color-themes-for-google-code-highlightjs *//* Tomorrow Comment */.hljs-comment {  color: #969896;}/* Tomorrow Red */.hljs-variable,.hljs-attribute,.hljs-tag,.hljs-regexp,.ruby .hljs-constant,.xml .hljs-tag .hljs-title,.xml .hljs-pi,.xml .hljs-doctype,.html .hljs-doctype,.css .hljs-id,.css .hljs-class,.css .hljs-pseudo {  color: #cc6666;}/* Tomorrow Orange */.hljs-number,.hljs-preprocessor,.hljs-pragma,.hljs-built_in,.hljs-literal,.hljs-params,.hljs-constant {  color: #de935f;}/* Tomorrow Yellow */.ruby .hljs-class .hljs-title,.css .hljs-rule .hljs-attribute {  color: #f0c674;}/* Tomorrow Green */.hljs-string,.hljs-value,.hljs-inheritance,.hljs-header,.hljs-name,.ruby .hljs-symbol,.xml .hljs-cdata {  color: #b5bd68;}/* Tomorrow Aqua */.hljs-title,.css .hljs-hexcolor {  color: #8abeb7;}/* Tomorrow Blue */.hljs-function,.python .hljs-decorator,.python .hljs-title,.ruby .hljs-function .hljs-title,.ruby .hljs-title .hljs-keyword,.perl .hljs-sub,.javascript .hljs-title,.coffeescript .hljs-title {  color: #81a2be;}/* Tomorrow Purple */.hljs-keyword,.javascript .hljs-function {  color: #b294bb;}.hljs {  display: block;  overflow-x: auto;  background: #1d1f21;  color: #c5c8c6;  padding: 0.5em;  -webkit-text-size-adjust: none;}.coffeescript .javascript,.javascript .xml,.tex .hljs-formula,.xml .javascript,.xml .vbscript,.xml .css,.xml .hljs-cdata {  opacity: 0.5;}pre code {    font-size: 1.1em;    font-family: monospace;    line-height: 1.3em;    overflow: auto;}</style></head><body><div id="content"><h1>A Gentle Introduction to the Nix Family</h1><p><div class="center">March 22, 2017</div> <div class="center">Updated: April 6, 2017</div></p><blockquote><p>“Don’t worry about what anybody else is going to do. The best way to predict the future is to invent it.”<br> ―Alan Kay </p></blockquote><p>Ideas that change the way we do computing come rarely. A lot of the technology that we are using now are just re-hashes of old ones—layers upon layers of cosmetics enveloping old concepts. Entire product lines are based upon this lack of creativity and ingenuity. Old problems are not solved. Instead, these so-called innovative solutions merely pass around the problem while painting it with new shades, claiming that at least, they made it more colorful. This mentality harms progress in innumerable ways. This gives the false impression that solutions are actually being done. This creates a false sense of assurance of improvements.</p><p>Several years ago <a href='https://nixos.org/~eelco/'>Eelco Dolstra</a> wrote the seminal <a href='https://nixos.org/docs/papers.html'>papers</a> that described radical ways to deploy software. These papers effectively formed the cornerstones of <a href='https://nixos.org/nix/'>Nix</a>, a purely functional package manager language that solved the disease that plagued computing for a long time—poor package management. In this article I’ll talk about the Nix family, and how to use them to your advantage.</p><p>The <code>$</code> symbol will be used to indicate the shell prompt for a regular user, while the <code>#</code> symbol will denote the shell for the root user. There are cases when the <a href='https://en.wikipedia.org/wiki/User_identifier#Effective_user_ID'>EUID</a> of a command will be zero (0) due to the use of sudo.</p><h2>Table of contents</h2><ul><li><a href='#nixos'>NixOS</a><ul><li><a href='#nixosinstallation'>Installation</a><ul><li><a href='#nixosboot'>Boot machine</a></li><li><a href='#nixosnetworking'>Setup networking</a></li><li><a href='#nixosdisks'>Prepare disks</a></li><li><a href='#nixosinstall'>Install to disk</a></li></ul></li><li><a href='#nixosconfiguration'>Configuration</a></li></ul></li><li><a href='#nix'>Nix</a><ul><li><a href='#nixstrings'>Strings</a></li><li><a href='#nixnumbers'>Numbers</a></li><li><a href='#nixbooleans'>Booleans</a></li><li><a href='#nixlists'>Lists</a></li><li><a href='#nixsets'>Sets</a></li><li><a href='#nixpaths'>Paths</a></li><li><a href='#nixfunctions'>Functions</a></li><li><a href='#nixlet'>Let</a></li><li><a href='#nixwith'>With</a></li><li><a href='#nixconditionals'>Conditionals</a></li><li><a href='#niximports'>File imports</a></li></ul></li><li><a href='#nixpkgs'>Nixpkgs</a><ul><li><a href='#nixpkgsinstallation'>Installation</a></li><li><a href='#nixpkgsusage'>Usage</a><ul><li><a href='#nixpkgsgit'>Git checkout</a></li><li><a href='#nixpkgschannels'>Channels</a></li><li><a href='#nixpkgsother'>Other commands</a></li></ul></li><li><a href='#nixpkgsconfiguration'>Configuration</a></li><li><a href='#nixpkgscontribute'>Contributing</a><ul><li><a href='#nixpkgsupdateexisting'>Updating an existing package</a></li><li><a href='#nixpkgssubmitnew'>Submitting a new package</a></li></ul></li><li><a href='#nixpkgsnotes'>Notes</a></li></ul></li><li><a href='#environments'>Environments</a><ul><li><a href='#systemenvironment'>System environment</a></li><li><a href='#userenvironment'>User environment</a></li><li><a href='#developmentenvironment'>Development environment</a></li></ul></li><li><a href='#closing'>Closing remarks</a></li><li><a href='#bonus'>Bonus</a></li></ul><h2><a name="nixos"></a> NixOS</h2><p>How many times have you had a broken system because you upgraded a software that other components depended on? How many late night stays have you had because you had to make an application work, because the new package that you installed broke it? How many times, when in frustration, you gave up repairing your system and just decided to re-install your system from scratch? Restoring data files are easy; restoring system configuration from the last working state, however, is a one-way ticket to hell.</p><p><a href='https://nixos.org'>NixOS</a> is a Linux distribution that solves these problems by leveraging on the determinism of <a href='https://nixos.org/nix'>Nix</a> and by using a single declarative configuration file that contains all settings and knobs in one place—<code>/etc/nixos/configuration.nix</code>. This file conntain information about your filesystems, users, services, network configuration, input devices, kernel parameters, and more. This means that you can take a <code>configuration.nix</code> of someone, and have his exact system configuration! In NixOS you don’t have to fiddle around with the whole system manually for configuration that want. You don’t have to use ad-hoc solutions to specify a desired configuration state. You don’t need to install additional software to manage system configuration.</p><p>NixOS does not follow the <a href='https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard'>FHS</a>, effectively preventing additional brain damage.  This gives room for a lot of flexibility and ingenuity. It does not have <code>/usr/</code> and <code>/opt/</code>. It does have <code>/bin/</code>, which contains only <code>sh</code> and <code>/usr/bin/</code> which contains only <code>env</code>—both of which are actually symlinks to the real programs somewhere in <code>/nix/store/</code>. The top-level location for system binaries—the ones installed explicitly by the administrator—are located in <code>/run/current-system/sw/bin/</code> and <code>/run/current-system/sw/sbin/</code>.  User-installed programs, on the other hand, are available at their respective <code>&#126;/.nix-profile/bin/</code>. These locations cannot be modified through normal means; dedicated programs must be used to write to these trees.</p><h3><a name="nixosinstallation"></a> Installation</h3><p>Installation of NixOS is straightforward. For bare metal systems, download an installer from <a href='https://nixos.org/nixos/download.html'>https://nixos.org/nixos/download.html</a>. VM images are also available from that page. For my last installation, I installed with the following setup:</p><ul><li><a href='https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface'>UEFI</a></li><li>USB boot</li><li>Wi-Fi connectivity</li><li><a href='https://en.wikipedia.org/wiki/GUID_Partition_Table'>GUID Partition Table (GPT)</a></li><li><a href='https://en.wikipedia.org/wiki/Linux_Unified_Key_Setup'>LUKS</a> over <a href='https://en.wikipedia.org/wiki/Logical_volume_management'>LVM</a></li></ul><h4><a name="nixosboot"></a> Boot machine</h4><p>Boot from the USB drive in UEFI mode. On the login prompt, login as <code>root</code>.</p><h4><a name="nixosnetworking"></a> Setup networking</h4><p>Scan for available networks</p><pre><code># nmcli d wifi list</code></pre><p>Then, connect to the router of choice</p><pre><code># nmcli d wifi con Foobarbaz name Foo password supersecretkey</code></pre><h4><a name="nixosdisks"></a> Prepare disks</h4><p>Create the partitions</p><pre><code># gdisk /dev/sda
sda1: EF00 &#40;EFI system&#41;, 512 MiB
sda2: 8E00 &#40;Linux LVM&#41;, rest</code></pre><p>Format <code>/dev/sda1</code></p><pre><code># mkfs.vfat -F32 /dev/sda1</code></pre><p>Create the physical volume</p><pre><code># pvcreate /dev/sda2</code></pre><p>Create the volume group</p><pre><code>vgcreate vg /dev/sda2</code></pre><p>Create the logical volumes</p><pre><code># lvcreate -L 20G -n swap vg
# lvcreate -l 100%FREE -n root vg</code></pre><p>Encrypt root</p><pre><code># cryptsetup luksFormat /dev/vg/root
# cryptsetup luksOpen /dev/vg/root root</code></pre><p>Format root</p><pre><code># mkfs.ext4 -j -L root /dev/mapper/root</code></pre><p>Format swap</p><pre><code># mkswap -L /dev/vg/swap</code></pre><p>Mount the filesystems</p><pre><code># mount /dev/mapper/root /mnt
# mkdir /mnt/boot
# mount /dev/sda1 /mnt/boot</code></pre><p>Enable swap</p><pre><code># swapon /dev/vg/swap</code></pre><h4><a name="nixosinstall"></a> Install to disk</h4><p>Create the base config</p><pre><code># nixos-generate-config --root /mnt</code></pre><p>Edit the config file</p><pre><code>nano /mnt/etc/nixos/configuration.nix</code></pre><p>To give you a headstart, you may use a trimmed-down version of <a href='https://github.com/ebzzry/dotfiles/blob/master/nixos/configuration.nix'>my configuration</a> follows. Replace the values as it suits you. All available configuration knobs are available <a href='https://nixos.org/nixos/options.html'>here</a>.</p><pre><code class="nix">{ config, lib, pkgs, ... }:

{
  imports = &#91;
      ./hardware-configuration.nix
  &#93;;

  boot = {
    loader = {
      systemd-boot.enable = true;
      efi.canTouchEfiVariables = true;
    };

    initrd.availableKernelModules = &#91;
      &quot;xhci&#95;pci&quot;
      &quot;ehci&#95;pci&quot;
      &quot;ahci&quot;
      &quot;usb&#95;storage&quot;
      &quot;sd&#95;mod&quot;
      &quot;rtsx&#95;pci&#95;sdmmc&quot;
    &#93;;

    initrd.luks.devices = &#91;
      {
        device = &quot;/dev/vg/root&quot;;
        name = &quot;root&quot;;
        preLVM = false;
      }
    &#93;;

    cleanTmpDir = true;
  };

  fileSystems = &#91;
    {
      device = &quot;/dev/disk/by-uuid/6106-6BF8&quot;;
      fsType = &quot;vfat&quot;;
      mountPoint = &quot;/boot&quot;;
    }

    {
      device = &quot;/dev/mapper/root&quot;;
      fsType = &quot;ext4&quot;;
      mountPoint = &quot;/&quot;;
    }
  &#93;;

  swapDevices = &#91;
    {
      device = &quot;/dev/vg/swap&quot;;
    }
  &#93;;

  networking = {
    hostName = &quot;mehfoo&quot;;
    hostId = &quot;7B1548AE&quot;;
    enableIPv6 = true;
    networkmanager.enable = true;
  };

  environment = {
    systemPackages = with pkgs; &#91; zsh &#93;;
  };

  time.timeZone = &quot;Asia/Manila&quot;;

  security.sudo = {
    enable = true;
    configFile = ''
      Defaults env&#95;reset
      root ALL = &#40;ALL:ALL&#41; ALL
      %wheel ALL = &#40;ALL&#41; SETENV: NOPASSWD: ALL
    '';
  };

  services = {
    xserver = {
      autorun = true;
      defaultDepth = 24;
      enable = true;
      displayManager.kdm.enable = true;
      desktopManager.kde5.enable = true;
      videoDrivers = &#91; &quot;intel&quot; &#93;;
    };
  };

  users = {
    extraUsers.ogag = {
      isNormalUser = true;
      uid = 1000;
      extraGroups = &#91; &quot;wheel&quot; &quot;networkmanager&quot; &quot;docker&quot; &#93;;
    };
    defaultUserShell = &quot;/run/current-system/sw/bin/zsh&quot;;
  };
}
</code></pre><p>Save this with:</p><pre><code># curl -sSLo /mnt/etc/nixos/configuration.nix https://goo.gl/ZTQcGs</code></pre><p>A longer version is available at:</p><pre><code># curl -sSLo /mnt/etc/nixos/configuration.nix https://goo.gl/K4P7l5</code></pre><p>Replace the UUID of the disk with the one that you have. Use the command <code>blkid</code> to get the UUIDs. For <code>networking.hostID</code>, use the following command:</p><pre><code># cksum /etc/machine-id | while read c rest; do printf &quot;%x&quot; $c; done</code></pre><p>The above configuration specifies the following, among other things:</p><ul><li>It creates a user <code>ogag</code> with full sudo access</li><li>It uses KDE 5 as the desktop environment</li><li>It enables SSH</li><li>It specifies the LUKS parameters</li></ul><p>Install NixOS to the disk</p><pre><code># nixos-install</code></pre><p>This will parse <code>/etc/nixos/configuration.nix</code>, making sure that there are no errors. This command will download all the necessary packages to match the specification, making sure that no stones are left unturned.</p><p>When the installation completes, reboot your system:</p><pre><code># reboot</code></pre><h3><a name="nixosconfiguration"></a> Configuration</h3><p>After installation, updating your existing configuration is trivial. All you have to do is edit the configuration file then rebuild the system:</p><pre><code># nano /etc/nixos/configuration.nix
# nixos-rebuild switch</code></pre><p>If you make a mistake, the system will notify you of it, instead of proceeding with an incorrect configuration. After the system has completed booting, switch to the console <kbd>Ctrl+Alt+F1</kbd>, then login as <code>root</code>, then set a password for the user that we specified in <code>configuration.nix</code>:</p><pre><code># passwd ogag</code></pre><p>Exit the shell, switch to the graphical interface <kbd>Alt+F7</kbd>, then login as <code>ogag</code>.</p><h2><a name="nix"></a> Nix</h2><p>The component that forms the heart of NixOS and Nixpkgs is the <a href='https://nixos.org/nix'>Nix</a> language. It is a declarative language designed in mind to handle packages.</p><p>To make it easier to understand the language, let’s install the Nix REPL:</p><pre><code>$ nix-env -iA $&#40;nix-channel --list | awk '{print $1}'&#41;.nix-repl</code></pre><p>Next, let’s run it. You’ll be greeted with the version number, and the nix-repl prompt. At the time of writing, the latest stable version is 1.11.8:</p><pre><code class="nix">$ nix-repl
Welcome to Nix version 1.11.8. Type :? for help.

nix-repl&gt;
</code></pre><p>Let’s try out some basic expressions.</p><h3><a name="nixstrings"></a> Strings</h3><p>Just like in other languages, strings evaluate to themselves:</p><pre><code class="nix">nix-repl&gt; &quot;foo&quot;
&quot;foo&quot;
</code></pre><p>To concatenate strings, use the <code>+</code> operator:</p><pre><code class="nix">nix-repl&gt; &quot;foo&quot; + &quot;bar&quot;
&quot;foobar&quot;
</code></pre><p>Another way to declare strings is to use two pairs of single quotes. Do not mistake it with the double quotes:</p><pre><code class="nix">nix-repl&gt; ''foo bar''
&quot;foo bar&quot;
</code></pre><p>The advantage of using <code>''</code> over <code>&quot;</code> is that allows the presence of <code>&quot;</code> inside it:</p><pre><code class="nix">nix-repl&gt; ''&quot;foo&quot; &quot;bar&quot;''
&quot;\&quot;foo\&quot; \&quot;bar\&quot;\&quot;
</code></pre><p>The value that it then returns will be properly quoted. This is useful later when we’re going to build complex expressions.</p><p>To deference strings inside strings, use the <code>${name}</code> form:</p><pre><code class="nix">nix-repl&gt; x = &quot;foo&quot;

nix-repl&gt; y = &quot;bar&quot;

nix-repl&gt; &quot;${x} ${y}&quot;
&quot;foo bar&quot;

nix-repl&gt; ''${x} ${y}''
&quot;foo bar&quot;
</code></pre><h3><a name="nixnumbers"></a> Numbers</h3><p>Basic arithmetic operations in Nix are included, with a small twist:</p><pre><code class="nix">nix-repl&gt; 6+2
8

nix-repl&gt; 6-2
4

nix-repl&gt; 6&#42;2
12

nix-repl&gt; 6/2
/home/ogag/6/2
</code></pre><p>Oops, that wasn’t what we expected. Since Nix was designed with files and directories in mind, it made a special case that when a <code>/</code> character is surrounded by non-space characters, it interprets it as a directory path, resulting in an absolute path. To actually perform division, add at least one space before and after the <code>/</code> character:</p><pre><code class="nix">nix-repl&gt; 6 / 2
</code></pre><p>There are no floating point numbers in Nix. So, if you try to evaluate one, you’ll get:</p><pre><code class="nix">nix-repl&gt; 1.0
error: syntax error, unexpected INT, expecting ID or OR&#95;KW or DOLLAR&#95;CURLY or '&quot;', at &#40;string&#41;:1:3
'&quot;'
</code></pre><p>The function <code>builtins.div</code> does essentially the same as <code>/</code>:</p><pre><code class="nix">nix-repl&gt; builtins.div 6 3
2
</code></pre><p>The difference, however, is that <code>builtins.div</code> can be applied partially:</p><pre><code class="nix">nix-repl&gt; &#40;builtins.div 6&#41;
«primop-app»
</code></pre><p>This expressions returns a closure of a partially applied function. We need another value to fully apply it:</p><pre><code class="nix">nix-repl&gt; &#40;builtins.div 6&#41; 3
2
</code></pre><p>We can even store the value of that partial application:</p><pre><code class="nix">nix-repl&gt; d = builtins.div 6
</code></pre><p>The <code>=</code> operator in Nix is used to bind values. In this example, it is used to define a partial application. To use that function:</p><pre><code class="nix">nix-repl&gt; d 3
2
</code></pre><h3><a name="nixbooleans"></a> Booleans</h3><p>Truth- and falsehood are represented with <code>true</code> and <code>false</code>:</p><pre><code class="nix">nix-repl&gt; 1 &lt; 2
true

nix-repl&gt; 1 &gt; 2
false

nix-repl&gt; 1 == 1
true

nix-repl&gt; &quot;foo&quot; == &quot;foo&quot;
true

nix-repl&gt; &quot;foo&quot; &lt; &quot;bar&quot;
false

nix-repl&gt; false || true
true

nix-repl&gt; false &amp;&amp; true
false
</code></pre><h3><a name="nixlists"></a> Lists</h3><p>Lists are heterogeneous types for containing serial values. Elements are separated by spaces:</p><pre><code class="nix">nix-repl&gt; &#91; 1 &quot;foo&quot; true &#93;
&#91; 1 &quot;foo&quot; true &#93;
</code></pre><p>To concatenate lists:</p><pre><code class="nix">nix-repl&gt; &#91; 1 &quot;foo&quot; true &#93; ++ &#91; false &#40;6 / 2&#41; &#93;
&#91; 1 &quot;foo&quot; true false 3 &#93;
</code></pre><p>To extract the head:</p><pre><code class="nix">nix-repl&gt; builtins.head &#40;&#91; 1 &quot;foo&quot; true &#40;6 / 2&#41; &#93; ++ &#91; false &#40;6 / 2&#41; &#93;&#41;
1
</code></pre><p>To extract the tail:</p><pre><code class="nix">nix-repl&gt; builtins.tail &#40;&#91; 1 &quot;foo&quot; true &#40;6 / 2&#41; &#93; ++ &#91; false &#40;6 / 2&#41; &#93;&#41;
&#91; &quot;foo&quot; true 3 false 3 &#93;
</code></pre><p>Lists are indexed starting at <a href='https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html'>0</a>. To get the <em>1th</em> element, use the <code>builtins.elemAt</code> operator:</p><pre><code class="nix">nix-repl&gt; builtins.elemAt &#91; 1 &quot;foo&quot; true &#93; 1
&quot;foo&quot;
</code></pre><h3><a name="nixsets"></a> Sets</h3><p>An important data structure in Nix are sets. They are keyword-value pairs separated by semi-colons:</p><pre><code class="nix">nix-repl&gt; { a = 0; b = &quot;bar&quot;; c = true; d = &#40;6 / 2&#41;; }
</code></pre><p>What makes sets different from lists is that extracting values from them are done by making name references. To extract the value of <code>b</code>, use the <code>.</code> operator:</p><pre><code class="nix">nix-repl&gt; { a = 0; b = &quot;bar&quot;; c = true; d = &#40;6 / 2&#41;; }.b
&quot;bar&quot;
</code></pre><p>which is equivalent to:</p><pre><code class="nix">nix-repl&gt; { a = 0; b = &quot;bar&quot;; c = true; d = &#40;6 / 2&#41;; }.&quot;b&quot;
&quot;bar&quot;
</code></pre><p>To dereference a member from the same set, use the <code>rec</code> keyword:</p><pre><code class="nix">nix-repl&gt; rec { a = 0; b = &quot;bar&quot;; c = true; d = &#40;6 / 2&#41;; e = b; }.e
&quot;bar&quot;
</code></pre><h3><a name="nixpaths"></a> Paths</h3><p>In Nix all paths are translated to absolute ones. If you make a reference to a file in the current directory:</p><pre><code class="nix">nix-repl&gt; ./foo
/home/ogag/foo
</code></pre><p>It gets translated to an absolute path. This is a Good Thing™.</p><p>Similarly, if you make a reference to a relative path inside an absolute path, it still gets translated to an absolute one:</p><pre><code class="nix">nix-repl&gt; /./foo
/foo
</code></pre><p>Note, however, that Nix doesn’t like paths that stand alone:</p><pre><code class="nix">nix-repl&gt; /
error: syntax error, unexpected '/', at &#40;string&#41;:1:1

nix-repl&gt; ./
error: syntax error, unexpected '.', at &#40;string&#41;:1:1
</code></pre><h3><a name="nixfunctions"></a> Functions</h3><p>What fun would it be if there’ll be no verbs to use with these nouns? Functions in Nix share similarities with other languages while having its own unique traits.</p><p>The most basic form of a function follows:</p><pre><code class="nix">nix-repl&gt; x: x
«lambda»
</code></pre><p>This expression creates an anonymous function that returns its argument—the <a href='https://en.wikipedia.org/wiki/Identity_function'>identity function</a>. The colon after the first <em>x</em> indicates that it is a parameter to the function, just like in <a href='/en/lambda-calculus/#functions'>lambda calculus</a>. Also, the names do not matter due to <a href='https://en.wikipedia.org/wiki/Lambda_calculus#Alpha_equivalence'>alpha equivalence</a>:</p><pre><code class="nix">nix-repl&gt; foo-bar-baz: foo-bar-baz
«lambda»
</code></pre><p>These functions are not of much use because they are not captured for application. If we want to use it, for example with the argument <code>&quot;foo&quot;</code>, we need to surround it with parentheses:</p><pre><code class="nix">nix-repl&gt; &#40;x: x&#41; &quot;foo&quot;
&quot;foo&quot;
</code></pre><p>To add more fun, let’s name that function:</p><pre><code class="nix">nix-repl&gt; identity = x: x
</code></pre><p>Sweet! Now, let’s apply it:</p><pre><code class="nix">nix-repl&gt; identity &quot;foo&quot;
&quot;foo&quot;
</code></pre><p>Let’s create a function that appends <code>&quot; ugh&quot;</code> to its input, then let’s apply it:</p><pre><code class="nix">nix-repl&gt; ugh = s: s + &quot; ugh&quot;

nix-repl&gt; ugh &quot;me&quot;
&quot;me ugh&quot;
</code></pre><p>To define a function that takes another argument, let’s use the following form:</p><pre><code class="nix">nix-repl&gt; ugh = s: t: s + &quot; ugh &quot; + t

nix-repl&gt; ugh &quot;me&quot; &quot;you&quot;
&quot;me ugh you&quot;
</code></pre><p>The pattern is that to add an additional parameter, use the <code>name: </code> form.</p><p>Sets, when used with functions, enable more powerful abstractions. We can pass a set as an argument to a function, which will then use the data inside that set:</p><pre><code class="nix">nix-repl&gt; poof = { a, b }: x: a + &quot; &quot; + b + x
</code></pre><p>This function has two parameters: <code>{ a, b }</code>—a parameter specification for a set with two elements, and <code>x</code>—a regular parameter. Take note, that the parameter specification is not a real set, but merely a way to match arguments; it uses a comma, as value separator. Inside this function we combine the inputs with the <code>+</code> operator. To use this function, we’d do it like:</p><pre><code class="nix">nix-repl&gt; poof { a = &quot;ugh&quot;; b = &quot;me&quot;; } &quot; poof&quot;
&quot;ugh me poof&quot;
</code></pre><p>When a function declares a set as its parameter, you need to specify the keywords when invoking the function that uses them. In this case the keyword names are <code>a</code> and <code>b</code>.</p><p>The definition of <code>poof</code> above is semantically similar to:</p><pre><code class="nix">nix-repl&gt; poof = meh: x: meh.a + &quot; &quot; + meh.b + x
</code></pre><p>We used a regular, non-set parameter here so that it can refer to the set as a value. Observe this:</p><pre><code class="nix">nix-repl&gt; meh = { a = &quot;foo&quot;; b = &quot;bar&quot;; }

nix-repl&gt; meh.a
&quot;foo&quot;
</code></pre><p>It is also possible to specify default values. When a parameter with default value is not used, the default value is used. They are declared similarly in Common Lisp:</p><pre><code class="lisp">&#40;defun foop &#40;a &amp;optional &#40;b &quot;O.o&quot;&#41;&#41;
  &#40;concatenate 'string a b'&#41;&#41;
</code></pre><pre><code class="nix">nix-repl&gt; foop = { a, b ? &quot;O.o&quot; }: a + b

nix-repl&gt; foop { a = &quot;goo&quot;; }
&quot;gooO.o&quot;

nix-repl&gt; foop { a = &quot;goo&quot;; b = &quot;oog&quot;; }
&quot;goooog&quot;
</code></pre><p>To add even more flexibility, Nix supports the use of pseudorest arguments. Let’s modify the function from above:</p><pre><code class="nix">nix-repl&gt; foop = { a, b, ...}: a + b
</code></pre><p>Let’s use it:</p><pre><code class="nix">nix-repl&gt; foop { a = &quot;meh&quot;; b = &quot;foo&quot;; }
&quot;mehfoo&quot;
</code></pre><p>The same. So how can we make use of that flexibility, then? We’ll create a label for the attribute set, so that we can refer to the ‘extra’ values:</p><pre><code class="nix">nix-repl&gt; foop = attrs@{ a, b, ...}: a + b + attrs.blah
</code></pre><p>We use it just like before, but with the use of the label:</p><pre><code class="nix">nix-repl&gt; foop { a = &quot;goo&quot;; b = &quot;oog&quot;; c = &quot;hhh&quot;; }
&quot;gooooghhh&quot;
</code></pre><p>I said ‘pseudo’ because the value for <code>c</code> was still required.</p><p>Default values and variable arity can be combined together:</p><pre><code class="nix">nix-repl&gt; foop = attrs@{ a, b, c ? &quot;C&quot;, ... }: a + b + c + attrs.d

nix-repl&gt; foop { a = &quot;A&quot;; b = &quot;B&quot;; d = &quot;D&quot;; }
&quot;ABCD&quot;

nix-repl&gt; foop { a = &quot;A&quot;; b = &quot;B&quot;; c = &quot;X&quot;; d = &quot;D&quot;; }
&quot;ABXD&quot;

</code></pre><h3><a name="nixlet"></a> Let</h3><p>The keyword <code>let</code> lets (pun not intended) us define variables in a local scope. For example, to make the identifiers <code>x</code> and <code>y</code> visible only in a local scope:</p><pre><code class="nix">nix-repl&gt; let x = &quot;foo&quot;; y = &quot;bar&quot;; in x + poof { a = &quot;huh&quot;; b = &quot;really&quot;; } &quot;hmm&quot; + y
&quot;foohuh reallyhmmbar&quot;
</code></pre><p>Take note of the last <code>;</code> before the <code>in</code> keyword that goes with <code>let</code>—it marks the start of the <code>let</code> body. The let construct behaves in similar ways to the <code>let</code> keyword found in languages like Lisp and Haskell.</p><h3><a name="nixwith"></a> With</h3><p>The keyword <code>with</code> lets you ‘drop’ set values in a scope:</p><pre><code class="nix">nix-repl&gt; with { x = &quot;foo&quot;; y = &quot;bar&quot;; }; poof { a = y; b = x; } &quot; xyz&quot;
&quot;bar foo xyz&quot;
</code></pre><p>What happened here is that the values inside that set were ‘unveiled’ to make them available in the <code>with</code> body.</p><h3><a name="nixconditionals"></a> Conditionals</h3><p>Conditional expressions are done with the <code>if</code> keyword. It has a similar form with mainstream languages:</p><pre><code class="nix">nix-repl&gt; if true then &quot;true&quot; else &quot;false&quot;
&quot;true&quot;
</code></pre><p>It can also be nested:</p><pre><code class="nix">nix-repl&gt; if false then &quot;true&quot; else if false then &quot;true&quot; else if false then &quot;true&quot; else &quot;false&quot;
&quot;false&quot;
</code></pre><h3><a name="niximports"></a> File imports</h3><p>The idea of importing files into a Nix expression is subtly different from other languages. Imports in Nix are closely tied with sets. Presuming we have the file <code>meh.nix</code> that contains the following:</p><pre><code class="nix">let
  meh = x: x + &quot;meh&quot;;
in {
  meh = meh;
}
</code></pre><p>The let expression binds the name <em>meh</em> to a function that takes one argument. In the body of let, it returns a set which contains one member with the name <em>meh</em>—the one on the left side of the <code>=</code>. The value of this member is the function that was just defined. The important concept to remember here is that this let expression returns an attribute set.</p><p>Let’s go back to the REPL to use this file:</p><pre><code class="nix">nix-repl&gt; import ./meh.nix
{ meh = «lambda»; }
</code></pre><p>We see again the familiar lambda term. The <em>meh</em> name here, as it shows, is a function. Now, how can we dereference this value? With the use of the <code>.</code> operator!</p><pre><code class="nix">nix-repl&gt; &#40;import ./meh.nix&#41;.meh &quot;foo&quot;
&quot;foomeh&quot;
</code></pre><p>We had to use parentheses because there is no such file as <code>meh.nix.meh</code> in the current directory. If we’re going to step through it, it would like the following:</p><pre><code class="nix">nix-repl&gt; { meh = «lambda»; }.meh &quot;foo&quot;
</code></pre><p>becoming:</p><pre><code class="nix">nix-repl&gt; { meh = &#40;x: x + &quot;meh&quot;&#41;; }.meh &quot;foo&quot;
&quot;foomeh&quot;
</code></pre><p>This pretty sums up the introductory concepts about the Nix language. The rest of the hairy details are available in the <a href='https://nixos.org/nix/manual/#ch-expression-language'>manual</a>.</p><h2><a name="nixpkgs"></a> Nixpkgs</h2><p>Nixpkgs is a collection of thousands of packages curated and maintained by users worldwide. Since the source code is in <a href='https://github.com/nixos/nixpkgs'>GitHub</a>, it is able to take advantage of the powerful collaboration models that that platform offers. At the time of writing, there are almost 6500 packages in <a href='https://nixos.org/nixos/packages.html'>the collection</a>. It contains a wide array of packages ranging from productivity applications to theorem provers.</p><p>Most of the popular operating systems handle packages well, until, they don’t. As long as you are moving in a straight line, alone, you’ll be fine. Things change, when you introduce other people in the walk. For the whole cast to move in unison, everyone must be strictly connected to one another. If a member decides to break off, and walk on his own, the entire cast becomes crippled. However, if that member clones himself so that the departing copy becomes independent, the original walking cast becomes undisturbed.</p><p>Let’s take the case of a distribution aimed as a multi-user production development environment. When you install Firefox 100, the main binary goes to either <code>/usr/bin/firefox</code> or <code>/usr/local/bin/firefox</code>. All the users then, in this system, will be able to access the application from that path; John, Mary, and Peter are happy. However, when John upgrades it to version 200, the same application that is being used by Mary and Peter get upgraded, too!. That’s not a good thing if they prefer the old version that works with them! Nixpkgs allows you have multiple versions of a software, without collisions from the other versions. John, Mary, and Peter can all have their versions of Firefox without conflicting with the other versions. How does it do it? It does it by naming components by their computed checksums, and by not using a common global location.</p><p>Each user has their own versions of <code>&#126;/.nix-profile</code> and all of the contents of those directories do not contain regular files. Instead, they are all symbolic files to the actual files located in <code>/nix/store/</code>. This directory is where programs and their dependencies are actually installed. The only way to write to that directory is through the Nix-specific programs. There is no way to modify the contents of that directory through normal means. So, when regular user <code>john</code> installs Vim 8, the program becomes installed as something like <code>/nix/store/w4cr4j13lqzry2b8830819vdz3sdypfa-vim-8.0.0329</code>. The characters before the package name is the checksum of all the inputs to build the package. The file <code>/home/john/.nix-profile/bin/vim</code> then points to a symlink to a file in <code>/nix/store/</code> that will lead to the actual Vim binary in <code>/nix/store/w4cr4j13lqzry2b8830819vdz3sdypfa-vim-8.0.0329/bin/vim</code>.</p><h3><a name="nixpkgsinstallation"></a> Installation</h3><p>Skip this step if you are using NixOS because Nixpkgs already comes with it. To install Nixpkgs on GNU/Linux or macOS, run:</p><pre><code>$ curl https://nixos.org/nix/install | bash</code></pre><p>You’ll be prompted to enter credentials for root access via sudo because it will install the resources to <code>/nix/</code>. After the installation, you may also be requested to append a line of command to your shell initialization file. When you spawn a new shell instance, the Nix-specific commands will be available for use.</p><h3><a name="nixpkgsusage"></a> Usage</h3><p>There are two ways to install packages with Nixpkgs: the git checkout, which is the bleeding edge, up-to-the-minute updated version, or by using channels. The <a href='https://github.com/nixos/nixpkgs'>git repository</a> is ideal for people who want to use the latest and greatest available version of a package, or for those who want to test things out. <a href='https://nixos.org/channels/'>Channels</a> on the other hand, are essentially snapshots of the git repository at an earlier version.</p><h4><a name="nixpkgsgit"></a> Git checkout</h4><p>Updates to the git repository happen frequently—as you are reading this article, <a href='https://github.com/nixos/nixpkgs/pulls?utf8=%E2%9C%93&q=is%3Apr%20is%3Aclosed'>new commits</a> are made to the main tree. To use the git checkout, clone the <a href='https://github.com/nixos/nixpkgs'>repository</a>:</p><pre><code>$ git clone https://github.com/nixos/nixpkgs &#126;/nixpkgs</code></pre><p>This command creates a <code>nixpkgs/</code> directory under your home. If your username is <code>ogag</code>, the clone of the repository is available at <code>/home/ogag/nixpkgs/</code> or <code>/Users/ogag/nixpkgs</code>, if you’re using a GNU/Linux or macOS, respectively.</p><p>To install a package, say emem—a Markdown to HTML converter—using the git checkout, run:</p><pre><code>$ nix-env -f &#126;/nixpkgs/default.nix -iA emem</code></pre><p>This will download emem along with all its dependencies, and then it will make the program available to you. To make sure that emem has successfully installed, run:</p><pre><code>$ emem --version</code></pre><p>If your shell doesn’t barf and complain that you’re looking for something that does not exist, and instead you see a version number, it means that you have successfully installed emem.</p><p>To get the most recent changes from the git repo, run:</p><pre><code>$ cd &#126;/nixpkgs &amp;&amp; git pull origin master</code></pre><h4><a name="nixpkgschannels"></a> Channels</h4><p>Installing packages via channels is nicer, because the commands to install packages with it are more convenient. The trade-off is that the packages will be out-of-date by a few weeks. If you’re fine with it, then use channels instead of the git checkout.</p><p>Channels are labeled <strong>stable</strong>, <strong>unstable</strong>, or with a specific version number, e.g., <strong>16.09</strong> or <strong>17.03</strong>. For this article, let’s use the unstable channel—it’s not as dated as stable, nor as recent as the git checkout. To subscribe to the unstable channel, run:</p><pre><code>$ nix-channel --add https://nixos.org/channels/nixpkgs-unstable nixpkgs</code></pre><p>This fetches the channel labeled <code>nixpkgs-unstable</code> from nixos.org, then installs it to your user profile.</p><p>To browse the list of channels, go <a href='https://nixos.org/channels/'>here</a>.</p><p>Using the example above, to install emem, run the following commands for NixOS and other systems, respectively:</p><pre><code>$ nix-env -iA nixos.emem</code></pre><pre><code>$ nix-env -iA nixpkgs.emem</code></pre><p>To update your channels, run:</p><pre><code>$ nix-channel --update</code></pre><p>Over time, trees in <code>/nix/store/</code> accumulate and there may be paths that are no longer referenced by any package. To clean it up, run:</p><pre><code>$ nix-collect-garbage</code></pre><h3><a name="nixpkgsother"></a> Other commands</h3><p>To uninstall a package, run:</p><pre><code>$ nix-env -e emem</code></pre><p>To list all your installed packages, run:</p><pre><code>$ nix-env -q --installed</code></pre><p>To list all available packages, run:</p><pre><code>$ nix-env -q --available</code></pre><p>If you know the binary name of a program, and you want to know which package does it belong to, run:</p><pre><code>$ command-not-found emem</code></pre><h3><a name="nixpkgsconfiguration"></a> Configuration</h3><p>The file <code>&#126;/.nixpkgs/config.nix</code> is a Nix expression, which is read by the Nix commands. In it, we’re able to specify package overrides—configuration that supplants default settings, and other knobs including, but not limited to, browser plugins, GUI configurations, SSL, etc.</p><p>Let’s take a look at a trimmed-down version of my <code>config.nix</code>:</p><pre><code>{ pkgs }:

{
  packageOverrides = pkgs: {
    emacs = pkgs.emacs.override {
      withGTK2 = false;
      withGTK3 = false;
      withXwidgets = false;
    };
  };

  firefox = {
    jre = true;
    enableGoogleTalkPlugin = true;
  };

  allowUnfree = true;
}
</code></pre><p>This is a function, that takes an attribute as parameter, then yields another attribute set as return value. My <i>config.nix</i> says that I don’t want GTK for Emacs. For Firefox, I specified that I want to use the JRE and the Google Talk plugin. Lastly, I am specifying that I want to be able to install software which doesn’t have open source licenses, or software that doesn’t follow the free software model.</p><h3><a name="nixpkgscontribute"></a> Contributing</h3><p>The collaboration model of Nixpkgs rests with git and GitHub. To contribute a package or update an existing one, fork the <a href='https://github.com/nixos/nixpkgs/'>Nixpkgs</a> repository into your own GitHub account, make changes into a new branch, then create a pull request.</p><h4><a name="nixpkgsupdateexisting"></a> Updating existing package</h4><p>After you have forked the repository, clone your version of the repository.</p><pre><code>$ git clone git@github.com:ogag/nixpkgs.git &#126;/nixpkgs</code></pre><p>This will create a copy of your fork in the root of your home directory. Head over to that directory, then let’s examine its contents:</p><pre><code class="bash">$ cd &#126;/nixpkgs
$ tree -aFL 1
.
├── COPYING
├── default.nix
├── doc/
├── .editorconfig
├── .git/
├── .github/
├── .gitignore
├── lib/
├── maintainers/
├── .mention-bot
├── nixos/
├── pkgs/
├── README.md
├── .travis.yml
├── .version
└── .version-suffix

7 directories, 9 files
</code></pre><p>Next, let’s find where the package lives, for example Hello.</p><pre><code>$ grep hello pkgs/top-level/all-packages.nix
  hello = callPackage ../applications/misc/hello { };</code></pre><p>It says here that the package Hello is available under <code>../applications/misc/hello</code>. Relative to the file <code>all-packages.nix</code>, the path is at <code>pkgs/applications/misc/hello</code> or <code>&#126;/nixpkgs/pkgs/applications/misc/hello</code>. Let’s go there:</p><pre><code>$ cd pkgs/applications/misc/hello
$ ls
default.nix</code></pre><p>Open the file <code>default.nix</code>:</p><pre><code class="nix">{ stdenv, fetchurl }:

stdenv.mkDerivation rec {
  name = &quot;hello-2.10&quot;;

  src = fetchurl {
    url = &quot;mirror://gnu/hello/${name}.tar.gz&quot;;
    sha256 = &quot;0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i&quot;;
  };

  doCheck = true;

  meta = {
    description = &quot;A program that produces a familiar, friendly greeting&quot;;
    longDescription = ''
      GNU Hello is a program that prints &quot;Hello, world!&quot; when you run it.
      It is fully customizable.
    '';
    homepage = http://www.gnu.org/software/hello/manual/;
    license = stdenv.lib.licenses.gpl3Plus;
    maintainers = &#91; stdenv.lib.maintainers.eelco &#93;;
    platforms = stdenv.lib.platforms.all;
  };
}
</code></pre><p>This tells us that <code>default.nix</code>, is a function with a parameter as an attribute with two elements. The function returns the result of calling <code>stdenv.mkDerivation</code> with the input of an attribute value. The value for the <code>name</code> attribute is a string with the format <em>packagename-X.Y.Z</em>, where packagename is the name of the package and X.Y.Z is the version number. The value for the <code>src</code> attribute is the value returned by calling the <code>fetchurl</code> function, with another set attribute argument. The value for the <code>url</code> attribute should either be a mirror specification, as described in <code>pkgs/build-support/fetchurl/mirrors.nix</code>, or a standard URL. In this instance, we used the GNU mirror and we interpolated the <code>name</code> variable inside that string. The value of the <code>sha256</code> attribute is the one we get by running <code>nix-prefetch-url</code> against the URL. To get the checksum for <code>hello-2.10</code>, run:</p><pre><code class="bash">$ nix-prefetch-url http://ftpmirror.gnu.org/hello/hello-2.10.tar.gz
downloading ‘http://ftpmirror.gnu.org/hello/hello-2.10.tar.gz’... &#91;622/709 KiB, 64.6 KiB/s&#93;
path is ‘/nix/store/3x7dwzq014bblazs7kq20p9hyzz0qh8g-hello-2.10.tar.gz’
0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i
</code></pre><p>It matched the SHA256 specification above.</p><p>The <code>doCheck</code> attribute instructs Nix to run the tests for this package.</p><p>The value for the <code>meta</code> attribute is another attribute set specification for other details regarding the package. The values specified here will help Nix programs classify the package, among other things. The <code>description</code> attribute is a short string describing the purpose of the package. The <code>longDescription</code> attribute is a longer, possibly multi-line string describe the package in more details. The <code>homepage</code> attribute is a URL to the WWW home of the package. You don’t need to quote it with single or double quotes explicitly—it does that internally. You still have to quote a URL if you use variable interpolation. The <code>maintainers</code> attribute is a list of the people handling that package. The <code>platforms</code> attribute is important; it categorizes a package properly—we don’t want to build a package on macOS that only runs on GNU/Linux.</p><p>If a newer version of Hello comes out, say version 2.11, modify the appropriate attributes. But first, let’s create a separate branch for it:</p><pre><code>$ git checkout -b hello-2.11</code></pre><p>In <code>default.nix</code>, change the name to <code>hello-2.11</code> and update the <code>sha256</code> attribute, too. Additionally, if you’re on NixOS, add the following values to <code>/etc/nixos/configuration.nix</code>:</p><pre><code>nix.useSandbox = true;</code></pre><p>If you’re using another GNU/Linux system, or macOS, add the following to <code>/etc/nix/nix.conf</code>:</p><pre><code>build-use-sandbox = relaxed</code></pre><p>Next, build the package:</p><pre><code>$ cd &#126;/nixpkgs
$ nix-build -A hello</code></pre><p>If the build went successful, a symlink named <code>result</code>, in the current directory will be created. This symlink points to a path in <code>/nix/store/</code>. Let’s run the program:</p><pre><code>$ ./result/bin/hello
Hello, world!</code></pre><p>Good. Commit the changes.</p><pre><code>$ git add -u
$ git commit -m 'hello: 2.10 -&gt; 2.11'
$ git push origin hello-2.11</code></pre><p>Finally, go to the GitHub repo <a href='https://github.com/nixos/nixpkgs'>page</a>, then create a pull request (PR) between <code>nixos/nixpkgs:master</code> and <code>ogag/nixpkgs:hello-2.11</code>.</p><h4><a name="nixpkgssubmitnew"></a> Submitting a new package</h4><p>The steps for submitting a new package is pretty much the same as with updating an existing one, except for a few things.</p><p>At the start, create a new branch for your package:</p><pre><code>$ cd &#126;/nixpkgs
$ git checkout -b tthsum-1.3.2</code></pre><p>Then, decide what category should it belong to:</p><pre><code>$ cd pkgs/applications/misc
$ mkdir tthsum</code></pre><p>Create the <code>default.nix</code> file:</p><pre><code class="nix">{ stdenv, fetchurl }:

stdenv.mkDerivation rec {
  name = &quot;tthsum-${version}&quot;;
  version = &quot;1.3.2&quot;;

  src = fetchurl {
    url = &quot;http://tthsum.devs.nu/pkg/tthsum-${version}.tar.bz2&quot;;
    sha256 = &quot;0z6jq8lbg9rasv98kxfs56936dgpgzsg3yc9k52878qfw1l2bp59&quot;;
  };

  installPhase = ''
    mkdir -p $out/bin $out/share/man/man1
    cp share/tthsum.1.gz $out/share/man/man1
    cp obj-unix/tthsum $out/bin
  '';

  meta = with stdenv.lib; {
    description = &quot;An md5sum-alike program that works with Tiger/THEX hashes&quot;;
    longDescription = ''
      tthsum generates or checks TTH checksums &#40;root of the THEX hash
      tree&#41;. The Merkle Hash Tree, invented by Ralph Merkle, is a hash
      construct that exhibits desirable properties for verifying the
      integrity of files and file subranges in an incremental or
      out-of-order fashion. tthsum uses the Tiger hash algorithm for
      both the internal and the leaf nodes.
    '';
    homepage = http://tthsum.devs.nu/;
    license = licenses.gpl3Plus;
    maintainers = &#91; maintainers.ebzzry &#93;;
    platforms = platforms.unix;
  };
}
</code></pre><p>What’s new here is the <code>installPhase</code> attribute. The default build procedures of the tthsum package is different from the way Nix handles installations, so we have to be explicit about it. The <code>$out</code> identifier refers to the final directory where the program will reside in <code>/nix/store/</code>. In the user environment, the program will be available as <code>&#126;/.nix-profile/bin/tthsum</code>, and for the system environment, it will be available as <code>/run/current-system/sw/bin/tthsum</code>.</p><p>At this point, Nix is still not aware of tthsum. We have to declare it at the top level. To do so, edit the file <code>pkgs/top-level/all-packages.nix</code>, and add the following in the correct category:</p><pre><code class="nix">tthsum = callPackage ../applications/misc/tthsum { };
</code></pre><p>Next, build the package as described above:</p><pre><code>$ cd &#126;/nixpkgs
$ nix-build -A tthsum</code></pre><p>If everything goes well, commit the changes:</p><pre><code>$ git add pkgs/applications/misc/tthsum
$ git add pkgs/top-level/all-packages.nix
$ git commit -m &quot;tthsum: init at 1.3.2&quot;
$ git push origin tthsum-1.3.2</code></pre><p>Finally, go to the GitHub repo <a href='https://github.com/nixos/nixpkgs'>page</a>, then create a pull request (PR) between <code>nixos/nixpkgs:master</code> and <code>ogag/nixpkgs:tthsum-1.3.2</code>.</p><h3><a name="nixpkgsnotes"></a> Notes</h3><p>If at any point during the installation of a package, the process is interrupted, the package being installed will not be in a half-baked state. The very last step of installing a package is atomic. The secret to it is that it the operation that makes it available to a user creates a symlink from <code>/nix/store</code>, where the actual program data is, to your profile, which is located at <code>&#126;/.nix-profile/</code>. Symbolic link creation in GNU/Linux and macOS are either successful or not.</p><p>On NixOS, the channel used by the root user is important because it is the one used when rebuilding the system with <code>nixos-rebuild switch</code> after changes to <code>/etc/nixos/configuration.nix</code> are made. To make sure that you using the right channel, list it with:</p><pre><code>$ sudo nix-channel --list</code></pre><p>To change the root channel similar to the one used above:</p><pre><code>$ sudo nix-channel --add https://nixos.org/channels/nixos-unstable nixos</code></pre><h2><a name="environments"></a> Environments</h2><p>An environment is a way of Nix of providing component isolation between system and users. In NixOS, there are three environments: system environment, user environment, and development environment.</p><h3><a name="systemenvironment"></a> System environment</h3><p>The system environment is modified only by the root user who declares its value in <code>/etc/nixos/configuration.nix</code>. It is a list which contains the packages that will be made available to all users of the system. An excerpt of <code>/etc/nixos/configuration.nix</code> that uses the system environment is:</p><pre><code class="nix">{ config, lib, pkgs, ... }:

{
  ...
  environment.systemPackages = with pkgs; &#91; zsh vim &#93;;
  ...
}
</code></pre><p>This declares that the packages named <em>zsh</em> and <em>vim</em> will be available for all users of the system. The binaries will be available as <code>/run/current-system/sw/bin/zsh</code> and <code>/run/current-system/sw/bin/vim</code>, for Zsh and Vim, respectively.</p><h3><a name="userenvironment"></a> User environment</h3><p>The user environment is the one that is used whenever the command <code>nix-env</code> is used. For example, when installing Zsh using nix-env:</p><pre><code>$ nix-env -iA nixos.zsh</code></pre><p>Zsh only becomes explicitly available for the user invoking it. If <code>john</code> is the username who ran that command, then the Zsh binary will be available as <code>/home/john/.nix-profile/bin/zsh</code>. If the user <code>mary</code> hasn’t installed Zsh to her profile, then it is unavailable to her. If Mary has the same channel as John, and she runs the same nix-env command, then Nix will no longer need to fetch the Zsh program data, from scratch. Instead, Nix makes the Zsh program data, created by the nix-env process that John used earlier, to make Zsh available to Mary. However, if Mary uses the git checkout, or a different version of channels than the one used by John, and the versions of Zsh differ from the version of John, then the invocation of <code>nix-env</code> by Mary will fetch a newer instance of Zsh.</p><h3><a name="developmentenvironment"></a> Development environment</h3><p>The third environment, development environments, are created with the use of <em>nix-shell</em>. <code>nix-shell</code> allows the user to create sandboxed environments. The environment created is isolated from the system and regular user environments. The environment created will still use <code>/nix/store</code>, but neither <code>/run/current-system/sw/</code> nor <code>&#126;/.nix-profile/</code> will be modified. What <em>nix-shell</em> provides is an environment that is separated from the rest of the system, allowing the user to create ad-hoc deployments, without worries of altering system state. With this, a user gains the ability, for example, to use an environment to test out different deployments of an application, or to compare features prior to delivery.</p><p>On macOS, the system environment is not used.</p><p>To create environments that are disjunct from the rest of the system, we need to have a way to separate the dependencies of an application and its data itself, from normal system intervention. The <code>nix-shell</code> allows us to create thin layers of abstraction while still taking advantage of the determinism and resource management of Nix itself.</p><p>To illustrate, let’s check that we don’t have <a href='https://www.gnu.org/software/hello/'>GNU Hello</a> installed, yet:</p><pre><code>$ which hello
hello not found</code></pre><p>If that is the case, good. Otherwise, remove the Hello package first.</p><p>Now, to demonstrate <code>nix-shell</code>, let’s run GNU Hello in the nix-shell, then it will return back to the user shell:</p><pre><code>$ nix-shell --packages hello --pure --run hello
Hello, world!
$ which hello
hello not found</code></pre><p>What this does is that fetches the binary package for Hello, creates an clean shell environment, then proceeds to run the <code>hello</code> binary, which will display to the screen the familiar greeting. If the run option was omitted, we will be dropped in a shell:</p><pre><code>$ nix-shell --packages hello --pure
&#91;nix-shell:&#126;&#93;$ hello
Hello, world!</code></pre><p>This shell instance is special because it only contains sufficient information just to make Hello, available. We can even inspect the value of <code>$PATH</code>, here:</p><pre><code class="bash">&#91;nix-shell:&#126;&#93;$ echo $PATH | tr ':' '\n'
/nix/store/kc912zn1ry1xilcm901ip7p8s1iqv0f1-hello-2.10/bin
/nix/store/f9q8k36x9jpi8jmdpwifcywzywpxvhrs-patchelf-0.9/bin
/nix/store/xx2bclrflkcvrddvp6bd3wsasqs7vsp1-paxctl-0.9/bin
/nix/store/4d6f8hg5gv20nsbq7b52qzn6bcs4fvlh-coreutils-8.26/bin
/nix/store/f3vl26f3n18khgq1kybnzvwjbm0r9grg-findutils-4.6.0/bin
/nix/store/mvnjpifk06yjffrsd50rpr3jjfrjsqiv-diffutils-3.5/bin
/nix/store/0xwrn1p8fp8h3cynszpgbmhmydbzhns5-gnused-4.4/bin
/nix/store/avmxym1w34sc17nrilsmgrk469l3ml0z-gnugrep-3.0/bin
/nix/store/2vh4wllg66rw61ffdfwp1xm4r2yns44j-gawk-4.1.3/bin
/nix/store/rhjsykhxrzj3ca8da6b4g6v1yx53xpi3-gnutar-1.29/bin
/nix/store/w1vlvxlavmz39by5xpnhva36q2lbi9hf-gzip-1.8/bin
/nix/store/mgvqw07ssjhf1hb96md97rjkfsrmfmp6-bzip2-1.0.6.0.1-bin/bin
/nix/store/69y0laqzizjycwaqivbsp273n0ag3ayi-gnumake-4.2.1/bin
/nix/store/86blj9iqyxwmdgkn3dyrpib1gkbmz91v-bash-4.4-p5/bin
/nix/store/qjklkl51d6qp98n8nncvbv62p01pp6qf-patch-2.7.5/bin
/nix/store/8pcap19p6qwf06ra4iaja3n6k6p2jzwg-xz-5.2.2-bin/bin
</code></pre><p>Your output is going to be different from mine because of the hashes in the store paths. Aside from the store path of Hello, the rest are the minimal components of a nix-shell instance. This cluster is called the <em>stdenv</em>.</p><p>nix-shell looks for the files <code>shell.nix</code> or <code>default.nix</code>, in that order, in the current directory during startup, to load definitions from. Let’s create one, saving it as <code>default.nix</code>:</p><pre><code class="nix">{ pkgs ? import &lt;nixpkgs&gt; {} }:

with pkgs;
stdenv.mkDerivation {
  name = &quot;shell&quot;;
  buildInputs = &#91; hello emem &#93;;
}
</code></pre><p>A <em>.nix</em> file is a Nix expression. In this example, it’s a function that takes one argument, with a default value. The odd-looking <code>&lt;nixpkgs&gt;</code> refers to the value of the <code>nixpkgs</code> attribute declared in the <code>NIX&#95;PATH</code> environment variable. On NixOS, it looks like this:</p><pre><code>$ echo $NIX&#95;PATH
nixpkgs=/nix/var/nix/profiles/per-user/root/channels/nixos/nixpkgs:nixos-config=/etc/nixos/configuration.nix:/nix/var/nix/profiles/per-user/root/channels</code></pre><p>In the directory being pointed by the nixpkgs attribute, there’s a <code>.git-revision</code> file. Let’s view its contents:</p><pre><code>$ cat /nix/var/nix/profiles/per-user/root/channels/nixos/nixpkgs/.git-revision
1e8c01784a6a121fc94d111f4af7cc88dd932186</code></pre><p>This tells us the version of Nixpkgs using channels on this profile.</p><p>Going back, the <code>with pkgs</code> declaration puts all the identifiers in the local scope, making them visible. <code>stdenv</code>, which was mentioned earlier, is an attribute set which, among many things, contain the <code>mkDerivation</code> identifier. <code>mkDerivation</code>, in turn, is a function that accepts one attribute set argument. Let me remind you, that the curly braces after <code>mkDerivation</code> specify a single unit of argument, which is the attribute set; it has no semantic resemblance to the curly braces found in other languages to delimit the start and end of a function scope. There are many knobs to it, but for the purposes of simplicity, we’ll only look at <code>name</code> and <code>buildInputs</code>—the bare attribute parameters.</p><p>For our trivial example, the value of <code>name</code> can be anything. The value of <code>buildInputs</code>, however, is important. Here, they’re declared to be <code>hello</code> and <code>emem</code>. These are references to values inside the <code>nixpkgs</code> marker that we saw earlier. Had we not used <code>with pkgs</code>, the expression would be:</p><pre><code class="nix">{ pkgs ? import &lt;nixpkgs&gt; {} }:

pkgs.stdenv.mkDerivation {
  name = &quot;shell&quot;;
  buildInputs = &#91; pkgs.hello pkgs.emem &#93;;
</code></pre><p>To feed this expression to nix-shell, making use of both <em>hello</em> and <em>emem</em>, run:</p><pre><code>$ nix-shell --pure --run &quot;hello | emem -w&quot;
&lt;p&gt;Hello, world!&lt;/p&gt;</code></pre><p>nix-shell gives us strong abstraction mechanisms that are deemed very difficult to do in other approaches. It banks on the deterministic properties of Nix, creating a very strong leverage.</p><h2><a name="closing"></a> Closing remarks</h2><p>Nix provides powerful tools to make managing systems and development configurations, significantly easier. It has flexible facilities for creating efficient workflows and distribution models. If I had to list down the most important features of the Nix ecosystem that I like, they are:</p><ul><li>deterministic</li><li>reproducible</li><li>stateless</li><li>declarative</li><li>consistent</li><li>portable</li><li>reliable</li><li>purely functional</li><li>has transactional updates</li></ul><p>Another important member of the Nix family is <a href='https://nixos.org/nixops'>NixOps</a>; it enables one to deploy NixOS on bare metal machines, virtual machines, or cloud using the declarative approach that we are familiar with. It is able to deploy to VirtualBox, Amazon EC2, Google Compute Engine, Microsoft Azure, Hetzner, Digital Ocean, and Libvirtd. Head over to the <a href='https://nixos.org/nixops/manual/'>manual</a> for more details.</p><p>In-depth details about instantiations, derivations, realisations were elided on purpose, in this article. They may become a topic on their own, or I may update this article to add those topics. I may also write a new section about NixOps.</p><p>An Emacs major mode is <a href='https://github.com/NixOS/nix/blob/master/misc/emacs/nix-mode.el'>available</a> from the main repository. It is also <a href='https://melpa.org/#/nix-mode'>available</a> via MELPA. You may install it with:</p><pre><code>M-x package-install RET nix-mode RET
</code></pre><p>There are other package management systems that are trying to solve this problem domain, too. The ones that I’m aware of are <a href='http://appimage.org/'>AppImage</a>, <a href='http://0install.net/'>Zero Install</a>, <a href='https://snapcraft.io/'>Snapcraft</a>, and <a href='http://flatpak.org/'>Flatpak</a>.</p><p>The <a href='https://www.gnu.org/software/guix/'>Guix System Distribution (GuixSD)</a> is a GNU/Linux distribution that is based on Nix. It uses Guile Scheme as its API language. The key differences between GuixSD and NixOS is that the former uses <a href='https://www.gnu.org/software/shepherd/'>GNU Shepherd</a> instead of systemd; it doesn’t allow non-free packages; and it uses <a href='https://www.fsfla.org/ikiwiki/selibre/linux-libre/'>Linux-libre</a>, a stripped down version of the mainstream kernel with all the proprietary blobs removed. More information about their differences can be found <a href='https://sandervanderburg.blogspot.de/2012/11/on-nix-and-gnu-guix.html'>here</a>.</p><p>Aside from GuixSD, there are also other projects that Nix has inspired. There is <a href='https://habitat.sh'>Habitat</a> an application automation framework, and <a href='https://github.com/alexanderGugel/ied'>ied</a>, an alternative package manager for Node.</p><p>The articles of <a href='https://lethalman.blogspot.com/2014/07/nix-pill-1-why-you-should-give-it-try.html'>Luca Bruno</a>, <a href='https://lethalman.blogspot.com/2014/07/nix-pill-1-why-you-should-give-it-try.html'>James Fisher</a>, and <a href='https://ocharles.org.uk/blog/posts/2014-02-04-how-i-develop-with-nixos.html'>Oliver Charles</a>, together with the <a href='https://nixos.org/nixos/manual'>NixOS</a>, <a href='https://nixos.org/nixpkgs/manual'>Nixpkgs</a>, and <a href='https://nixos.org/nix/manual'>Nix</a> manuals, significantly helped me in understanding Nix. Special thanks goes to <a href='https://fare.livejournal.com'>François-René Rideau</a> for introducing me to Nix several years ago.</p><p>The NixOS Foundation is a registered non-profit organization; your <a href='https://nixos.org/nixos/foundation.html'>donations</a> will significantly help in the development of Nix. Join the <a href='https://nixos.org/nixos/community.html'>community</a> and help make it grow!</p><h2><a name="bonus"></a> Bonus</h2><p>Here’s the <a href='/en/y'>Y combinator</a> in Nix, applied to the factorial function:</p><pre><code class="nix">nix-repl&gt; y = x: &#40;&#40;f: &#40;x &#40;v: &#40;&#40;f f&#41; v&#41;&#41;&#41;&#41; &#40;f: &#40;x &#40;v: &#40;&#40;f f&#41; v&#41;&#41;&#41;&#41;&#41;

nix-repl&gt; b = p: &#40;n: if n == 0 then 1 else &#40;n &#42; &#40;p &#40;n - 1&#41;&#41;&#41;&#41;

nix-repl&gt; f = y b

nix-repl&gt; f 20
2432902008176640000
</code></pre><p>Or, in one expression, using let:</p><pre><code class="nix">nix-repl&gt; let y = x: &#40;&#40;f: &#40;x &#40;v: &#40;&#40;f f&#41; v&#41;&#41;&#41;&#41; &#40;f: &#40;x &#40;v: &#40;&#40;f f&#41; v&#41;&#41;&#41;&#41;&#41;;
              b = p: &#40;n: if n == 0 then 1 else &#40;n &#42; &#40;p &#40;n - 1&#41;&#41;&#41;&#41;;
              f = y b;
          in f 20
2432902008176640000
</code></pre><p>You may also pipe stdout to nix-repl:</p><pre><code class="nix">$ echo 'let y = x: &#40;&#40;f: &#40;x &#40;v: &#40;&#40;f f&#41; v&#41;&#41;&#41;&#41; &#40;f: &#40;x &#40;v: &#40;&#40;f f&#41; v&#41;&#41;&#41;&#41;&#41;; b = p: &#40;n: if n == 0 then 1 else &#40;n &#42; &#40;p &#40;n - 1&#41;&#41;&#41;&#41;; f = y b; in f 20' | nix-repl
Welcome to Nix version 1.11.8. Type :? for help.

nix-repl&gt; let y = x: &#40;&#40;f: &#40;x &#40;v: &#40;&#40;f f&#41; v&#41;&#41;&#41;&#41; &#40;f: &#40;x &#40;v: &#40;&#40;f f&#41; v&#41;&#41;&#41;&#41;&#41;; b = p: &#40;n: if n == 0 then 1 else &#40;n &#42; &#40;p &#40;n - 1&#41;&#41;&#41;&#41;; f = y b; in f 20
2432902008176640000

nix-repl&gt;
</code></pre><hr/><div class="footer"><p><div class="text-small"> <a href='/en'>Home</a>  <a href='/en/about'>About</a>  <a href='/en/quotes'>Quotes</a>  <a href='/en/words'>Words</a>  <a href='https://github.com/ebzzry/ebzzry.github.io'>Source</a> </div> <div class="text-x-small"> Site created with <a href='https://github.com/ebzzry/emem'>emem</a> </div></p><p><div class="text-x-small"> <a rel="license" href="https://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" class="cc" src="/images/cc4-88x31.png" /></a><br> This work by <a xmlns:cc="https://creativecommons.org/ns#" href="https://ebzzry.io" property="cc:attributionName" rel="cc:attributionURL">Rommel Martinez</a> is licensed under a<br> <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>. </div></p><p></div></p></div><script src="/static/js/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create', 'UA-93746003-1', 'auto');ga('send', 'pageview');</script></body></html>