<!DOCTYPE html>
<html lang="eo"><head><title>Milda Enkonduko al Nix-Flokoj</title><meta charset="utf-8" /><meta content="width=device-width,initial-scale=1.0,user-scalable=yes" name="viewport" /><meta content="noodp,noydir" name="robots" /><link rel='apple-touch-icon' sizes='180x180' href='/images/ico/apple-touch-icon.png'><link rel='icon' type='image/png' sizes='32x32' href='/images/ico/favicon-32x32.png'><link rel='icon' type='image/png' sizes='16x16' href='/images/ico/favicon-16x16.png'><link rel='manifest' href='/images/ico/site.webmanifest'><link rel='mask-icon' href='/images/ico/safari-pinned-tab.svg' color='#5bbad5'><link rel='shortcut icon' href='/images/ico/favicon.ico'> <meta name='msapplication-TileColor' content='#da532c'> <meta name='msapplication-config' content='/images/ico/browserconfig.xml'> <meta name='theme-color' content='#ffffff'><meta content="Milda Enkonduko al Nix-Flokoj" name="description" /><meta content="nix, nix flakes, nix-flokoj, darwin, nixos, linux, linukso" name="keywords" /><meta content="Milda Enkonduko al Nix-Flokoj" property="og:title" /><meta content="article" property="og:type" /><meta content="https://ebzzry.com/eo/flokoj/" property="og:url" /><meta content="https://ebzzry.com/images/ico/android-chrome-512x512.png" property="og:image" /><style media="all" type="text/css">html {    color: #333;    font-size: 1em;    font-family: Georgia, Cambria, Palatino, "Palatino Linotype", "Times New Roman", Times, serif;    line-height: 1.45;    text-align: left:    width: 100%;    max-width: 40em;    margin: 0 auto 0 auto;    padding: 0;}body {    border-top: hidden;    border-bottom: hidden;    padding: 0 1.5em 1em 1.5em;    margin: 0;}#content {    -webkit-column-count: 1;    -moz-column-count: 1;    column-count: 1;}code {    font-size: 0.9em;    font-family: "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Lucida Console", "Courier New", Courier, monospace;    color: black;    display: inline-block;}pre code {    font-size: 1em;    font-family: monospace;    line-height: 1.3em;    overflow: auto;    font-weight: normal;}kbd {    font-size: 1.1em;    padding: 0.1em 0.6em;    border: 1px solid #ccc;    font-family: monospace;    background-color: #f7f7f7;    color: #333;    -moz-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    -webkit-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    -moz-border-radius: 3px;    -webkit-border-radius: 3px;    border-radius: 3px;    display: inline-block;    margin: 0 0.1em;    text-shadow: 0 1px 0 #fff;    white-space: nowrap;}h1, h2, h3, h4, h5, h6 {    font-family: Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans", Tahoma, Geneva, Helvetica, Arial, sans-serif;    margin-bottom: 0;}h1 {    font-size: 2.5em;    text-align: center;    border-bottom: 6px solid black;}h2 {    font-size: 2.0em;    text-align: left;    border-bottom: 2px solid black;}h3 {    font-size: 1.6em;    text-align: left;    border-bottom: 1px solid lightgrey;}h4 {    font-size: 1.5em;    text-align: left;}h5 {    font-size: 1.3em;    text-align: left;}ul, ol {    padding-left: 2em;}ul li {    list-style-type: square;}ul li li {    list-style-type: disc;}ul li li li {    list-style-type: circle;}ol li {    list-style-type: decimal;}p, para, b, strong, i, em, emph {    font-size: 1em;}blockquote {    font-size: 1.2em;    font-style: italic;    margin-left: 2em;}b, strong {    font-weight: bold;}i, em, emph {    font-style: italic;}table {    margin: 0.5em;    border-spacing: 0;    border-collapse: collapse;}th, td {    border: 1px solid lightgray;    padding-top: 0;    padding-bottom: 0;    padding-left: 0.45em;    padding-right: 0.45em;}.text-right {    text-align: right;}.text-small {    font-size: small;}.text-x-small {    font-size: x-small;}.banner {    display: block;    width: 100%;    margin-left: auto;    margin-right: auto;}.footer {    text-align: right;    float: right;    max-width: 18em;}.cc {    border-width: 0}.center {    text-align: center;}</style><style media="all" type="text/css">/* Ewan Themes -- based 99.99% from Tomorrow Night Theme *//* http://jmblog.github.com/color-themes-for-google-code-highlightjs *//* Original theme - https://github.com/chriskempson/tomorrow-theme *//* http://jmblog.github.com/color-themes-for-google-code-highlightjs *//* Tomorrow Comment */.hljs-comment {  color: #969896;}/* Tomorrow Red */.hljs-variable,.hljs-attribute,.hljs-tag,.hljs-regexp,.ruby .hljs-constant,.xml .hljs-tag .hljs-title,.xml .hljs-pi,.xml .hljs-doctype,.html .hljs-doctype,.css .hljs-id,.css .hljs-class,.css .hljs-pseudo {  color: #cc6666;}/* Tomorrow Orange */.hljs-number,.hljs-preprocessor,.hljs-pragma,.hljs-built_in,.hljs-literal,.hljs-params,.hljs-constant {  color: #de935f;}/* Tomorrow Yellow */.ruby .hljs-class .hljs-title,.css .hljs-rule .hljs-attribute {  color: #f0c674;}/* Tomorrow Green */.hljs-string,.hljs-value,.hljs-inheritance,.hljs-header,.hljs-name,.ruby .hljs-symbol,.xml .hljs-cdata {  color: #b5bd68;}/* Tomorrow Aqua */.hljs-title,.css .hljs-hexcolor {  color: #8abeb7;}/* Tomorrow Blue */.hljs-function,.python .hljs-decorator,.python .hljs-title,.ruby .hljs-function .hljs-title,.ruby .hljs-title .hljs-keyword,.perl .hljs-sub,.javascript .hljs-title,.coffeescript .hljs-title {  color: #81a2be;}/* Tomorrow Purple */.hljs-keyword,.javascript .hljs-function {  color: #b294bb;}.hljs {  display: block;  overflow-x: auto;  background: #1d1f21;  color: #c5c8c6;  padding: 0.5em;  -webkit-text-size-adjust: none;}.coffeescript .javascript,.javascript .xml,.tex .hljs-formula,.xml .javascript,.xml .vbscript,.xml .css,.xml .hljs-cdata {  opacity: 0.5;}pre code {    font-size: 1.1em;    font-family: monospace;    line-height: 1.3em;    overflow: auto;}</style></head><body><div id="content"><h1>Milda Enkonduko al Nix-Flokoj</h1><p><div class="center"><a href='/en/flakes'>English</a> • Esperanto</div></p><blockquote><p>Tamen ĉiu decido por io estas decido kontraŭ io alia.<br> —H. G. Tannhaus, Dark (2017) </p></blockquote><p><img src="/images/site/aaron-burden-vtCZp-9GvrQ-unsplash-1008x250.webp" style="display: block; width: 100%; margin-left: auto; margin-right: auto;" alt="adv360" title="adv360"/></p><h2><a name="toc">Table of contents</a></h2><ul><li><a href='#enkonduko'>Enkonduko</a><ul><li><a href='#nixos'>NixOS</a></li><li><a href='#darwin'>Darwin</a></li></ul></li><li><a href='#flokoj'>Flokoj</a><ul><li><a href='#packages'>packages</a></li><li><a href='#devshells'>devShells</a></li><li><a href='#apps'>apps</a></li><li><a href='#nixosconfiguration'>nixosConfiguration</a></li><li><a href='#darwinconfiguration'>darwinConfiguration</a></li><li><a href='#flake-utils'>flake-utils</a></li></ul></li><li><a href='#finrimarkoj'>Finrimarkoj</a></li></ul><h2><a name="enkonduko">Enkonduko</a></h2><p>Kiam mi malkovris je Nix preskaŭ du jardekoj antaŭe, mi lernis, ke estas ankoraŭ multaj aferoj kiujn mi ne scias. Mi estis forblovita. Mi miris. Ĝi estis mirinda. Mia ardo por sistemadministrado reardiĝis.</p><p>Kiel iu kiu elspezis multan tempon en la BSD-lando—agordante ĉion mane, memorante ĉiom da lokoj kiu grava agordo loĝis—mi opiniis, ke Nix kaj NixOS estas spiro de freŝa aero.</p><p>Post ne longe, NixOS fariĝis mia ĉefa labora maŝino. Mi povis fari ĉion per ĝi, eĉ uzi aparatojn kiuj ne estis antaŭdesignita por funkcii sur linukso. Per la helpo de la oficiala dokumentoj kaj helpemaj artikoloj de homoj kiuj jam uzis ĝin antaŭ mi, mi povis agordi ĝin laŭ miaj preferoj. Mi skribis pri tio sperto <a href='/eo/nix'>ĉi tie</a>.</p><h3><a name="nixos">NixOS</a></h3><p>La maniero en kiu mi ĉiam uzis mian NixOS-sistemon estas, ke mi instalu pakojn per <code>nix-env</code>. Bedaŭrinde, tutegale kiom mi optimumigis la procedon, ĝi estis ankoraŭ malrapida kaj laborintensiva. Mi malkovris, ke la sistemo ŝargis aĵojn pli ol necesitaj, severe influi la rendimenton.</p><p>Mi pli fosis kaj malkovris la Nix-flokojn. Estis menciite ĉe la <a href='https://wiki.nixos.org/wiki/Flakes'>vikio</a>, ke ĝi estas eksperimenta kapablo. Mi fakte ne scias kion tio signifas, sed ĝi sentis kiel alfaa kapablo kiu estas jam preta.</p><p>Por ebligi ĝin, mi redaktis la dosieron <code>/etc/nixos/configuration.nix</code> kaj aldonis la jenan:</p><pre><code class="conf">nix.settings.experimental-features = &#91; &quot;nix-command&quot; &quot;flakes&quot; &#93;;
</code></pre><p>kaj faris la jenan</p><pre><code class="sh">sudo nixos-rebuild switch
</code></pre><p>Mi akiris novan aron de kamondoj el la <code>nix</code>-komando, kaj malkovris ke ili estas malbagatelaj foriroj el la komandoj kiuj mi jam konis.</p><p>Por instali pakon, ekzemple emem—sen flokoj kaj por malinstali ĝin, ruli</p><pre><code class="sh">nix-env --install -A nixpkgs.emem
nix-env --uninstall emem
</code></pre><p>Per flokoj—por instali kaj malinstali ĝin—ruli</p><pre><code class="sh">nix profile install nixpkgs#emem
nix profile remove emem
</code></pre><h3><a name="darwin">Darwin</a></h3><p>Kiam mi akiris M1 Macbook Pro-tekkomputilon, mi nature sciemis ĉu estas maniero por mi por instali je Nix sur ĝi. Post ne longe, mi malkovris <a href='https://github.com/LnL7/nix-darwin/'>nix-darwin</a>. Post unu horo de alĝustigetado, mi fine akiris la sorĉelvokon kiu muntus ĉion.</p><pre><code class="sh">darwin-rebuild switch --flake &#126;/.config/nix
</code></pre><p>Same kiel flokoj sur NixOS, mi prenis la novan aron de komandoj.</p><p>Plejmulte da—se ne ĉiom—da gravaj Nix-komandoj jam kunfandiĝis al <code>nix</code>. Mi iris per ĝi senprobleme dum unu jaro. Baldaŭ, mi decidis, ke estas jam la ŝanco por plenplonĝi kaj uzi flokojn ekster la baza agordo.</p><h2><a name="flokoj">Flokoj</a></h2><p>Unu el la aferoj kiuj ja ĉiam ĝenis mi estis la transiro el la malnova reĝimo de uzi <code>shell.nix</code> por krei porteblajn nix-ŝelojn, al <code>flake.nix</code>. Por uzi flokojn, oni devas krei la dosieron <code>flake.nix</code>, kiu estos la bazo por ĉio. La komando <code>nix</code> legas ĉi tiun dosieron el la aktuala dosierujo. La <code>init</code> sub-komando kreas unu, por ni, oportune.</p><pre><code class="sh">nix flake init
</code></pre><p>La rezulto, <code>flake.nix</code>, aspektos kiel la jena:</p><pre><code class="nix">{
  description = &quot;A flake️️&quot;;
  inputs = {
    nixpkgs.url = &quot;github:nixos/nixpkgs?ref=nixpkgs-unstable&quot;;
  };
  outputs = { self, nixpkgs }: {
    packages.x86-64&#95;linux.hello = nixpkgs.legacyPackages.x86-64&#95;linux.hello;
    packages.x86-64&#95;linux.default = self.packages.x86-64&#95;linux.hello;
  };
}
</code></pre><p>Oni povas vidi, tuje, ke ĝi estas atribua aro, de tri parto:</p><pre><code class="nix">{
  description = ...;
  inputs = ...;
  outputs = ...;
}
</code></pre><p>Metu plaĉan valoron en <code>description</code> por ke ni povu uzi ĝin kiel informon kiam «grep» por flokoj. <code>inputs</code> indikas la aferojn kiuj iros al la floko, dum <code>outputs</code> estas tiuj kiuj estos produktita per ĝi, kiam tiam estos uzita de la <code>nix</code>-komandoj. <code>inputs</code> mem estas atribua aro, kaj ni unue difinos la lokon de <code>nixpkgs</code>.</p><pre><code class="nix">inputs = {
  nixpkgs.url = &quot;github:nixos/nixpkgs?ref=nixpkgs-unstable&quot;;
}
</code></pre><p>Jen ni uzas <code>ref</code> por indiki la branĉan nomon. Oni povas havi aliajn indikilojn, kiel enmeta-identigilo, per <code>rev</code>.</p><pre><code class="nix">inputs = {
  nixpkgs.url = &quot;github:nixos/nixpkgs?ref=nixpkgs-unstable&quot;;
  oldnixpkgs.url = &quot;github:nixos/nixpkgs?rev=d73ab2f14214a587059fa38cacf82198409e54eb&quot;;
}
</code></pre><p>La valoro de <code>outputs</code> estas funkcio kiu ricevas atribuan liston kiel argumento kaj revenas atribuan liston enhavante la eligajn specifojn. La formo estas la jena:</p><pre><code class="nix">outputs = { }: { }
</code></pre><p>La eligoj de floko kongruas kun specifaj Nix-komandoj. Kelke da ili kiujn mi uzas estas listigita jene.</p><table><thead><tr><th align='left'>eligo</th><th align='left'>uzita de</th></tr></thead><tbody><tr><td align='left'><code>packages</code></td><td align='left'><code>nix build</code></td></tr><tr><td align='left'><code>devShells</code></td><td align='left'><code>nix develop</code></td></tr><tr><td align='left'><code>apps</code></td><td align='left'><code>nix run</code></td></tr><tr><td align='left'><code>nixosConfigurations</code></td><td align='left'><code>nixos-rebuild &ndash;flake</code></td></tr><tr><td align='left'><code>darwinConfigurations</code></td><td align='left'><code>darwin-rebuild &ndash;flake</code></td></tr></tbody></table><h3><a name="packages">packages</a></h3><p>Ni priparolu la plej bazan tipon de eligo—packages.</p><pre><code class="nix">outputs = { self, nixpkgs }: {
  packages.x86-64&#95;linux.hello = nixpkgs.legacyPackages.x86-64&#95;linux.hello;
  packages.x86-64&#95;linux.default = self.packages.x86-64&#95;linux.hello;
};
</code></pre><p>La argumento de tiu funkcio estas atribua aro, kun du ŝlosilaj: <code>self</code> kaj <code>nixpkgs</code>. <code>self</code>, tie, estas la atribuo mem. Tio ebligas nin por skribi referencojn al la partoj ene. <code>nixpkgs</code> enhavas ĉiom da pakoj por specifa sistemo, kiu, en la ekzemplo supre, estas <code>x86-64&#95;linux</code>.</p><p>En</p><pre><code class="nix">packages.x86-64&#95;linux.hello = nixpkgs.legacyPackages.x86-64&#95;linux.hello;
</code></pre><p>ni kreas eligan pakon kiu nomiĝas <code>packages.x86-64&#95;linux.hello</code>, valorizante ĝin la <code>hello</code>-derivaĵon el Nixpkgs. Ni ankaŭ devas precizigi la arkitekturon, aŭ kiel Nix nomas ĝin, system, ĉar pakoj estas sistemspecifaj. Sekve, ni kreu implicitan eligan pakon kiu estos taksita se iu ajn pako ne estas precizigita. Ni uzas la identigilon <code>self.packages.x86-64&#95;linux.hello</code> por elekti <code>packages.x86-64&#95;linux.hello</code> kiu estas antaŭe difinita en la sama atribua aro.</p><p>Ni restrukturu <code>outputs</code> por igi ĝin pli legeblan:</p><pre><code class="nix">outputs = { nixpkgs }:
 let
   system = &quot;x86-64&#95;linux&quot;;
   pkgs = nixpkgs.legacyPackages.${system};
 in with pkgs; {
   packages.${system} = rec {
     hello = pkgs.hello;
     default = hello;
   };
 };
</code></pre><p>Per flokoj, ĉio devas esti enmetita kun gito. La <code>nix</code>-komando ne funkcios kromse ili estas parto de la deponejo. Ajna <code>.nix</code>-dosiero estas referencita de la flokoj, devas esti parto de la deponejo.</p><pre><code class="sh">git init
git add .
git commit -m 'Initial commit'
</code></pre><p>Por munti la <code>hello</code>-pakon, ruli</p><pre><code class="sh">nix build .#hello
</code></pre><p>La <code>.</code>-signo indikas la aktualan dosierujon ĉe la floka fonto, dum <code>#hello</code> indikas, ke ni muntas la <code>hello</code>-pakon. Se la aktuala dosierujo estas <code>/Users/foo/tmp</code>, la jenaj komandoj estas ekvivalentaj.</p><pre><code class="sh">nix build .#hello
nix build $PWD#hello
nix build /Users/foo/tmp#hello
</code></pre><p>Por munti la implicitan pakon, ni simple forigas <code>#hello</code>.</p><pre><code class="sh">nix build
nix build $PWD
nix build .
nix build /Users/foo/tmp
</code></pre><p>La komando kreas la simbilligilon <code>result</code> en la aktuala dosierujo kiu indikas la muntan eligon en la Nix-konservejo. Por ruli <code>hello</code>,</p><pre><code class="sh">./result/bin/hello
</code></pre><h3><a name="devshells">devshells</a></h3><p>Eble la eligo kiun mi plej ofte uzas estas <code>devShells</code>. Ĝi ebligas min krei «programadajn mediojn» (kio ajn tio signifas) kiu esence enhavas mediojn kiu estas tute izolitaj el mia ĉefa sistemo. Ĝi estas (esence) la flaka versio de tiuj kiuj estas kreitaj per <code>nix-shell</code>.</p><p>Jen simpla ekzemplo</p><pre><code class="nix">devShells.${system} = rec {
  lisp = mkShell { buildInputs = &#91; sbcl &#93;; };
  default = lisp;
};
</code></pre><p>Tio difinas lispan ŝelon per <code>pkgs.mkShell</code> kaj prenas atribuan liston. La plej grava ŝlosilo estas <code>buildInputs</code> kiu estas listo de la pakoj. Ĉi tie, ĝi estas <code>pkgs.sbcl</code>. Kiel la <code>packages</code>-eligo, ni difinas implicitan ŝelon per <code>default</code>.</p><p>Nia <code>flake.nix</code>-dosiero nun aspektas jene</p><pre><code class="nix">{
  description = &quot;A flake️️&quot;;
  inputs = { nixpkgs.url = &quot;github:nixos/nixpkgs?ref=nixpkgs-unstable&quot;; };
  outputs = { nixpkgs, ... }:
    let
      system = &quot;x86-64&#95;linux&quot;;
      pkgs = nixpkgs.legacyPackages.${system};
    in with pkgs; {
      packages.${system} = rec {
        hello = hello;
        default = hello;
      };
      devShells.${system} = rec {
        lisp = mkShell { buildInputs = &#91; sbcl &#93;; };
        default = lisp;
      };
    };
}
</code></pre><p>Por eniri la implicitan ŝelon, kiu estas <code>lisp</code>, ruli</p><pre><code class="sh">nix develop
</code></pre><p>Oni tiam havas aliron al la pakoj kiuj oni ĵus deklaris,</p><pre><code class="sh">sbcl --version
</code></pre><h3><a name="apps">Apps</a></h3><p><code>app</code>-eligo, aliflanke, ebligas onin por oportune plenumi iu ajn programon el pako.</p><p>Ni iru kaj difinu apan eligon kiu lanĉas sisteman kontrolilon.</p><pre><code class="nix">apps.${system} = rec {
  btop = {
    type = &quot;app&quot;;
    program = &quot;${pkgs.btop}/bin/btop&quot;;
  };
  default = btop;
};
</code></pre><p>La atribua tipo devas havi la valoron <code>&quot;app&quot;</code>. La atribuo <code>program</code> enhavas la pakan vojon al la programo kiun oni volas ruli. Por lanĉi ĝin, rulu</p><pre><code class="sh">nix run
</code></pre><h3><a name="nixosconfiguration">nixosConfiguration</a></h3><p>Unu el la plej bonaj aferoj kiun mi malkovris per flakoj estas la kapablo por provizi la administradon de la NixOS-agordo. Oni ne bezonas ŝanĝi ion ajn al la ekzistanta dosiero, <code>/etc/nixos/configuration.nix</code>. Oni nur devas diri al <code>flake.nix</code> kiel regi ĝin.</p><pre><code class="nix">nixosConfigurations.&quot;hostname&quot; = nixos.lib.nixosSystem {
  modules = &#91; ./configuration.nix &#93;;
  specialArgs = { inherit pkgs; };
};
</code></pre><p>La dosiero <code>./configuration.nix</code> ĉi-supre estas kopio de la dosiero <code>/etc/nixos/configuration.nix</code> kiu ankaŭ estos spurita per versikontrolo. Aldonu ĝin al la deponejo</p><pre><code class="sh">git add configuration.nix
</code></pre><p>La ĉeno <code>&quot;hostname&quot;</code> devas esti anstataŭigita per la nomo de la maŝino kiu uzus tiun agordon.</p><pre><code class="nix">{
  inputs = { nixpkgs.url = &quot;github:nixos/nixpkgs/nixos-unstable&quot;; };
  outputs = { nixpkgs, ... }:
    let
      system = &quot;x86-64&#95;linux&quot;;
      pkgs = nixpkgs.legacyPackages.${system};
    in with pkgs; {
      nixosConfigurations = {
        &quot;ebzzry-tpad&quot; = nixpkgs.lib.nixosSystem {
          modules = &#91; ./nixos-configuration.nix &#93;;
          specialArgs = { inherit pkgs; };
        };
      };
    };
}
</code></pre><p>Por remunti la NixOS-agordon por la maŝino <code>ebzzry-tpad</code>, rulu</p><pre><code class="sh">sudo nixos-rebuild switch --flake .#ebzzry-tpad
</code></pre><p>Se nur ekzistas unu agordo, la jena komando sufiĉus,</p><pre><code class="sh">sudo nixos-rebuild switch --flake .
</code></pre><h3><a name="darwinconfiguration">darwinConfiguration</a></h3><p>Per <code>nix-darwin</code>, oni povas fari la saman kiel ĉi-supre,</p><pre><code class="nix">{
  inputs = {
    nixpkgs.url = &quot;github:nixos/nixpkgs/nixpkgs-unstable&quot;;
    nix-darwin.url = &quot;github:lnl7/nix-darwin&quot;;
    nix-darwin.inputs.nixpkgs.follows = &quot;nixpkgs&quot;;
  };
  outputs = { nixpkgs, nix-darwin }:
    let
      system = &quot;aarch64-darwin&quot;;
      pkgs = nixpkgs.legacyPackages.${system};
    in with pkgs; {
      darwinConfigurations = {
        &quot;ebzzry-mbp&quot; = nix-darwin.lib.darwinSystem {
          modules = &#91; ./darwin-configuration.nix &#93;;
          specialArgs = { inherit pkgs; };
        };
      };
      darwinPackages = self.darwinConfigurations.&quot;ebzzry-mbp&quot;.pkgs;
    };
}
</code></pre><p>Por remunti la Darwin-agordon, rulu</p><pre><code class="sh">darwin-rebuild switch --flake .
</code></pre><h3><a name="restrukturi">Restrukturado</a></h3><p>Tre baldaŭ, oni malkovros ke la agordo estas fuŝaĵo:</p><pre><code class="nix">{
  inputs = { nixpkgs.url = &quot;github:nixos/nixpkgs?ref=nixpkgs-unstable&quot;; };
  outputs = { nixpkgs, ... }:
    let
      nixosSystem = &quot;x86-64&#95;linux&quot;;
      nixosPackages = nixpkgs.legacyPackages.${nixosSystem};
      darwinSystem = &quot;aarch64-darwin&quot;;
      darwinPackages = nixpkgs.legacyPackages.${darwinSystem};
    in {
      packages.${nixosSystem} = with nixosPackages; rec {
        hello = hello;
        default = hello;
      };
      devShells.${nixosSystem} = with nixosPackages; rec {
        lisp = mkShell { buildInputs = &#91; sbcl &#93;; };
        default = lisp;
      };
      apps.${nixosSystem} = with nixosPackages; rec {
        btop = {
          type = &quot;app&quot;;
          program = &quot;${pkgs.btop}/bin/btop&quot;;
        };
        default = btop;
      };
      packages.${darwinSystem} = with darwinPackages; rec {
        hello = hello;
        default = hello;
      };
      devShells.${darwinSystem} = with darwinPackages; rec {
        lisp = mkShell { buildInputs = &#91; sbcl &#93;; };
        default = lisp;
      };
      apps.${darwinSystem} = with darwinPackages; rec {
        btop = {
          type = &quot;app&quot;;
          program = &quot;${pkgs.btop}/bin/btop&quot;;
        };
        default = btop;
      };
    };
}
</code></pre><p>Ĉiu eligo kiun oni kreas por sistemo, devas esti skribita por la aliaj sistemoj, kiun oni deziras subteni. Tie estas ie kie <a href='https://github.com/numtide/flake-utils'>flake-utils</a> helpas. Ĝi estas aro de utilecaj funkcioj kiu helpas en skribi pli bonajn Nix-esprimojn. Unue ni restrukturu la eligojn por igin ilin pli belajn.</p><p>apps.nix:<pre><code class="nix">{ pkgs }: rec {
  hello = {
    type = &quot;app&quot;;
    program = &quot;${pkgs.hello}/bin/hello&quot;;
  };
  default = hello;
}
 </code></pre></p><p>packages.nix:<pre><code class="nix">{ pkgs }: rec {
  btop = pkgs.btop;
  default = btop;
}
 </code></pre></p><p>shells.nix:<pre><code class="nix">{ nixpkgs, pkgs, ... }:
with pkgs; rec {
  lisp = mkShell { buildInputs = &#91; sbcl &#93;; };
  default = lisp;
}
 </code></pre></p><p>Sekve, ni restrukturu <code>flake.nix</code>:</p><p>flake.nix:<pre><code class="nix">{
  description = &quot;A flake️️&quot;;
  inputs = {
    nixpkgs.url = &quot;github:nixos/nixpkgs/nixpkgs-unstable&quot;;
    nixos.url = &quot;github:nixos/nixpkgs/nixos-unstable&quot;;
    flake-utils.url = &quot;github:numtide/flake-utils&quot;;
  };
  outputs = { self, nixpkgs, nixos, nix-darwin, flake-utils }:
    let
      user = &quot;ebzzry&quot;;
      nixosHostName = &quot;la-vulpo&quot;;
      nixosSystem = &quot;x86&#95;64-linux&quot;;
      darwinHostName = &quot;la-orcino&quot;;
      darwinSystem = &quot;aarch64-darwin&quot;;
    in flake-utils.lib.eachDefaultSystem &#40;system:
      let pkgs = nixpkgs.legacyPackages.${system};
      in {
        apps = import ./apps.nix { inherit pkgs; };
        packages = import ./packages.nix { inherit pkgs; };
        devShells = import ./shells.nix { inherit nixpkgs pkgs; };
      }&#41;;
}
 </code></pre></p><p>Ne forgesu aldoni la novajn <code>.nix</code>-dosierojn kiujn oni krenas. </p><p>Tio kio ekazas ĉi tie estas ke ni aldonas novan enigon, <code>flake-utils</code>, kaj sekve, ni pasas ĝin al <code>outputs</code>, fine ni vokas funkcion.</p><p>La funkcio <code>flake-utils.lib.eachDefaultSystem</code> prenas funkcion kiel sia argumento—<code>&#40;system: ...&#41;</code>. Tiu funkcio prenas unuopan argumenton, <code>system</code>, kiu kongruas al la haveblaj sistemoj. Ĝi tiam iteracias tra ĉiu sistemo kaj generi la esprimojn.</p><h2><a name="finrimarkoj">Finrimarkoj</a></h2><p>Per Nix-flokoj, ĉio fariĝas pli deklara, pli komprenebla, kaj pli lakona. Mi opinias, ke estas facile administri miajn sistemojn per simpla aliro.</p><p>Ĝi povas ŝanĝiĝi en la estonteco, tamen, flokoj nun, estas la plej bona maniero por administri pakojn kaj agordojn. Oni provu uzi ĝin!</p><hr/><div class="footer"><p><div class="text-small"> <a href='/eo/'>Hejmo</a> • <a href='/eo/pri/'>Pri</a> • <a href='/eo/citajxoj/'>Citaĵoj</a> • <a href='/eo/pripensoj/'>Pripensoj</a> </div></p><p><div class="text-x-small"> Kreita per ❤️ de Rommel Martínez </div></p><p></div></p></div><script src="/static/js/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>