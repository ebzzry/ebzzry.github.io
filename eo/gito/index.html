<!DOCTYPE html>
<html lang="eo"><head><title>Kiel Mi Uzas Giton ĉe la Komandlinio</title><meta charset="utf-8" /><meta content="width=device-width,initial-scale=1.0,user-scalable=yes" name="viewport" /><meta content="noodp,noydir" name="robots" /><link rel='apple-touch-icon' sizes='180x180' href='/images/ico/apple-touch-icon.png'><link rel='icon' type='image/png' sizes='32x32' href='/images/ico/favicon-32x32.png'><link rel='icon' type='image/png' sizes='16x16' href='/images/ico/favicon-16x16.png'><link rel='manifest' href='/images/ico/site.webmanifest'><link rel='mask-icon' href='/images/ico/safari-pinned-tab.svg' color='#5bbad5'><link rel='shortcut icon' href='/images/ico/favicon.ico'> <meta name='msapplication-TileColor' content='#da532c'> <meta name='msapplication-config' content='/images/ico/browserconfig.xml'> <meta name='theme-color' content='#ffffff'><meta content="Kiel Mi Uzas Giton ĉe la Komandlinio" name="description" /><meta content="gito, ŝelo, sxelo, ziŝo, zisxo, linukso, makintoŝo, makintosxo, vindozo, agordo, agordaĵo, agordajxo" name="keywords" /><meta content="Kiel Mi Uzas Giton ĉe la Komandlinio" property="og:title" /><meta content="article" property="og:type" /><meta content="https://ebzzry.com/eo/gito/" property="og:url" /><meta content="https://ebzzry.com/images/ico/android-chrome-512x512.png" property="og:image" /><style media="all" type="text/css">html {    color: #333;    font-size: 1em;    font-family: Georgia, Cambria, Palatino, "Palatino Linotype", "Times New Roman", Times, serif;    line-height: 1.45;    text-align: left:    width: 100%;    max-width: 40em;    margin: 0 auto 0 auto;    padding: 0;}body {    border-top: hidden;    border-bottom: hidden;    padding: 0 1.5em 1em 1.5em;    margin: 0;}#content {    -webkit-column-count: 1;    -moz-column-count: 1;    column-count: 1;}code {    font-size: 0.9em;    font-family: "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Lucida Console", "Courier New", Courier, monospace;    color: black;    display: inline-block;}pre code {    font-size: 1em;    font-family: monospace;    line-height: 1.3em;    overflow: auto;    font-weight: normal;}kbd {    font-size: 1.1em;    padding: 0.1em 0.6em;    border: 1px solid #ccc;    font-family: monospace;    background-color: #f7f7f7;    color: #333;    -moz-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    -webkit-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    -moz-border-radius: 3px;    -webkit-border-radius: 3px;    border-radius: 3px;    display: inline-block;    margin: 0 0.1em;    text-shadow: 0 1px 0 #fff;    white-space: nowrap;}h1, h2, h3, h4, h5, h6 {    font-family: Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans", Tahoma, Geneva, Helvetica, Arial, sans-serif;    margin-bottom: 0;}h1 {    font-size: 2.5em;    text-align: center;    border-bottom: 6px solid black;}h2 {    font-size: 2.0em;    text-align: left;    border-bottom: 2px solid black;}h3 {    font-size: 1.6em;    text-align: left;    border-bottom: 1px solid lightgrey;}h4 {    font-size: 1.5em;    text-align: left;}h5 {    font-size: 1.3em;    text-align: left;}ul, ol {    padding-left: 2em;}ul li {    list-style-type: square;}ul li li {    list-style-type: disc;}ul li li li {    list-style-type: circle;}ol li {    list-style-type: decimal;}p, para, b, strong, i, em, emph {    font-size: 1em;}blockquote {    font-size: 1.2em;    font-style: italic;    margin-left: 2em;}b, strong {    font-weight: bold;}i, em, emph {    font-style: italic;}table {    margin: 0.5em;    border-spacing: 0;    border-collapse: collapse;}th, td {    border: 1px solid lightgray;    padding-top: 0;    padding-bottom: 0;    padding-left: 0.45em;    padding-right: 0.45em;}.text-right {    text-align: right;}.text-small {    font-size: small;}.text-x-small {    font-size: x-small;}.banner {    display: block;    width: 100%;    margin-left: auto;    margin-right: auto;}.footer {    text-align: right;    float: right;    max-width: 18em;}.cc {    border-width: 0}.center {    text-align: center;}</style><style media="all" type="text/css">/* Ewan Themes -- based 99.99% from Tomorrow Night Theme *//* http://jmblog.github.com/color-themes-for-google-code-highlightjs *//* Original theme - https://github.com/chriskempson/tomorrow-theme *//* http://jmblog.github.com/color-themes-for-google-code-highlightjs *//* Tomorrow Comment */.hljs-comment {  color: #969896;}/* Tomorrow Red */.hljs-variable,.hljs-attribute,.hljs-tag,.hljs-regexp,.ruby .hljs-constant,.xml .hljs-tag .hljs-title,.xml .hljs-pi,.xml .hljs-doctype,.html .hljs-doctype,.css .hljs-id,.css .hljs-class,.css .hljs-pseudo {  color: #cc6666;}/* Tomorrow Orange */.hljs-number,.hljs-preprocessor,.hljs-pragma,.hljs-built_in,.hljs-literal,.hljs-params,.hljs-constant {  color: #de935f;}/* Tomorrow Yellow */.ruby .hljs-class .hljs-title,.css .hljs-rule .hljs-attribute {  color: #f0c674;}/* Tomorrow Green */.hljs-string,.hljs-value,.hljs-inheritance,.hljs-header,.hljs-name,.ruby .hljs-symbol,.xml .hljs-cdata {  color: #b5bd68;}/* Tomorrow Aqua */.hljs-title,.css .hljs-hexcolor {  color: #8abeb7;}/* Tomorrow Blue */.hljs-function,.python .hljs-decorator,.python .hljs-title,.ruby .hljs-function .hljs-title,.ruby .hljs-title .hljs-keyword,.perl .hljs-sub,.javascript .hljs-title,.coffeescript .hljs-title {  color: #81a2be;}/* Tomorrow Purple */.hljs-keyword,.javascript .hljs-function {  color: #b294bb;}.hljs {  display: block;  overflow-x: auto;  background: #1d1f21;  color: #c5c8c6;  padding: 0.5em;  -webkit-text-size-adjust: none;}.coffeescript .javascript,.javascript .xml,.tex .hljs-formula,.xml .javascript,.xml .vbscript,.xml .css,.xml .hljs-cdata {  opacity: 0.5;}pre code {    font-size: 1.1em;    font-family: monospace;    line-height: 1.3em;    overflow: auto;}</style></head><body><div id="content"><h1>Kiel Mi Uzas Giton ĉe la Komandlinio</h1><p><div class="center"><a href='/en/git/'>English</a> • Esperanto</div> <div class="center">Laste ĝisdatigita: la 24-an de januaro 2025</div></p><blockquote><p>Male, tiuj kun senĉeseco povas malatenti kiujn aliaj pensas. Ion ajn ili povas fari en ilia propra mondo senzorgeme al la opinioj de tiuj ĉirkaŭ ili.<br> —Daigo UMEHARA </p></blockquote><p><img src="/images/site/simon-berger-6te9SupeW1g-unsplash-1008x250.webp" style="display: block; width: 100%; margin-left: auto; margin-right: auto;" alt="simon-berger-6te9SupeW1g-unsplash" title="simon-berger-6te9SupeW1g-unsplash"/></p><h2><a name="et">Enhavotabelo</a></h2><ul><li><a href='#enkonduko'>Enkonduko</a></li><li><a href='#mallongaj'>Mallongaj komandoj</a><ul><li><a href='#alinomoj'>Alinomoj</a></li><li><a href='#alternativo'>Alternativo</a></li></ul></li><li><a href='#agordo'>Agordo</a><ul><li><a href='#bazafunkcio'>Baza funkcio</a></li><li><a href='#komandoj1'>Gravaj komandoj</a></li><li><a href='#komandoj2'>Aliaj komandoj</a></li></ul></li><li><a href='#cxio'>Ĉion rikolti</a></li><li><a href='#finrimarkoj'>Finrimarkoj</a></li></ul><h2><a name="enkonduko">Enkonduko</a></h2><p>En mia ilaro estas terminalsimulilo, ŝelo, redaktilo, retumilo, kompililo, kaj gito. Ekde kiam giton mi konis antaŭ multaj jaroj, ĝi fariĝis unu el miaj plej uzataj iloj. Pro ĝia rapideco kaj amplekso de uzo, ĝin mi uzas kiel mia tria brako.</p><p>Pro tio ke emakson mi uzas, je <a href='https://magit.vc/'>Magit</a> mi ankaŭ havas. Tamen, en ĉi tiu artikolo mi parolos pri kiel giton mi uzas ĉiutage ĉe la komandlinio.</p><p>La komandoj kaj funckioj kiujn ni havos ĉi tie estas por Ziŝo kaj Baŝo. Eblas, ke ili ankaŭ povas funkcii per aliaj ŝeloj, tamen, ilin mi ne testis.</p><h2><a name="mallongaj">Mallongaj komandoj</a></h2><p>Per gito, se la staton de deponejo ni volas vidi, la jenan komandon ni rulos:</p><pre><code>git status</code></pre><p>Tamen, estas pluraj kazoj kiam pli mallongan version ni deziras uzi:</p><pre><code>git s</code></pre><p>La pli mallongan version ni uzas eble aŭ por la ŝparado de maŝinskribado aŭ estas fizike malfacilas por la plenan komandon maŝinskribi. En ĉi tiu sekcio mi diskutos pri la ekzistantaj metodoj por pli mallongajn komandojn fari.</p><h3><a name="alinomoj">Alinomoj</a></h3><p>Manierojn por la difinado de mallongaj komandoj gito jam havas. Ekzemple, se ni deziras, ke anstataŭ</p><pre><code>git clone</code></pre><p>ni uzas je</p><pre><code>git c</code></pre><p>alinomon por la <code>clone</code>-komando ni povas difini per la alinoma sistemo de gito. Tion ni povas fari per du metodoj.</p><p>La unua metodo estas rekte per la komandlinio:</p><pre><code>git config --global alias.c clone</code></pre><p>La dua metodo estas per la agorda dosiero, kiu troviĝas en <code>&#126;/.gitconfig</code>. La jenan tekston ni metu en tiun dosieron:</p><pre><code>&#91;alias&#93;
  c = clone
</code></pre><p>Arbitrajn komandojn oni ankaŭ povas uzi ene la <code>alias</code>-klaŭzo. Estas du metodoj por tion fari.</p><p>La unua metodo estas rekte kiel ŝela komando:</p><pre><code>&#91;alias&#93;
  hello = &quot;! echo hello world&quot;
</code></pre><p>Se la komandon</p><pre><code>git hello</code></pre><p>oni rulas, ŝajnos, ke la jenan komandon oni rulis:</p><pre><code>echo hello world</code></pre><p>Do, konsekvece la eligo estas</p><pre><code>hello world</code></pre><p>La dua metodo estas per la difinado de ŝelaj funkcioj:</p><pre><code>&#91;alias&#93;
  hi = &quot;! hi &#40;&#41; { echo hi world; }; hi&quot;
</code></pre><p>Se la komandon</p><pre><code>git hi</code></pre><p>oni rulas, ŝajnos, ke la jenan komandon oni rulos:</p><pre><code>hi &#40;&#41; { echo hi world; }
hi</code></pre><p>Per ĝi, ŝelan funkcion kiu nomiĝas <code>hi</code> oni unue difinis. Sekve, tiun funkcion ni vokis. Do, la eligo estas:</p><pre><code>hi world</code></pre><h3><a name="alternativo">Alternativo</a></h3><p>Dum tiuj metodoj bonas por multaj uzantoj, ili ne sufiĉas por mi tial, ke aliron al mia tuta ŝela agordo ĝi ne havas. Aliajn funkciojn kiujn mi havas en mia ŝelagordo ĝi ne povas voki. Pli grave, la funkciado per alinomoj estas limigita nur ene la medio de la gitagordo.</p><p>Kion mi uzas anstataŭe estas ke ŝelan funkcion mi difinis, en kiu, ilin mi povas voki per falsaj alinomoj kaj per validaj gitkomandoj. Per tiu sistemo, se la jenan komandon mi uzos:</p><pre><code>git clone</code></pre><p>Gito kondutas same kiel la originala komando. Tamen se la jenan komandon mi uzos:</p><pre><code>git abc</code></pre><p>la subkomandon <code>abc</code>, kiun mi difinis, vi vokos. Eĉ se alinomon kun sama nomo mi jam havas en <code>&#126;/.gitconfig</code>, ĉi tiu komando kuras per pli alta prioritato.</p><h2><a name="agordo">Agordo</a></h2><p>En ĉi tiu sekcio estas difinoj kiujn ni devas meti en la agorddosiero de Ziŝo kaj Baŝo. Ilin mi havas en <code>&#126;/.zshenv</code> kaj <code>&#126;/.bashrc</code>, respektive.</p><h3><a name="bazafunkcio">Baza funkcio</a></h3><p>Jen la baza funcio:</p><pre><code>function git &#40;&#41; {
  local git= self= op=

  if &#91;&#91; -n &quot;${BASH}&quot; &#93;&#93;; then
    git=$&#40;which git&#41;
    self=${FUNCNAME}
  elif &#91;&#91; -n &quot;${ZSH&#95;NAME}&quot; &#93;&#93;; then
    git=$&#40;whence -p git&#41;
    self=$0
  else
    echo &quot;Meh&quot;
    return 1
  fi

  if &#91;&#91; $# -eq 0 &#93;&#93;; then
    if &#91;&#91; -n &quot;${BASH}&quot; &#93;&#93;; then
      type &quot;${self}&quot; | less
    elif &#91;&#91; -n &quot;${ZSH&#95;NAME}&quot; &#93;&#93;; then
      which &quot;${self}&quot; | less
    else
      echo &quot;Meh&quot;
      return 1
    fi
  else
    op=&quot;$1&quot;
    shift

    case &quot;${op}&quot; in
      # komandoj ĉi tie
      &#40;&#42;&#41; =git &quot;${op}&quot; &quot;$@&quot; ;;
    esac
  fi
}
</code></pre><p>Se ne estas komando por gito:</p><pre><code>git</code></pre><p>la difinon de la funkcio mem la ŝelo montras.</p><p>La subkomandoj loĝos en la areo markita <code># komandoj ĉi tie</code>. La retropaŝa ago markita per <code>&#42;</code> signifas, ke se ne estas propra komando el mi, la internan komandon de gito ruli anstataŭ.</p><h3><a name="komandoj1">Gravaj komandoj</a></h3><p>Jen la plej gravaj komandoj kiujn ni unue devas havi.</p><p><strong>Ĉefaj operacioj</strong></p><pre><code>      &#40;s&#41; &quot;${git}&quot; status ;;
      &#40;c&#41; &quot;${git}&quot; clone &quot;$@&quot; ;;
      &#40;h&#41; &quot;${git}&quot; show &quot;$@&quot; ;;
      &#40;mv&#41; &quot;${git}&quot; mv &quot;$@&quot; ;;
      &#40;mv!&#41; &quot;${git}&quot; mv -f &quot;$@&quot; ;;
      &#40;me&#41; &quot;${git}&quot; merge &quot;$@&quot; ;;
      &#40;ta&#41; &quot;${git}&quot; tag &quot;$@&quot; ;;
      &#40;bl&#41; &quot;${git}&quot; blame &quot;$@&quot; ;;

      &#40;a&#41; &quot;${git}&quot; add &quot;$@&quot; ;;
      &#40;au&#41; &quot;${self}&quot; a -u ;;
      &#40;a.&#41; &quot;${self}&quot; a . ;;
      &#40;aum&#41; &quot;${self}&quot; au; &quot;${self}&quot; cim &quot;$@&quot; ;;
      &#40;a.m&#41; &quot;${self}&quot; a.; &quot;${self}&quot; cim &quot;$@&quot; ;;
      &#40;a.x&#41; &quot;${self}&quot; a.m &quot;x&quot; ;;
      &#40;aux&#41; &quot;${self}&quot; aum &quot;x&quot; ;;
      &#40;auxx&#41; &quot;${self}&quot; aux; &quot;${self}&quot; rs 2 ;;
      &#40;au.x&#41; &quot;${self}&quot; a.x; &quot;${self}&quot; rs 2 ;;
      &#40;auxx!&#41; &quot;${self}&quot; auxx; &quot;${self}&quot; oo! ;;

      &#40;cl&#41; &quot;${git}&quot; clean &quot;$@&quot; ;;
      &#40;cl!&#41; &quot;${self}&quot; cl -f ;;

      &#40;ci&#41; &quot;${git}&quot; commit &quot;$@&quot; ;;
      &#40;cia&#41; &quot;${self}&quot; ci --amend &quot;$@&quot; ;;
      &#40;cim&#41; &quot;${self}&quot; ci --message &quot;$@&quot; ;;

      &#40;co&#41; &quot;${git}&quot; checkout &quot;$@&quot; ;;
      &#40;com&#41; &quot;${self}&quot; co main ;;
      &#40;cot&#41; &quot;${self}&quot; co trunk ;;
      &#40;co!&#41; &quot;${self}&quot; co --force &quot;$@&quot; ;;
      &#40;cob&#41; &quot;${self}&quot; co -b &quot;$@&quot; ;;

      &#40;ls&#41; &quot;${git}&quot; ls-files &quot;$@&quot; ;;
      &#40;lsm&#41; &quot;${self}&quot; ls -m ;;
      &#40;lsd&#41; &quot;${self}&quot; ls -d ;;
      &#40;lsdrm&#41; &quot;${self}&quot; lsd | xargs &quot;${git}&quot; rm ;;

      &#40;rt&#41; &quot;${git}&quot; reset &quot;$@&quot; ;;
      &#40;rt!&#41; &quot;${self}&quot; rt --hard &quot;$@&quot; ;;
      &#40;rv&#41; &quot;${git}&quot; revert &quot;$@&quot; ;;

      &#40;g&#41; &quot;${git}&quot; grep &quot;$@&quot; ;;
      &#40;gi&#41; &quot;${self}&quot; g -i &quot;$@&quot; ;;

      &#40;f&#41; &quot;${git}&quot; fetch &quot;$@&quot; ;;
      &#40;fa&#41; &quot;${self}&quot; f --all &quot;$@&quot; ;;

      &#40;rm&#41; &quot;${git}&quot; rm &quot;$@&quot; ;;
      &#40;rmr&#41; &quot;${self}&quot; rm -r &quot;$@&quot; ;;
      &#40;rm!&#41; &quot;${self}&quot; rm -rf &quot;$@&quot; ;;
</code></pre><p><strong>Puŝado kaj tirado</strong></p><pre><code>      &#40;ph&#41; &quot;${git}&quot; push &quot;$@&quot; ;;
      &#40;phu&#41; &quot;${self}&quot; ph -u &quot;$@&quot; ;;
      &#40;ph!&#41; &quot;${self}&quot; ph --force &quot;$@&quot; ;;
      &#40;pho&#41; &quot;${self}&quot; phu origin &quot;$@&quot; ;;
      &#40;phoo&#41; &quot;${self}&quot; phu origin &quot;$&#40;git brh&#41;&quot; ;;
      &#40;phd&#41; &quot;${self}&quot; ph --delete &quot;$@&quot; ;;
      &#40;phdo&#41; &quot;${self}&quot; phd origin &quot;$&#40;git brh&#41;&quot; ;;
      &#40;oo&#41; &quot;${self}&quot; ph origin &quot;$&#40;git brh&#41;&quot; ;;
      &#40;oo!&#41; &quot;${self}&quot; ph! origin &quot;$&#40;git brh&#41;&quot; ;;

      &#40;pl&#41; &quot;${git}&quot; pull &quot;$@&quot; ;;
      &#40;pl!&#41; &quot;${self}&quot; pl --force &quot;$@&quot; ;;
      &#40;plr&#41; &quot;${self}&quot; pl --rebase &quot;$@&quot; ;;
      &#40;plro&#41; &quot;${self}&quot; plr origin &quot;$@&quot; ;;
      &#40;plroo&#41; &quot;${self}&quot; plr origin &quot;$&#40;git brh&#41;&quot; ;;
      &#40;plru&#41; &quot;${self}&quot; plr upstream &quot;$@&quot; ;;
      &#40;plruo&#41; &quot;${self}&quot; plr upstream &quot;$&#40;git brh&#41;&quot; ;;
</code></pre><p><strong>Branĉoj kaj dosierdiferencoj</strong></p><pre><code>      &#40;br&#41; &quot;${git}&quot; branch &quot;$@&quot; ;;
      &#40;bra&#41; &quot;${self}&quot; br -a ;;
      &#40;brm&#41; &quot;${self}&quot; br -m &quot;$@&quot; ;;
      &#40;brmh&#41; &quot;${self}&quot; brm &quot;$&#40;git brh&#41;&quot; ;;
      &#40;brd&#41; &quot;${self}&quot; br -d &quot;$@&quot; ;;
      &#40;brD&#41; &quot;${self}&quot; br -D &quot;$@&quot; ;;
      &#40;brh&#41; &quot;${git}&quot; rev-parse --abbrev-ref HEAD ;;

      &#40;d&#41; &quot;${git}&quot; diff &quot;$@&quot; ;;
      &#40;dc&#41; &quot;${git}&quot; diff --cached &quot;$@&quot; ;;
      &#40;dh&#41; &quot;${self}&quot; d HEAD ;;
      &#40;dhw&#41; &quot;${self}&quot; d --word-diff=color ;;
</code></pre><p><strong>Protokoloj</strong></p><pre><code>      &#40;l&#41; &quot;${git}&quot; log &quot;$@&quot; ;;
      &#40;l1&#41; &quot;${self}&quot; l -1 --pretty=%B ;;
      &#40;lo&#41; &quot;${self}&quot; l --oneline ;;
      &#40;lp&#41; &quot;${self}&quot; l --patch ;;
      &#40;lp1&#41; &quot;${self}&quot; lp -1 ;;
      &#40;lpw&#41; &quot;${self}&quot; lp --word-diff=color ;;
</code></pre><h3><a name="komandoj2">Aliaj komandoj</a></h3><p>Jen aliaj komandoj kiujn ni ankaŭ devas difini.</p><p><strong>Pravaloriziĝado kaj puŝadheloj</strong></p><pre><code>      &#40;i&#41; touch .gitignore; &quot;${git}&quot; init; &quot;${self}&quot; a.; &quot;${self}&quot; cim &quot;$@&quot; ;;
      &#40;i!&#41; &quot;${self}&quot; i &quot;&#91;supro&#93; pravaloriziĝu&quot; ;;

      &#40;oo&#41; &quot;${self}&quot; ph origin &quot;$&#40;git brh&#41;&quot; ;;
      &#40;oo!&#41; &quot;${self}&quot; ph! origin &quot;$&#40;git brh&#41;&quot; ;;

</code></pre><p>Kiam ajn novajn deponejon mi kreas, la jenan komandon mi rulas:</p><pre><code>git i Pravaloriziĝu</code></pre><p>Kion la <code>oo</code> subkomando faras estas ke la kodo puŝiĝos al la fordeponejo kiu nomiĝas <code>origin</code> sub la nomo de la aktuala branĉo. Ekzemple, se la aktuala branĉo nomiĝas <code>trunk</code>, kaj la jenan komandon oni rulas:</p><pre><code>git oo</code></pre><p>la komando fariĝos</p><pre><code>git ph origin trunk</code></pre><p><strong>Ŝanĝado de arboj</strong></p><pre><code>      &#40;rb&#41; &quot;${git}&quot; rebase &quot;$@&quot; ;;
      &#40;rbi&#41; &quot;${self}&quot; rb --interactive &quot;$@&quot; ;;
      &#40;rbc&#41; &quot;${self}&quot; rb --continue &quot;$@&quot; ;;
      &#40;rbs&#41; &quot;${self}&quot; rb --skip &quot;$@&quot; ;;
      &#40;rba&#41; &quot;${self}&quot; rb --abort &quot;$@&quot; ;;
      &#40;rbs&#41; &quot;${self}&quot; rb --skip &quot;$@&quot; ;;
      &#40;rbi!&#41; &quot;${self}&quot; rbi --root &quot;$@&quot; ;;

      &#40;ri&#41; &quot;${self}&quot; rbi HEAD&#126;&quot;$1&quot; ;;
      &#40;rs&#41; &quot;${self}&quot; rt --soft HEAD&#126;&quot;$1&quot; &amp;&amp; &quot;${self}&quot; cim &quot;$&#40;git log --format=%B --reverse HEAD..HEAD@{1} | head -1&#41;&quot; ;;
</code></pre><p>La subkomandon <code>rs</code> mi uzas kiam ŝanĝojn mi volas kunpremegi neinterage. La argumento al ĝi estas cifero kio prezicigas kiom da ŝanĝo oni volas kunpremigi. Ekzemple, se la lastajn du ŝanĝojn mi volas kunpremegi, la jenan komandon mi uzas:</p><pre><code>git rs 2</code></pre><p><strong>Aldonado</strong></p><pre><code>      &#40;a&#41; &quot;${git}&quot; add &quot;$@&quot; ;;
      &#40;au&#41; &quot;${self}&quot; a -u ;;
      &#40;a.&#41; &quot;${self}&quot; a . ;;
      &#40;aum&#41; &quot;${self}&quot; au; &quot;${self}&quot; cim &quot;$@&quot; ;;
      &#40;a.m&#41; &quot;${self}&quot; a.; &quot;${self}&quot; cim &quot;$@&quot; ;;
      &#40;a.x&#41; &quot;${self}&quot; a.m &quot;x&quot; ;;
      &#40;aux&#41; &quot;${self}&quot; aum &quot;x&quot; ;;
      &#40;auxx&#41; &quot;${self}&quot; aux; &quot;${self}&quot; rs 2 ;;
      &#40;au.x&#41; &quot;${self}&quot; a.x; &quot;${self}&quot; rs 2 ;;
      &#40;auxx!&#41; &quot;${self}&quot; auxx; &quot;${self}&quot; oo! ;;
</code></pre><p>La subkomando <code>aum</code> fariĝos mallongigo de <code>au</code> kaj <code>cm</code> orde. La subkomandon <code>auxx</code> mi uzas kiam ajn nur etajn ŝanĝojn mi faris sed novan videblan enskribon en la protokolo mi ne deziras havi.</p><p><strong>Foraj deponejoj</strong></p><pre><code>      &#40;re&#41; &quot;${git}&quot; remote &quot;$@&quot; ;;
      &#40;rea&#41; &quot;${self}&quot; re add &quot;$@&quot; ;;
      &#40;reao&#41; &quot;${self}&quot; rea origin &quot;$@&quot; ;;
      &#40;reau&#41; &quot;${self}&quot; rea upstream &quot;$@&quot; ;;
      &#40;rer&#41; &quot;${self}&quot; re remove &quot;$@&quot; ;;
      &#40;ren&#41; &quot;${self}&quot; re rename &quot;$@&quot; ;;
      &#40;rero&#41; &quot;${self}&quot; rer origin &quot;$@&quot; ;;
      &#40;reru&#41; &quot;${self}&quot; rer upstream &quot;$@&quot; ;;
      &#40;res&#41; &quot;${self}&quot; re show &quot;$@&quot; ;;
      &#40;reso&#41; &quot;${self}&quot; res origin ;;
      &#40;resu&#41; &quot;${self}&quot; res upstream ;;
</code></pre><p><strong>Revizioj, filtrado, kaj kaŝujoj</strong></p><pre><code>      &#40;rl&#41; &quot;${git}&quot; rev-list &quot;$@&quot; ;;
      &#40;rla&#41; &quot;${self}&quot; rl --all &quot;$@&quot; ;;
      &#40;rl0&#41; &quot;${self}&quot; rl --max-parents=0 HEAD ;;

      &#40;cp&#41; &quot;${git}&quot; cherry-pick &quot;$@&quot; ;;
      &#40;cpc&#41; &quot;${self}&quot; cp --continue &quot;$@&quot; ;;
      &#40;cpa&#41; &quot;${self}&quot; cp --abort &quot;$@&quot; ;;

      &#40;fr&#41; &quot;${git}&quot; filter-repo &quot;$@&quot; ;;
      &#40;fr!&#41; &quot;${git}&quot; filter-repo --force &quot;$@&quot; ;;

      &#40;rp&#41; &quot;${git}&quot; rev-parse &quot;$@&quot; ;;
      &#40;rph&#41; &quot;${self}&quot; rp HEAD ;;

      &#40;st&#41; &quot;${git}&quot; stash &quot;$@&quot; ;;
      &#40;stp&#41; &quot;${self}&quot; st pop &quot;$@&quot; ;;
</code></pre><p>Kiam ajn tekstojn de ĉiuj antaŭaj ŝanĝmesaĝoj mi volas ŝanĝi, ekzemple la vorton <code>hundo</code> mi volas ŝanĝi al <code>kato</code>, la jenan komandon mi rulas:</p><pre><code>git fr! --replace-message &lt;&#40;echo 'hundo==&gt;kato'&#41;</code></pre><p>Kiam ajn dosieron mi volas forigi tute el la deponejo, ekzemple <code>dosiero.dat</code>, la jenan komandon mi rulas:</p><pre><code>git fr! --invert-paths --path dosiero.dat</code></pre><p>Kiam ajn la retpoŝadreson mi volas ŝanĝi, ekzemple, de <code>hundo@mondo.io</code> al <code>kato@mondo.io</code>, la jenan komandon mi rulas:</p><pre><code>    git fr! --email-callback 'return email.replace&#40;b&quot;hundo@mondo.io&quot;, b&quot;kato@mondo.io&quot;&#41;'
</code></pre><p>La jenan komandon mi tiam uzas sekve, por certigi ke la ŝanĝoj aperas en la fora deponejo:</p><pre><code>git oo!</code></pre><p><strong>Subarboj, kaj submoduloj</strong></p><pre><code>      &#40;subt&#41; &quot;${git}&quot; subtree &quot;$@&quot; ;;
      &#40;subta&#41; &quot;${self}&quot; subt add &quot;$@&quot; ;;
      &#40;subtph&#41; &quot;${self}&quot; subt push &quot;$@&quot; ;;
      &#40;subtpl&#41; &quot;${self}&quot; subt pull &quot;$@&quot; ;;

      &#40;subm&#41; &quot;${git}&quot; submodule &quot;$@&quot; ;;
      &#40;subms&#41; &quot;${self}&quot; subm status &quot;$@&quot; ;;
      &#40;submy&#41; &quot;${self}&quot; subm summary &quot;$@&quot; ;;
      &#40;submu&#41; &quot;${self}&quot; subm update &quot;$@&quot; ;;
      &#40;subma&#41; &quot;${self}&quot; subm add &quot;$@&quot; ;;
      &#40;submi&#41; &quot;${self}&quot; subm init &quot;$@&quot; ;;

      &#40;ref&#41; &quot;${git}&quot; reflog &quot;$@&quot; ;;
</code></pre><p><strong>Priskribado</strong></p><pre><code>      &#40;de&#41; &quot;${git}&quot; describe &quot;$@&quot; ;;
      &#40;det&#41; &quot;${self}&quot; de --tags &quot;$@&quot; ;;
</code></pre><h2><a name="cxio">Ĉion rikolti</a></h2><p>Jen da difinoj en unu loko:</p><pre><code>function git {
  local git= self= op=

  if &#91;&#91; -n &quot;${BASH}&quot; &#93;&#93;; then
    git=$&#40;which git&#41;
    self=${FUNCNAME}
  elif &#91;&#91; -n &quot;${ZSH&#95;NAME}&quot; &#93;&#93;; then
    git=$&#40;whence -p git&#41;
    self=$0
  else
    echo &quot;Ve.&quot;
    return 1
  fi

  if &#91;&#91; $# -eq 0 &#93;&#93;; then
    if &#91;&#91; -n &quot;${BASH}&quot; &#93;&#93;; then
      type &quot;${self}&quot; | less
    elif &#91;&#91; -n &quot;${ZSH&#95;NAME}&quot; &#93;&#93;; then
      which &quot;${self}&quot; | less
    else
      echo &quot;Meh&quot;
      return 1
    fi
  else
    op=&quot;$1&quot;
    shift

    case &quot;${op}&quot; in
      &#40;i&#41; touch .gitignore; &quot;${git}&quot; init; &quot;${self}&quot; a.; &quot;${self}&quot; cim &quot;$@&quot; ;;
      &#40;i!&#41; &quot;${self}&quot; i &quot;&#91;supro&#93; pravalorizu novdeponejon&quot; ;;

      &#40;s&#41; &quot;${git}&quot; status ;;
      &#40;c&#41; &quot;${git}&quot; clone &quot;$@&quot; ;;
      &#40;h&#41; &quot;${git}&quot; show &quot;$@&quot; ;;
      &#40;mv&#41; &quot;${git}&quot; mv &quot;$@&quot; ;;
      &#40;mv!&#41; &quot;${git}&quot; mv -f &quot;$@&quot; ;;
      &#40;me&#41; &quot;${git}&quot; merge &quot;$@&quot; ;;
      &#40;ta&#41; &quot;${git}&quot; tag &quot;$@&quot; ;;
      &#40;bl&#41; &quot;${git}&quot; blame &quot;$@&quot; ;;

      &#40;a&#41; &quot;${git}&quot; add &quot;$@&quot; ;;
      &#40;au&#41; &quot;${self}&quot; a -u ;;
      &#40;a.&#41; &quot;${self}&quot; a . ;;
      &#40;aum&#41; &quot;${self}&quot; au; &quot;${self}&quot; cim &quot;$@&quot; ;;
      &#40;a.m&#41; &quot;${self}&quot; a.; &quot;${self}&quot; cim &quot;$@&quot; ;;
      &#40;a.x&#41; &quot;${self}&quot; a.m &quot;x&quot; ;;
      &#40;aux&#41; &quot;${self}&quot; aum &quot;x&quot; ;;
      &#40;auxx&#41; &quot;${self}&quot; aux; &quot;${self}&quot; rs 2 ;;
      &#40;au.x&#41; &quot;${self}&quot; a.x; &quot;${self}&quot; rs 2 ;;
      &#40;auxx!&#41; &quot;${self}&quot; auxx; &quot;${self}&quot; oo! ;;

      &#40;cl&#41; &quot;${git}&quot; clean &quot;$@&quot; ;;
      &#40;cl!&#41; &quot;${self}&quot; cl -f ;;

      &#40;ci&#41; &quot;${git}&quot; commit &quot;$@&quot; ;;
      &#40;cia&#41; &quot;${self}&quot; ci --amend &quot;$@&quot; ;;
      &#40;cim&#41; &quot;${self}&quot; ci --message &quot;$@&quot; ;;

      &#40;co&#41; &quot;${git}&quot; checkout &quot;$@&quot; ;;
      &#40;com&#41; &quot;${self}&quot; co main ;;
      &#40;cot&#41; &quot;${self}&quot; co trunk ;;
      &#40;co!&#41; &quot;${self}&quot; co --force &quot;$@&quot; ;;
      &#40;cob&#41; &quot;${self}&quot; co -b &quot;$@&quot; ;;

      &#40;ls&#41; &quot;${git}&quot; ls-files &quot;$@&quot; ;;
      &#40;lsm&#41; &quot;${self}&quot; ls -m ;;
      &#40;lsd&#41; &quot;${self}&quot; ls -d ;;
      &#40;lsdrm&#41; &quot;${self}&quot; lsd | xargs &quot;${git}&quot; rm ;;

      &#40;rt&#41; &quot;${git}&quot; reset &quot;$@&quot; ;;
      &#40;rt!&#41; &quot;${self}&quot; rt --hard &quot;$@&quot; ;;
      &#40;rv&#41; &quot;${git}&quot; revert &quot;$@&quot; ;;

      &#40;g&#41; &quot;${git}&quot; grep &quot;$@&quot; ;;
      &#40;gi&#41; &quot;${self}&quot; g -i &quot;$@&quot; ;;

      &#40;f&#41; &quot;${git}&quot; fetch &quot;$@&quot; ;;
      &#40;fa&#41; &quot;${self}&quot; f --all &quot;$@&quot; ;;

      &#40;fr&#41; &quot;${git}&quot; filter-repo &quot;$@&quot; ;;
      &#40;fr!&#41; &quot;${git}&quot; filter-repo --force &quot;$@&quot; ;;

      &#40;rm&#41; &quot;${git}&quot; rm &quot;$@&quot; ;;
      &#40;rmr&#41; &quot;${self}&quot; rm -r &quot;$@&quot; ;;
      &#40;rm!&#41; &quot;${self}&quot; rm -rf &quot;$@&quot; ;;

      &#40;rb&#41; &quot;${git}&quot; rebase &quot;$@&quot; ;;
      &#40;rbi&#41; &quot;${self}&quot; rb --interactive &quot;$@&quot; ;;
      &#40;rbc&#41; &quot;${self}&quot; rb --continue &quot;$@&quot; ;;
      &#40;rbs&#41; &quot;${self}&quot; rb --skip &quot;$@&quot; ;;
      &#40;rba&#41; &quot;${self}&quot; rb --abort &quot;$@&quot; ;;
      &#40;rbs&#41; &quot;${self}&quot; rb --skip &quot;$@&quot; ;;
      &#40;rbi!&#41; &quot;${self}&quot; rbi --root &quot;$@&quot; ;;

      &#40;ri&#41; &quot;${self}&quot; rbi HEAD&#126;&quot;$1&quot; ;;
      &#40;rs&#41; &quot;${self}&quot; rt --soft HEAD&#126;&quot;$1&quot; &amp;&amp; &quot;${self}&quot; cim &quot;$&#40;git log --format=%B --reverse HEAD..HEAD@{1} | head -1&#41;&quot; ;;

      &#40;ph&#41; &quot;${git}&quot; push &quot;$@&quot; ;;
      &#40;phu&#41; &quot;${self}&quot; ph -u &quot;$@&quot; ;;
      &#40;ph!&#41; &quot;${self}&quot; ph --force &quot;$@&quot; ;;
      &#40;pho&#41; &quot;${self}&quot; phu origin &quot;$@&quot; ;;
      &#40;phoo&#41; &quot;${self}&quot; phu origin &quot;$&#40;git brh&#41;&quot; ;;
      &#40;phd&#41; &quot;${self}&quot; ph --delete &quot;$@&quot; ;;
      &#40;phdo&#41; &quot;${self}&quot; phd origin &quot;$&#40;git brh&#41;&quot; ;;
      &#40;oo&#41; &quot;${self}&quot; ph origin &quot;$&#40;git brh&#41;&quot; ;;
      &#40;oo!&#41; &quot;${self}&quot; ph! origin &quot;$&#40;git brh&#41;&quot; ;;

      &#40;pl&#41; &quot;${git}&quot; pull &quot;$@&quot; ;;
      &#40;pl!&#41; &quot;${self}&quot; pl --force &quot;$@&quot; ;;
      &#40;plr&#41; &quot;${self}&quot; pl --rebase &quot;$@&quot; ;;
      &#40;plro&#41; &quot;${self}&quot; plr origin &quot;$@&quot; ;;
      &#40;plroo&#41; &quot;${self}&quot; plr origin &quot;$&#40;git brh&#41;&quot; ;;
      &#40;plru&#41; &quot;${self}&quot; plr upstream &quot;$@&quot; ;;
      &#40;plruo&#41; &quot;${self}&quot; plr upstream &quot;$&#40;git brh&#41;&quot; ;;

      &#40;l&#41; &quot;${git}&quot; log &quot;$@&quot; ;;
      &#40;l1&#41; &quot;${self}&quot; l -1 --pretty=%B ;;
      &#40;lo&#41; &quot;${self}&quot; l --oneline ;;
      &#40;lp&#41; &quot;${self}&quot; l --patch ;;
      &#40;lp1&#41; &quot;${self}&quot; lp -1 ;;
      &#40;lpw&#41; &quot;${self}&quot; lp --word-diff=color ;;

      &#40;br&#41; &quot;${git}&quot; branch &quot;$@&quot; ;;
      &#40;bra&#41; &quot;${self}&quot; br -a ;;
      &#40;brm&#41; &quot;${self}&quot; br -m &quot;$@&quot; ;;
      &#40;brmh&#41; &quot;${self}&quot; brm &quot;$&#40;git brh&#41;&quot; ;;
      &#40;brd&#41; &quot;${self}&quot; br -d &quot;$@&quot; ;;
      &#40;brD&#41; &quot;${self}&quot; br -D &quot;$@&quot; ;;
      &#40;brh&#41; &quot;${git}&quot; rev-parse --abbrev-ref HEAD ;;

      &#40;d&#41; &quot;${git}&quot; diff &quot;$@&quot; ;;
      &#40;dc&#41; &quot;${git}&quot; diff --cached &quot;$@&quot; ;;
      &#40;dh&#41; &quot;${self}&quot; d HEAD ;;
      &#40;dhw&#41; &quot;${self}&quot; d --word-diff=color ;;

      &#40;re&#41; &quot;${git}&quot; remote &quot;$@&quot; ;;
      &#40;rea&#41; &quot;${self}&quot; re add &quot;$@&quot; ;;
      &#40;reao&#41; &quot;${self}&quot; rea origin &quot;$@&quot; ;;
      &#40;reau&#41; &quot;${self}&quot; rea upstream &quot;$@&quot; ;;
      &#40;rer&#41; &quot;${self}&quot; re remove &quot;$@&quot; ;;
      &#40;ren&#41; &quot;${self}&quot; re rename &quot;$@&quot; ;;
      &#40;rero&#41; &quot;${self}&quot; rer origin &quot;$@&quot; ;;
      &#40;reru&#41; &quot;${self}&quot; rer upstream &quot;$@&quot; ;;
      &#40;res&#41; &quot;${self}&quot; re show &quot;$@&quot; ;;
      &#40;reso&#41; &quot;${self}&quot; res origin ;;
      &#40;resu&#41; &quot;${self}&quot; res upstream ;;

      &#40;rl&#41; &quot;${git}&quot; rev-list &quot;$@&quot; ;;
      &#40;rla&#41; &quot;${self}&quot; rl --all &quot;$@&quot; ;;
      &#40;rl0&#41; &quot;${self}&quot; rl --max-parents=0 HEAD ;;

      &#40;cp&#41; &quot;${git}&quot; cherry-pick &quot;$@&quot; ;;
      &#40;cpc&#41; &quot;${self}&quot; cp --continue &quot;$@&quot; ;;
      &#40;cpa&#41; &quot;${self}&quot; cp --abort &quot;$@&quot; ;;

      &#40;rp&#41; &quot;${git}&quot; rev-parse &quot;$@&quot; ;;
      &#40;rph&#41; &quot;${self}&quot; rp HEAD ;;

      &#40;st&#41; &quot;${git}&quot; stash &quot;$@&quot; ;;
      &#40;stp&#41; &quot;${self}&quot; st pop &quot;$@&quot; ;;

      &#40;subt&#41; &quot;${git}&quot; subtree &quot;$@&quot; ;;
      &#40;subta&#41; &quot;${self}&quot; subt add &quot;$@&quot; ;;
      &#40;subtph&#41; &quot;${self}&quot; subt push &quot;$@&quot; ;;
      &#40;subtpl&#41; &quot;${self}&quot; subt pull &quot;$@&quot; ;;

      &#40;subm&#41; &quot;${git}&quot; submodule &quot;$@&quot; ;;
      &#40;subms&#41; &quot;${self}&quot; subm status &quot;$@&quot; ;;
      &#40;submy&#41; &quot;${self}&quot; subm summary &quot;$@&quot; ;;
      &#40;submu&#41; &quot;${self}&quot; subm update &quot;$@&quot; ;;
      &#40;subma&#41; &quot;${self}&quot; subm add &quot;$@&quot; ;;
      &#40;submi&#41; &quot;${self}&quot; subm init &quot;$@&quot; ;;

      &#40;ref&#41; &quot;${git}&quot; reflog &quot;$@&quot; ;;

      &#40;de&#41; &quot;${git}&quot; describe &quot;$@&quot; ;;
      &#40;det&#41; &quot;${self}&quot; de --tags &quot;$@&quot; ;;

      &#40;&#42;&#41; &quot;${git}&quot; &quot;${op}&quot; &quot;$@&quot; ;;
    esac
  fi
}
</code></pre><p>Mi devas mencii, ke se la funkcion supre ni jam havas en nia ŝela agordo kaj la jenan alinomon ni havas en <code>&#126;/.gitconfig</code>:</p><pre><code>&#91;alias&#93;
  ls = &quot;! echo hello world&quot;
</code></pre><p>tiam la jenan komandon ni rulos</p><pre><code>git ls</code></pre><p>aperos la listoj de dosieroj administritaj de git, anstataŭ la teksto <code>hello world</code> sur la ekrano.</p><h2><a name="finrimarkoj">Finrimarkoj</a></h2><p>Do, per tiu funkcio, mi povas labori per gito pli facile tial, ke mi nur devas pensi pli la mallongigoj. Krome aliron al miaj aliaj ŝelaj komandoj mi havas. Pro tio ke je <a href='/eo/timukso/'>tmux</a> mi uzas, kiam ajn giton mi bezonas uzi, klavkombinon por la malfermado de alia tmux-fenestro sube mi nur devas premi. Tie, tiujn gitkomandojn mi povas facile sen la ŝanĝon de ekranvido kiun Magit bedaŭrinde faras. Min ĝi ebligas por pensi aparte inter la kodo kaj la administrado de la kodo mem.</p><hr/><div class="footer"><p><div class="text-small"> <a href='/eo/'>Hejmo</a> • <a href='/eo/pri/'>Pri</a> • <a href='/eo/citajxoj/'>Citaĵoj</a> • <a href='/eo/pripensoj/'>Pripensoj</a> </div></p><p><div class="text-x-small"> Kreita per ❤️ de Rommel Martínez </div></p><p></div></p></div><script src="/static/js/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>