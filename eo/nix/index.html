<!DOCTYPE html>
<html lang="eo"><head><title>Milda Enkonduko al la Nix-Familio</title><meta charset="utf-8" /><meta content="width=device-width,initial-scale=1.0,user-scalable=yes" name="viewport" /><meta content="noodp,noydir" name="robots" /><link rel='apple-touch-icon' sizes='180x180' href='/images/ico/apple-touch-icon.png'><link rel='icon' type='image/png' sizes='32x32' href='/images/ico/favicon-32x32.png'><link rel='icon' type='image/png' sizes='16x16' href='/images/ico/favicon-16x16.png'><link rel='manifest' href='/images/ico/site.webmanifest'><link rel='mask-icon' href='/images/ico/safari-pinned-tab.svg' color='#5bbad5'><link rel='shortcut icon' href='/images/ico/favicon.ico'> <meta name='msapplication-TileColor' content='#da532c'> <meta name='msapplication-config' content='/images/ico/browserconfig.xml'> <meta name='theme-color' content='#ffffff'><meta content="Milda Enkonduko al la Nix-Familio" name="description" /><meta content="nix, nixos, nixpkgs, enkonduko, gvidilo, linukso, makintoŝo, makintosxo, unikso, nix-surmetoj, surmetoj" name="keywords" /><meta content="Milda Enkonduko al la Nix-Familio" property="og:title" /><meta content="article" property="og:type" /><meta content="https://ebzzry.com/eo/nix/" property="og:url" /><meta content="https://ebzzry.com/images/ico/android-chrome-512x512.png" property="og:image" /><style media="all" type="text/css">html {    color: #333;    font-size: 1em;    font-family: Georgia, Cambria, Palatino, "Palatino Linotype", "Times New Roman", Times, serif;    line-height: 1.45;    text-align: left:    width: 100%;    max-width: 40em;    margin: 0 auto 0 auto;    padding: 0;}body {    border-top: hidden;    border-bottom: hidden;    padding: 0 1.5em 1em 1.5em;    margin: 0;}#content {    -webkit-column-count: 1;    -moz-column-count: 1;    column-count: 1;}code {    font-size: 0.9em;    font-family: "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Lucida Console", "Courier New", Courier, monospace;    color: black;    display: inline-block;}pre code {    font-size: 1em;    font-family: monospace;    line-height: 1.3em;    overflow: auto;    font-weight: normal;}kbd {    font-size: 1.1em;    padding: 0.1em 0.6em;    border: 1px solid #ccc;    font-family: monospace;    background-color: #f7f7f7;    color: #333;    -moz-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    -webkit-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    -moz-border-radius: 3px;    -webkit-border-radius: 3px;    border-radius: 3px;    display: inline-block;    margin: 0 0.1em;    text-shadow: 0 1px 0 #fff;    white-space: nowrap;}h1, h2, h3, h4, h5, h6 {    font-family: Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans", Tahoma, Geneva, Helvetica, Arial, sans-serif;    margin-bottom: 0;}h1 {    font-size: 2.5em;    text-align: center;    border-bottom: 6px solid black;}h2 {    font-size: 2.0em;    text-align: left;    border-bottom: 2px solid black;}h3 {    font-size: 1.6em;    text-align: left;    border-bottom: 1px solid lightgrey;}h4 {    font-size: 1.5em;    text-align: left;}h5 {    font-size: 1.3em;    text-align: left;}ul, ol {    padding-left: 2em;}ul li {    list-style-type: square;}ul li li {    list-style-type: disc;}ul li li li {    list-style-type: circle;}ol li {    list-style-type: decimal;}p, para, b, strong, i, em, emph {    font-size: 1em;}blockquote {    font-size: 1.2em;    font-style: italic;    margin-left: 2em;}b, strong {    font-weight: bold;}i, em, emph {    font-style: italic;}table {    margin: 0.5em;    border-spacing: 0;    border-collapse: collapse;}th, td {    border: 1px solid lightgray;    padding-top: 0;    padding-bottom: 0;    padding-left: 0.45em;    padding-right: 0.45em;}.text-right {    text-align: right;}.text-small {    font-size: small;}.text-x-small {    font-size: x-small;}.banner {    display: block;    width: 100%;    margin-left: auto;    margin-right: auto;}.footer {    text-align: right;    float: right;    max-width: 18em;}.cc {    border-width: 0}.center {    text-align: center;}</style><style media="all" type="text/css">/* Ewan Themes -- based 99.99% from Tomorrow Night Theme *//* http://jmblog.github.com/color-themes-for-google-code-highlightjs *//* Original theme - https://github.com/chriskempson/tomorrow-theme *//* http://jmblog.github.com/color-themes-for-google-code-highlightjs *//* Tomorrow Comment */.hljs-comment {  color: #969896;}/* Tomorrow Red */.hljs-variable,.hljs-attribute,.hljs-tag,.hljs-regexp,.ruby .hljs-constant,.xml .hljs-tag .hljs-title,.xml .hljs-pi,.xml .hljs-doctype,.html .hljs-doctype,.css .hljs-id,.css .hljs-class,.css .hljs-pseudo {  color: #cc6666;}/* Tomorrow Orange */.hljs-number,.hljs-preprocessor,.hljs-pragma,.hljs-built_in,.hljs-literal,.hljs-params,.hljs-constant {  color: #de935f;}/* Tomorrow Yellow */.ruby .hljs-class .hljs-title,.css .hljs-rule .hljs-attribute {  color: #f0c674;}/* Tomorrow Green */.hljs-string,.hljs-value,.hljs-inheritance,.hljs-header,.hljs-name,.ruby .hljs-symbol,.xml .hljs-cdata {  color: #b5bd68;}/* Tomorrow Aqua */.hljs-title,.css .hljs-hexcolor {  color: #8abeb7;}/* Tomorrow Blue */.hljs-function,.python .hljs-decorator,.python .hljs-title,.ruby .hljs-function .hljs-title,.ruby .hljs-title .hljs-keyword,.perl .hljs-sub,.javascript .hljs-title,.coffeescript .hljs-title {  color: #81a2be;}/* Tomorrow Purple */.hljs-keyword,.javascript .hljs-function {  color: #b294bb;}.hljs {  display: block;  overflow-x: auto;  background: #1d1f21;  color: #c5c8c6;  padding: 0.5em;  -webkit-text-size-adjust: none;}.coffeescript .javascript,.javascript .xml,.tex .hljs-formula,.xml .javascript,.xml .vbscript,.xml .css,.xml .hljs-cdata {  opacity: 0.5;}pre code {    font-size: 1.1em;    font-family: monospace;    line-height: 1.3em;    overflow: auto;}</style></head><body><div id="content"><h1>Milda Enkonduko al la Nix-Familio</h1><p><div class="center"><a href='/en/nix/'>English</a> • Esperanto</div> <div class="center">lun sep 17 22:50:53 2018 +0800</div></p><blockquote><p>Ne maltrankviliĝu pri tio, kion la aliaj faros. La plej bona maniero por antaŭdiri la estontecon estas por eltrovi ĝin.<br>—Alan KAY </p></blockquote><p><img src="/images/site/wallhaven-751942-1008x250.webp" style="display: block; width: 100%; margin-left: auto; margin-right: auto;" alt="wallhaven-751942" title="wallhaven-751942"/></p><h2><a name="et">Enhavotabelo</a></h2><ul><li><a href='#enkonduko'>Enkonduko</a></li><li><a href='#nixos'>NixOS</a><ul><li><a href='#nixosinstalo'>Instalo</a><ul><li><a href='#nixossxalti'>Ŝalti la maŝinon</a></li><li><a href='#nixosreto'>Agordi la reton</a></li><li><a href='#nixosdiskoj'>Pretigi la diskojn</a></li><li><a href='#nixosinstali'>Instali al disko</a></li></ul></li><li><a href='#nixosagordajxo'>Agordaĵo</a></li></ul></li><li><a href='#nix'>Nix</a><ul><li><a href='#nixsignovicoj'>Signovicoj</a></li><li><a href='#nixnombroj'>Nombroj</a></li><li><a href='#nixbuleaj'>Buleaj valoroj</a></li><li><a href='#nixlistoj'>Listoj</a></li><li><a href='#nixaroj'>Aroj</a></li><li><a href='#nixdosierindikoj'>Dosierindikoj</a></li><li><a href='#nixfunkcioj'>Funkcioj</a></li><li><a href='#nixlet'>Let</a></li><li><a href='#nixwith'>With</a></li><li><a href='#nixkondicxesprimoj'>Kondiĉesprimoj</a></li><li><a href='#nixdosierenportoj'>Dosierenportoj</a></li></ul></li><li><a href='#nixpkgs'>Nixpkgs</a><ul><li><a href='#nixpkgsinstalo'>Instalo</a></li><li><a href='#nixpkgsuzado'>Uzado</a><ul><li><a href='#nixpkgsgito'>Gito</a></li><li><a href='#nixpkgskanaloj'>Kanaloj</a></li><li><a href='#nixpkgsaliaj'>Aliaj komandoj</a></li></ul></li><li><a href='#nixpkgsagordajxo'>Agordaĵo</a></li><li><a href='#nixpkgskontribui'>Kontribui</a><ul><li><a href='#nixpkgsgxisdatigi'>Ĝisdatigi ekzistantan pakon</a></li><li><a href='#nixpkgssendi'>Sendi novan pakon</a></li></ul></li><li><a href='#nixpkgsnotoj'>Notoj</a></li></ul></li><li><a href='#medioj'>Medioj</a><ul><li><a href='#sistemmedio'>Sistemmedio</a></li><li><a href='#uzantmedio'>Uzantmedio</a></li><li><a href='#programadmedio'>Programadmedio</a></li></ul></li><li><a href='#surmetoj'>Surmetoj</a><ul><li><a href='#surmetojtranspasoj'>Transpasoj</a></li><li><a href='#surmetojnovajpakoj'>Novaj pakoj</a></li></ul></li><li><a href='#finrimarkoj'>Finrimarkoj</a></li><li><a href='#bonifiko'>Bonifiko</a></li></ul><h2><a name="enkonduko">Enkonduko</a></h2><p>Venas rare ideoj kiuj povas ŝanĝi la metodoj por komputado. Multe da teĥnologio kiujn ni uzas nune estas nur ripetoj de la malnovaj—niveloj sur niveloj de kosmetikoj kiuj ĉirkaŭkovras la malnovajn konceptojn. Plenaj produktaj sistemoj baziĝas ĉe ĉi tiu manko de kreemo kaj lerteco. Malnovaj problemoj ne solviĝas. Pentrante per novaj kolortonoj, ĉi tiuj tielnomataj elpensemaj solvoj nure ĉirkaŭigas la problemojn anstataŭe, pretendante ke almenaŭ, ili plikolorplenigis ĝin. Ĉi tiu mensostato difektas progreson en nekalkuleblaj manieroj. Ĉi tio donas la falsan impreson, ke la solvoj fakte estas faritaj. Ĉi tio kreas Falsan senson de plibonigo.</p><p>Antaŭ multaj jaroj <a href='https://nixos.org/~eelco/'>Eelco DOLSTRA</a> skribis siajn influegjan <a href='https://nixos.org/~eelco/pubs/'>paperojn</a>, en kiu, li priskribis la radikalajn manierojn por disponigi programaron. Tiuj paperoj formis la kernojn de <a href='https://nixos.org/nix/'>Nix</a>—pure funkcia paka administrila lingvo kiu solvis la malsanon kiu delonge plagis la informadikon—kompatinda paka administrado. En ĉi tiu artikolo mi parolos pri la Nix-familio, kaj kiel uzi ĝin por la avantaĝo.</p><p>Uziĝos la dolarsigno ($) por indiki la ŝelan inviton de la normuzanto indiki, uziĝos la kradsigno (#) por indki la ŝelan inviton de la ĉefuzanto. Estas fojoj kiam la <a href='https://en.wikipedia.org/wiki/User_identifier#Effective_user_ID'>EUID</a> de komando estas nulo (0) pro la uzo de <em>sudo</em>.</p><h2><a name="nixos">NixOS</a></h2><p>Kiom da fojoj, oni havadis difektitan sistemon pro oni ĝistadigis programaron kiun aliaj komponantoj dependis? Kiom da malfruaj noktoj oni pasis por ripari apon ĉar la nova pako kiun oni instalis rompigis ĝin? Kiom da fojoj, pro ĉagrenego, oni rezignis pri la riparado de la sistemo kaj simple decidis por reinstali la sistemon de nulo. Facilas restaŭri datumdosierojn. Restaŭri sistemagordon de la lasta funkcia stato, bedaŭrinde, estas unudirekta bileto al geheno.</p><p><a href='https://nixos.org'>NixOS</a> (niks-oŭ-es) estas linuksa distribuo kiu solvas ĉi tiajn problemojn per ekspluati la determinismon de <a href='https://nixos.org/nix'>Nix</a> kaj per uzi unu deklaran agorddosieron kiu tenas ĉiomajn agordaĵojn kaj alĝustigilojn tenas en unu loko—<code>/etc/nixos/configuration.nix</code>. Ĉi tiu dosiero enhavas informon pri la dosiersistemo, uzantoj, servoj, retagordo, enigaparatoj, kernaj parametroj, kaj pli . Signifas, ke oni povas preni <i>configuration.nix</i> de iu kaj havi ĝian ekzaktan sistemagordon! En NixOS oni ne plu bezonas ludi pri la tutsistemo por la agordo kiun oni deziras. Oni ne plu uzas porokazajn solvojn por specifi deziratan agordan staton. Oni ne plu bezonas instali aldonan programaron por administri sistemagordon.</p><p>NixOS ne konformiĝas al <a href='https://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard'>FHS</a>, malebligante aldonan cerban damaĝon efektive. Tio donas al mi spacon por multe da flekso kaj eltrovemo. Ĝi ne havas <code>/usr/</code> kaj <code>/opt/</code>. Tamen, ĝi havas<code>/bin/</code> kaj je <code>/usr/bin/</code>, kiuj havas nur <code>sh</code> kaj <code>env</code> respektive—ambaŭ fakte estas simbolligiloj al la realaj programoj kiuj loĝas ie en <code>/nix/store/</code>. La supra loko por sistemprogramoj—tiuj, kiuj estas instalitaj specife de la sistemestro—lokiĝas en <code>/run/current-system/sw/bin/</code> kaj <code>/run/current-system/sw/sbin/</code>. Uzantinstalitaj programoj, aliflanke, troveblas en siaj respektivaj <code>&#126;/.nix-profile/bin/</code>-lokoj. Ĉi tiuj lokoj ne povas ŝanĝiĝi per kutimaj manieroj; dediĉitaj programoj devas esti uzataj por skribi al ĉi tiuj arboj.</p><h3><a name="nixosinstalo">Instalo</a></h3><p>Instalo de NixOS simplas. Por «nudmetalaj» sistemoj, elŝutu la instalilon el <a href='https://nixos.org/download/'>nixos.org/download</a>. Virtualmaŝinaj diskbildoj ankaŭ haveblas de tiu paĝo. De mia lasta instalo, mi instalis per la jena agordo:</p><ul><li><a href='https://en.wikipedia.org/wiki/Unified_Extensible_Firmware_Interface'>UEFI</a></li><li>USB-praŝargo</li><li>Vifia konekto</li><li><a href='https://en.wikipedia.org/wiki/GUID_Partition_Table'>GUID-subdiska tabelo (GPT)</a></li><li><a href='https://en.wikipedia.org/wiki/Linux_Unified_Key_Setup'>LUKS</a> super <a href='https://en.wikipedia.org/wiki/Logical_volume_management'>LVM</a></li></ul><h4><a name="nixossxalti">Ŝalti la maŝinon </a></h4><p>Praŝargu per la USB-poŝmemorilo en UEFI-reĝimo. Ĉe la ensaluta invito, ensalutu kiel <code>root</code>.</p><h4><a name="nixosreto">Agordi la reton</a></h4><p>Skanu haveblajn retojn:</p><pre><code># nmcli d wifi list</code></pre><p>Tiam, konektu al la preferata enkursigilo:</p><pre><code># nmcli d wifi con ENKURSIGILO name NOMO password PASVORTO</code></pre><h4><a name="nixosdiskoj">Pretigi la diskojn </a></h4><p>Kreu la subdiskojn:</p><pre><code># gdisk /dev/sda
sda1: EF00 &#40;EFI system&#41;, 512 MiB
sda2: 8E00 &#40;Linux LVM&#41;, ceteraj</code></pre><p>Strukturu <code>/dev/sda1</code>:</p><pre><code># mkfs.vfat -F 32 /dev/sda1</code></pre><p>Kreu la fizikan volumon:</p><pre><code># pvcreate /dev/sda2</code></pre><p>Kreu la voluman grupon:</p><pre><code># vgcreate vg /dev/sda2</code></pre><p>Kreu la logikajn volumojn:</p><pre><code># lvcreate -L 20G -n swap vg
# lvcreate -l 100%FREE -n root vg</code></pre><p>Ĉifru la radikon:</p><pre><code># cryptsetup luksFormat /dev/vg/root
# cryptsetup luksOpen /dev/vg/root root</code></pre><p>Strukturu la radikon:</p><pre><code># mkfs.ext4 -j -L root /dev/mapper/root</code></pre><p>Strukturu la permutodosieron:</p><pre><code># mkswap -L swap /dev/vg/swap</code></pre><p>Surmetu la dosiersistemojn:</p><pre><code># mount /dev/mapper/root /mnt
# mkdir /mnt/boot
# mount /dev/sda1 /mnt/boot</code></pre><p>Ŝaltu la permutodosieron:</p><pre><code># swapon /dev/vg/swap</code></pre><h4><a name="nixosinstali">Instali al disko</a></h4><p>Kreu la bazagorddosieron:</p><pre><code># nixos-generate-config --root /mnt</code></pre><p>Redaktu la agorddosieron:</p><pre><code># nano /mnt/etc/nixos/configuration.nix</code></pre><p>Por plifaciligi la procedon, oni povas uzi la malpligrandigitan version de <a href='https://github.com/ebzzry/dotfiles/blob/main/nixos/configuration.nix'>mia agorddosiero</a>. Kaj sekve, anstataŭigu la valorojn laŭplaĉe. Haveblas ĉiom da agordaj alĝustigiloj <a href='https://nixos.org/nixos/options.html'>ĉi tie</a>.</p><pre><code class="nix">{ config, lib, pkgs, ... }:

{
  imports = &#91;
      ./hardware-configuration.nix
  &#93;;

  boot = {
    loader = {
      systemd-boot.enable = true;
      efi.canTouchEfiVariables = true;
    };

    initrd.availableKernelModules = &#91;
      &quot;xhci&#95;pci&quot;
      &quot;ehci&#95;pci&quot;
      &quot;ahci&quot;
      &quot;usb&#95;storage&quot;
      &quot;sd&#95;mod&quot;
      &quot;rtsx&#95;pci&#95;sdmmc&quot;
    &#93;;

    initrd.luks.devices = &#91;
      {
        device = &quot;/dev/vg/root&quot;;
        name = &quot;root&quot;;
        preLVM = false;
      }
    &#93;;

    cleanTmpDir = true;
  };

  fileSystems = &#91;
    {
      device = &quot;/dev/disk/by-uuid/6106-6BF8&quot;;
      fsType = &quot;vfat&quot;;
      mountPoint = &quot;/boot&quot;;
    }

    {
      device = &quot;/dev/mapper/root&quot;;
      fsType = &quot;ext4&quot;;
      mountPoint = &quot;/&quot;;
    }
  &#93;;

  swapDevices = &#91;
    {
      device = &quot;/dev/vg/swap&quot;;
    }
  &#93;;

  networking = {
    hostName = &quot;ombrelo&quot;;
    hostId = &quot;7B1548AE&quot;;
    enableIPv6 = true;
    networkmanager.enable = true;
  };

  environment = {
    systemPackages = with pkgs; &#91; zsh &#93;;
  };

  time.timeZone = &quot;Asia/Manila&quot;;

  security.sudo = {
    enable = true;
    configFile = ''
      Defaults env&#95;reset
      root ALL = &#40;ALL:ALL&#41; ALL
      %wheel ALL = &#40;ALL&#41; SETENV: NOPASSWD: ALL
    '';
  };

  services = {
    xserver = {
      autorun = true;
      defaultDepth = 24;
      enable = true;
      displayManager.kdm.enable = true;
      desktopManager.kde5.enable = true;
      videoDrivers = &#91; &quot;intel&quot; &#93;;
    };
  };

  users = {
    extraUsers.vakelo = {
      isNormalUser = true;
      uid = 1000;
      extraGroups = &#91; &quot;wheel&quot; &quot;networkmanager&quot; &quot;docker&quot; &#93;;
    };
    defaultUserShell = &quot;/run/current-system/sw/bin/zsh&quot;;
  };
}
</code></pre><p>Se oni preterpasis la paŝon <code>nixos-generate-config</code> ĉi-supre, kreu la antaŭproduktan dosieron permane:</p><pre><code># mkdir -p /mnt/etc/nixos</code></pre><p>Oni povas konservi la ĉi-supran dosieron per:</p><pre><code># curl -sSLo /mnt/etc/nixos/configuration.nix https://goo.gl/ZTQcGs</code></pre><p>Haveblas pli longa versio per:</p><pre><code># curl -sSLo /mnt/etc/nixos/configuration.nix https://goo.gl/K4P7l5</code></pre><p>Anstataŭigu la UUID-identigilon de la disko per tiu, kiun oni havas. Uzu La komandon <code>blkid</code> por akiri la UUID-identigilojn. Por la valoro de <code>networking.hostID</code> uzu la jenan komandon:</p><pre><code># cksum /etc/machine-id | while read c rest; do printf &quot;%x&quot; $c; done</code></pre><p>La ĉi-supra agordo precizigas la jenan, inter aliaj aferoj:</p><ul><li>Krei uzanton <code>vakelo</code> kun tuta <i>sudo</i>-kapablo;</li><li>Uzi KDE5 kiel la fenestrilo;</li><li>Ŝalti sekurŝelon; kaj</li><li>Specifi la LUKS-parametrojn.</li></ul><p>Instalu NixOS al la disko:</p><pre><code># nixos-install</code></pre><p>Tio komando analizas <code>/etc/nixos/configuration.nix</code> , asekurante, ke ne estas eraroj. Tiu komando elŝutos ĉiom da necesaj pakojn por kongrui al la specifo .</p><p>Post kiam la instalo finiĝis, repraŝargu la sistemon:</p><pre><code># reboot</code></pre><h3><a name="nixosagordajxo">Agordaĵo</a></h3><p>Instalinte, ĝisdatigi la ekzistantan agordaĵon facilas. Ĉio kion oni devas fari estas redakti la agorddosieron tiam rekunmetu la sistemon:</p><pre><code># nano /etc/nixos/configuration.nix
# nixos-rebuild switch</code></pre><p>Se okazis eraro, la sistemo sciigos onin pri tio, anstataŭ pluigi per malĝusta agordo. Post kiam la sistemo finfaris reŝargi, iru al la konzolo per <kbd>Ctrl+Alt+F1</kbd>, tiam ensalutu kiel <code>root</code>, tiam agordu pasvorton por la uzanto kiun ni specifis en <code>configuration.nix</code>:</p><pre><code># passwd vakelo</code></pre><p>Eliru de la ŝelo, tiam iru al la grafika fasado per <kbd>Alt+F7</kbd>, tiam ensalutu kiel <code>vakelo</code>.</p><h2><a name="nix">Nix</a></h2><p>La komponanto kiu la fondas koron de NixOS kaj Nixpkgs estas la <a href='https://nixos.org/nix'>Nix</a>-lingvo. Ĝi estas deklarlingvo kreita por administri pakojn.</p><p>Por ke oni facile povu kompreni la lingvon, ni rulu <code>nix repl</code>:</p><pre><code>$ nix repl</code></pre><p>Sekve, ni rulu ĝin. Oni salutiĝas per la versinombro, kaj la invito de nix-repl. Skribante ĉi tiun artikolon, la plej ĵusa stabila versinombro estas 2.4:</p><pre><code class="nix">Welcome to Nix 2.4. Type :? for help.

nix-repl&gt;
</code></pre><p>Ni elprovu bazajn esprimojn.</p><h3><a name="nixsignovicoj">Signovicoj</a></h3><p>Samkiel en aliaj lingvoj, signovicoj taksas al si mem:</p><pre><code class="nix">nix-repl&gt; &quot;hundo&quot;
&quot;hundo&quot;
</code></pre><p>Por kunmeti signovicojn, uzu la operacisimbolon <code>+</code>:</p><pre><code class="nix">nix-repl&gt; &quot;hundo&quot; + &quot;kato&quot;
&quot;hundokato&quot;
</code></pre><p>Alia maniero por deklari signovicojn, estas por uzi du parojn de unuoblaj citiloj. Ne konfuziĝu pri ĝi kontraste de la duoblaj citiloj:</p><pre><code class="nix">nix-repl&gt; ''hundo kato''
&quot;hundo kato&quot;
</code></pre><p>La avantaĝo de uzi <code>''</code> anstataŭ <code>&quot;</code>, estas ĝi permesas la ĉeeston de <code>&quot;</code> ene ĝi:</p><pre><code class="nix">nix-repl&gt; ''&quot;hundo&quot; &quot;kato&quot;''
&quot;\&quot;hundo\&quot; \&quot;kato\&quot;\&quot;
</code></pre><p>La valoro kiun ĝi revenas estos ĝuste citita. Ĉi tio utilas poste kiam ni muntos pli komplikajn esprimojn.</p><p>Por elreferenci signovicojn ene signovicoj, uzu la formon <code>${name}</code>:</p><pre><code class="nix">nix-repl&gt; x = &quot;hundo&quot;

nix-repl&gt; y = &quot;kato&quot;

nix-repl&gt; &quot;${x} ${y}&quot;
&quot;hundo kato&quot;

nix-repl&gt; ''${x} ${y}''
&quot;hundo kato&quot;
</code></pre><h3><a name="nixnombroj">Nombroj</a></h3><p>Bazaj aritmetikaj operacioj en Nix estas inkluzivitaj kun malgranda surprizo:</p><pre><code class="nix">nix-repl&gt; 6+2
8

nix-repl&gt; 6-2
4

nix-repl&gt; 6&#42;2
12

nix-repl&gt; 6/2
/home/vakelo/6/2
</code></pre><p>Ho! Tio ne estis, kion ni anticipis. Pro tio ke Nix estas desegnitaj kun dosieroj kaj dosierujoj, ĝi kreis specialan kazon, ke kiam suprenstreko (/) signo estas ĉirkaŭitaj per nespacetaj signoj, ĝi interpretas ĝin kiel dosierujindiko, rezultonte al absolutdosierindiko. Por fari dividon efektive, aldonu almenaŭ unu spaceton antaŭ kaj post la <code>/</code> signo:</p><pre><code class="nix">nix-repl&gt; 6 / 2
3
</code></pre><p>Parenteze, ne estas glitpunktoj en Nix. Do, se oni provas uzi ilin, oni akiros:</p><pre><code class="nix">nix-repl&gt; 1.0
error: syntax error, unexpected INT, expecting ID or OR&#95;KW or DOLLAR&#95;CURLY or '&quot;', at &#40;string&#41;:1:3
'&quot;'
</code></pre><p>La funkcio <code>builtins.div</code> faras la operacion de <code>/</code> esence:</p><pre><code class="nix">nix-repl&gt; builtins.div 6 3
2
</code></pre><p>La kontrasto tamen, estas, ke <code>builtins.div</code> povas esti aplikita parte:</p><pre><code class="nix">nix-repl&gt; &#40;builtins.div 6&#41;
«primop-app»
</code></pre><p>Tiu esprimo revenas fermon de parte aplikita funkco. Ni bezonas alian valoron por tute apliki ĝin:</p><pre><code class="nix">nix-repl&gt; &#40;builtins.div 6&#41; 3
2
</code></pre><p>Ni eĉ povas konservi la valoron de tiu parta esprimo :</p><pre><code class="nix">nix-repl&gt; d = builtins.div 6
</code></pre><p>La operacisimbolo <code>=</code> en Nix estas uzata por bindi valorojn. En ĉi tiu ekzemplo, ĝi estas uzita por difini partan aplikon. Por uzi tiun funkcion:</p><pre><code class="nix">nix-repl&gt; d 3
2
</code></pre><h3><a name="nixbuleaj">Buleaj valoroj</a></h3><p>Vereco kaj malvereco estas reprezentitaj de <code>true</code> kaj <code>false</code>:</p><pre><code class="nix">nix-repl&gt; 1 &lt; 2
true

nix-repl&gt; 1 &gt; 2
false

nix-repl&gt; 1 == 1
true

nix-repl&gt; &quot;hundo&quot; == &quot;hundo&quot;
true

nix-repl&gt; &quot;hundo&quot; &gt; &quot;kato&quot;
false

nix-repl&gt; false || true
true

nix-repl&gt; false &amp;&amp; true
false
</code></pre><h3><a name="nixlistoj">Listoj</a></h3><p>Listoj estas heterogenaj tipoj por enteni seriajn valorojn. Eroj estas apartigitaj per spacetoj:</p><pre><code class="nix">nix-repl&gt; &#91; 1 &quot;hundo&quot; true &#93;
&#91; 1 &quot;hundo&quot; true &#93;
</code></pre><p>Por listojn kunmeti:</p><pre><code class="nix">nix-repl&gt; &#91; 1 &quot;hundo&quot; true &#93; ++ &#91; false &#40;6 / 2&#41; &#93;
&#91; 1 &quot;hundo&quot; true false 3 &#93;
</code></pre><p>Por eltiri la kopon:</p><pre><code class="nix">nix-repl&gt; builtins.head &#40;&#91; 1 &quot;hundo&quot; true &#40;6 / 2&#41; &#93; ++ &#91; false &#40;6 / 2&#41; &#93;&#41;
1
</code></pre><p>Por eltiri la voston:</p><pre><code class="nix">nix-repl&gt; builtins.tail &#40;&#91; 1 &quot;hundo&quot; true &#40;6 / 2&#41; &#93; ++ &#91; false &#40;6 / 2&#41; &#93;&#41;
&#91; &quot;hundo&quot; true 3 false 3 &#93;
</code></pre><p>Listoj estas indeksitaj komence de <a href='https://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html'>0 (angle)</a>. Por akiri la 1-an eron, uzu la operatoron <code>builtins.elemAt</code>:</p><pre><code class="nix">nix-repl&gt; builtins.elemAt &#91; 1 &quot;hundo&quot; true &#93; 1
&quot;hundo&quot;
</code></pre><h3><a name="nixaroj">Aroj</a></h3><p>Grava datumstrukturo en Nix estas aroj. Ili estas paroj de ŝlosilvorto-valoro apartigitaj per punktokomoj:</p><pre><code class="nix">nix-repl&gt; { a = 0; b = &quot;kato&quot;; c = true; cx = &#40;6 / 2&#41;; }
{ a = 0; b = &quot;kato&quot;; c = true; cx = 3; }
</code></pre><p>Tio, kio igas arojn malsamaj konstraste de listoj, estas, ke eltiri valorojn el ili estas faritaj per nomi referencojn. Por eltiri la valoron de <code>b</code>, uzu la operacisimbolon <code>.</code>:</p><pre><code class="nix">nix-repl&gt; { a = 0; b = &quot;kato&quot;; c = true; cx = &#40;6 / 2&#41;; }.b
&quot;kato&quot;
</code></pre><p>kiu estas ekvivalenta al:</p><pre><code class="nix">nix-repl&gt; { a = 0; b = &quot;kato&quot;; c = true; cx = &#40;6 / 2&#41;; }.&quot;b&quot;
&quot;kato&quot;
</code></pre><p>Por elreferenci anon el tiu sama aro, uzu la ŝlosilvorton <code>rec</code>:</p><pre><code class="nix">nix-repl&gt; rec { a = 0; b = &quot;kato&quot;; c = true; cx = &#40;6 / 2&#41;; d = b; }.d
&quot;kato&quot;
</code></pre><h3><a name="nixdosierindikoj">Dosierindikoj</a></h3><p>En Nix ĉiom da dosierindikoj estas tradukitaj al absolutdosierindikoj. Se oni faras referencon al dosiero en la aktuala dosierujo:</p><pre><code class="nix">nix-repl&gt; ./hundo
/home/vakelo/hundo
</code></pre><p>Fariĝas absolutdosierindiko. Ĉi tio estas Bonafero™.</p><p>Simile, se oni faras referencon al relativdosierindiko ene absolutdosierindiko, ĝi ankoraŭ tradukiĝas al absolutdosierindiko.</p><pre><code class="nix">nix-repl&gt; /./hundo
/hundo
</code></pre><p>Notu, bedaŭrinde, ke dosierindikoj kiuj staras sole ne plaĉas al Nix:</p><pre><code class="nix">nix-repl&gt; /
error: syntax error, unexpected '/', at &#40;string&#41;:1:1

nix-repl&gt; ./
error: syntax error, unexpected '.', at &#40;string&#41;:1:1
</code></pre><h3><a name="nixfunkcioj">Funkcioj</a></h3><p>Ĉu eĉ ekzistas plezuro se ne estos verboj por uzi kun ĉi tiuj substantivoj? Funkcioj en Nix kunhavas similecojn al aliaj lingvoj, havante ĝiajn unikajn trajtojn.</p><p>Jen la bazformo de funkcio:</p><pre><code class="nix">nix-repl&gt; x: x
«lambda»
</code></pre><p>Tiu esprimo kreas sennoman funkcion kiu revenas sian argumenton—la <a href='https://en.wikipedia.org/wiki/Identity_function'>identa funkcio (angle)</a>. La dupunkto post la unua <code>x</code> montras, ke ĝi estas parametro al la funkcio, samkiel en <a href='/eo/lambdokalkulo/#funkcioj'>lambdokalkulo</a>. Aldone, la nomoj ne gravas pro <a href='https://eo.wikipedia.org/wiki/Lambda-kalkulo#%CE%B1-konverto'>alfa-ekvivalenteco</a>:</p><pre><code class="nix">nix-repl&gt; hundo-kato-muso: hundo-kato-muso
«lambda»
</code></pre><p>Tiuj funkcioj ne estas tre utilaj tial, ke ili ne estas kaptitaj por aplikado. Se oni volas ĝin, ekzemple, kun la argumento <code>&quot;hundo&quot;</code>, ni bezonas ĉirkaŭkovri ĝin per rondkrampoj:</p><pre><code class="nix">nix-repl&gt; &#40;x: x&#41; &quot;hundo&quot;
&quot;hundo&quot;
</code></pre><p>Por aldoni plian amuzon, ni nomu tiun funkcion:</p><pre><code class="nix">nix-repl&gt; idento = x: x
</code></pre><p>Bonege! Nun, ni apliku ĝin:</p><pre><code class="nix">nix-repl&gt; idento &quot;hundo&quot;
&quot;hundo&quot;
</code></pre><p>Ni kreu funkcion kiu postaldonas <code>&quot; ve&quot;</code> al sia enigo, tiam ni apliku ĝin:</p><pre><code class="nix">nix-repl&gt; ve = s: s + &quot; ve&quot;

nix-repl&gt; ve &quot;mi&quot;
&quot;mi ve&quot;
</code></pre><p>Por krei funkcion kiu akceptas alian argumenton, ni uzu la jenan formon:</p><pre><code class="nix">nix-repl&gt; ve = s: t: s + &quot; ve &quot; + t

nix-repl&gt; ve &quot;mi&quot; &quot;vi&quot;
&quot;mi ve vi&quot;
</code></pre><p>La modelo, estas, ke por aldoni aldonan parametron, uzu la formon <code>name: </code>.</p><p>Aroj, kiam uzitaj kun funkcioj, ŝaltas pliajn potencajn abstraktadojn. Ni povas doni aron kiel argumento al funkcio, kiu do uzos la datumon ene tiu aro:</p><pre><code class="nix">nix-repl&gt; anaso = { a, b }: x: a + &quot; &quot; + b + x
</code></pre><p>Tiu funkcio havas du parametrojn: <code>{ a, b }</code>—parametra specifo por aro kun du eroj, kaj <code>x</code>—kutima parametro. Memoru, ke parametra specifo ne estas veraro, sed nur maniero por kongrui la argumentojn; ĝi uzas komon kiel apartigilo de valoroj. Ene ĉi tiu funkcio la ni povas kombini enigojn per la operacisimbolon <code>+</code>. Por uzi ĉi tiun funkcion, ni uzu ĝin jene:</p><pre><code class="nix">nix-repl&gt; anaso { a = &quot;ve&quot;; b = &quot;mi&quot;; } &quot; anaso&quot;
&quot;ve mi anaso&quot;
</code></pre><p>Kiam funkcio deklaras aron kiel sia parametro, oni devas specifi la ŝlosilvortojn kiam invoki la funkciojn kiu uzas ilin. Tiukaze, la nomoj de sa ŝlosilvortoj estas <code>a</code> kaj <code>b</code>:</p><p>La difino de <code>anaso</code> supre estas semantike simila al:</p><pre><code class="nix">nix-repl&gt; anaso = ve: x: ve.a + &quot; &quot; + ve.b + x
</code></pre><p>Ni uzis kutiman, ne-aran parametron ĉi tie por ke ĝi povu referenci al la aro kiel valoro. Rimarku ĉi tion:</p><pre><code class="nix">nix-repl&gt; ve = { a = &quot;hundo&quot;; b = &quot;kato&quot;; }

nix-repl&gt; ve.a
&quot;hundo&quot;
</code></pre><p>Ankaŭ eblas por specifi la implicitajn valorojn. Kiam parametro kun implicita valoro ne estas uzita, la implicita valoro estos uzita. Simile, en Komunlispo:</p><pre><code class="lisp">&#42; &#40;defun birdo &#40;a &amp;optional &#40;b &quot;O.o&quot;&#41;&#41;
    &#40;concatenate 'string a b&#41;&#41;

&#42; &#40;birdo &quot;o.O &quot;&#41;

&quot;o.O O.o&quot;
&#42; &#40;birdo &quot;o.O &quot; &quot;&#94;&#95;&#94;&quot;&#41;

&quot;o.O &#94;&#95;&#94;&quot;
</code></pre><pre><code class="nix">nix-repl&gt; birdo = { a, b ? &quot;O.o&quot; }: a + b

nix-repl&gt; birdo { a = &quot;oro&quot;; }
&quot;oroO.o&quot;

nix-repl&gt; birdo { a = &quot;oro&quot;; b = &quot;argxento&quot;; }
&quot;oroargxento&quot;
</code></pre><p>Por aldoni plian flekson, Nix subtenas la uzon de pseŭdo-«rest» argumentoj. Ni modifu La funkcion ĉi-supre:</p><pre><code class="nix">nix-repl&gt; birdo = { a, b, ...}: a + b
</code></pre><p>Ĝin ni uzu:</p><pre><code class="nix">nix-repl&gt; birdo { a = &quot;ve&quot;; b = &quot;hundo&quot;; }
&quot;vehundo&quot;
</code></pre><p>Estas same. Do kiel ni povas uzi tiun flekson? Ni kreos etikodon por la atribuaro por ke ni povu referenci al la ‹ekstraj› valoroj:</p><pre><code class="nix">nix-repl&gt; birdo = atribuoj@{ a, b, ...}: a + b + atribuoj.c
</code></pre><p>Ni simple uzu ĝin kiel antaŭe, sed kun la uzado de la etikedo:</p><pre><code class="nix">nix-repl&gt; birdo { a = &quot;oro&quot;; b = &quot;argxento&quot;; c = &quot;bronzo&quot;; }
&quot;oroargxentobronzo&quot;
</code></pre><p>Mi diris «pseŭda» ĉar la valoro por <code>c</code> estis ankoraŭ postulita.</p><p>Implicitaj valoroj kaj variabla loknombro povas esti kunmetitaj:</p><pre><code class="nix">nix-repl&gt; birdo = atribuoj@{ a, b, c ? &quot;C&quot;, ... }: a + b + c + atribuoj.z

nix-repl&gt; birdo { a = &quot;A&quot;; b = &quot;B&quot;; z = &quot;Z&quot;; }
&quot;ABCZ&quot;

nix-repl&gt; birdo { a = &quot;A&quot;; b = &quot;B&quot;; c = &quot;x&quot;; z = &quot;Z&quot;; }
&quot;ABXZ&quot;

</code></pre><h3><a name="nixlet">Let</a></h3><p>La ŝlosilvorto <code>let</code> permesas onin por difini variablojn en lokamplekso. Ekzemple, por igi la identigilojn <code>x</code> kaj <code>y</code> videblaj nur en lokamplekso:</p><pre><code class="nix">nix-repl&gt; let x = &quot;hundo&quot;; y = &quot;kato&quot;; in x + anaso { a = &quot;ne&quot;; b = &quot;vere&quot;; } &quot;efektive&quot; + y
&quot;hundone vereefektivekato&quot;
</code></pre><p>Memoru la lastan <code>;</code> antaŭ la <code>in</code> ŝlosilvorto kiu iras kun <code>let</code>—ĝi markas la komencon de la korpo de <code>let</code>. La konstruo <code>let</code> kondutas simile al la ŝlosilvorto <code>let</code> troveblas en programlingvoj kiel Lispo kaj Haskelo.</p><h3><a name="nixwith">With</a></h3><p>La ŝlosilvorto <code>with</code> permesas onin por demeti arvalorojn en amplekso:</p><pre><code class="nix">nix-repl&gt; with { x = &quot;hundo&quot;; y = &quot;kato&quot;; }; anaso { a = y; b = x; } &quot; xyz&quot;
&quot;kato hundo xyz&quot;
</code></pre><p>Kio okazis ĉi tie, estas, ke senvualiĝis la valoroj en tiu aro por disponebligi ilin en la korpo de <code>with</code>.</p><h3><a name="nixkondicxesprimoj">Kondiĉesprimoj</a></h3><p>Kondiĉesprimoj estas faritaj per la ŝlosilvorto <code>if</code>. Ĝi havas similan formon de plimultaj lingvoj:</p><pre><code class="nix">nix-repl&gt; if true then &quot;true&quot; else &quot;false&quot;
&quot;true&quot;
</code></pre><p>Ĝi povas esti nestiĝita:</p><pre><code class="nix">nix-repl&gt; if false then &quot;true&quot; else if false then &quot;true&quot; else if false then &quot;true&quot; else &quot;false&quot;
&quot;false&quot;
</code></pre><h3><a name="nixdosierenportoj">Dosierenportoj</a></h3><p>La ideo de enporti dosierojn en Nix-esprimo estas subtile malsama kontraste de aliaj lingvoj. Enportoj en Nix estas intime rilata al aroj. Supozante, ke ni havas la dosieron <code>ve.nix</code> , kiu enhavas la jenan:</p><pre><code class="nix">let
  ve = x: x + &quot;ve&quot;;
in {
  ve = ve;
}
</code></pre><p>La <code>let</code>-esprimo bindas la saman <code>ve</code> al funkcio kiu akceptas unu argumenton. En la korpo de <code>let</code>, ĝi revenas aron kiu havas unu membron kun la nomo <code>ve</code>—tiu en la maldekstra parto de <code>=</code>. La valoro de ĉi tiu ano estas la funkcio kiun ni ĵus difinis. La grava koncepto por memorigi, estas, ke ĉi tiu <code>let</code>-esprimo revenas atribuaron .</p><p>Ni iru reen al la <a href='https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop'>REPL (angle)</a> por uzi ĉi tiun dosieron:</p><pre><code class="nix">nix-repl&gt; import ./ve.nix
{ ve = «lambda»; }
</code></pre><p>Ni denove vidas la lambdo-terminon. Sajnas, ke la nomo <code>ve</code>, ĉi tie, estas funkcio. Nun, kiel ni povas elreferenci ĉi tiun valoron? Ni uzu la operatoron <code>.</code>!</p><pre><code class="nix">nix-repl&gt; &#40;import ./ve.nix&#41;.ve &quot;hundo&quot;
&quot;hundove&quot;
</code></pre><p>Ni devis uzi rondkrampojn tial, ke ne ekzistas tia dosiero <code>ve.nix.ve</code> en la aktuala dosierujo. Se ni trapasos ĝin, ĝi aperos jene:</p><pre><code class="nix">nix-repl&gt; { ve = «lambda»; }.ve &quot;hundo&quot;
</code></pre><p>fariĝos:</p><pre><code class="nix">nix-repl&gt; { ve = &#40;x: x + &quot;ve&quot;&#41;; }.ve &quot;hundo&quot;
&quot;hundove&quot;
</code></pre><p>La enkondukajn konceptojn de la Nix-lingvo ĉi tiu sekcio resumas. La ceteraj vilaj detaloj troveblas en la <a href='https://nixos.org/nix/manual/#ch-expression-language'>gvidilo</a>.</p><h2><a name="nixpkgs">Nixpkgs</a></h2><p>Nixpkgs (niks-pa-kej-ĝes) estas kolekto de pakoj organizitaj kaj administritaj per uzantoj tutmonde. Pro tio ke la fontkodo estas ĉe <a href='https://github.com/nixos/nixpkgs'>GitHub</a>, ĝi eblas ekspluati la avantaĝon de la potenca kunlaborada sistemo kiun tiu platformo ofertas. La <a href='https://nixos.org/nixos/packages.html'>kolekto</a> havas grandan vicaron da pakoj, de produktivecaj apoj al teoremaj pruviloj.</p><p>Plejparto de popularaj operaciumoj pakojn traktas bone, ĝis ili ne plu. Tiel longe kiel oni movas en rektan linion, sole, oni sekuras. Aferoj ŝanĝiĝas kiam aliaj homoj enkondukiĝas en la marŝado. Por ke la tutgrupo movu en unisono, ĉiuj devas esti konektitaj al unu la alia. Se ano decidas forvojaĝi, kaj sole marŝi, la tutgrupo kripliĝos. Tamen, se tiu ano decidas kloni ĝin por ke la forvojaĝado fariĝu sendependa, la originala marŝada grupo fariĝas neŝanĝita.</p><p>Ni traktu la kazon de distribuo celita kiel pluruzanta produkta programada medio. Kiam oni instalas fajrfokson versio 100, la ĉefa duuma dosiero iras al aŭ <code>/usr/bin/firefox</code> aŭ <code>/usr/local/bin/firefox</code>. Sekve, ĉiom da uzantoj povas aliri la apon el tiu dosierindiko; feliĉas Johano, Mario, kaj Petro. Bedaŭrinde, se Johano decidis aktualigi ĝin al versio 200, la sama apo kiun Mario kaj Petro uzas ankaŭ aktualiĝos! Tio ne estas bonafero se ili preferas la malnovan version kiu funkcias al ili! Nix permesas onin por havi plurajn versiojn de programaro sen kolizioj al la aliaj versioj. Johano, Mario, kaj Petro povas havi siajn preferatajn versiojn de fajrfokso sen konfliktoj al la aliaj versioj. Kiel Nixpkgs faras ĝin? Ĝi faras ĝin per nomi la komponantojn per iliaj kalkulitaj kontrolsumoj kaj per ne uzi komunan tutmondan lokon.</p><p>Ĉiom da uzantoj havas siajn proprajn versiojn de <code>&#126;/.nix-profile/</code> kaj ĉiom da enhavo de tiuj dosierujoj ne havas kutimajn dosierojn. Anstataŭ, ili estas simbolligiloj al la efektivaj dosieroj troveblas en <code>/nix/store/</code>. Ĉi tiu dosierujo, estas kie la programoj kaj siaj dependecoj estas efektive instalitaj. La nura maniero por skribi al tiu dosierujo estas per la dediĉitaj Nix-programoj. Ne estas maniero por rekte modifi tiun dosierujon per normaj manieroj. Do, kiam la uzanto <code>johano</code> instalas Vim 8, la programo fariĝas instalita kiel <code>/nix/store/w4cr4j13lqzry2b8830819vdz3sdypfa-vim-8.0.0329</code>. La signoj antaŭ la paknomo estas la kontrolsumo de ĉiom da enigoj kiuj estis uzitaj por konstrui la pakon. La dosiero <code>/home/johano/.nix-profile/bin/vim</code> tiam indikas al simbolligo, en dosiero troveblas en <code>/nix/store/</code> kiu kondukas al la efektiva Vim-duumdosiero en <code>/nix/store/w4cr4j13lqzry2b8830819vdz3sdypfa-vim-8.0.0329/bin/vim</code>.</p><h3><a name="nixpkgsinstalo">Instalo</a></h3><p>Se oni uzas NixOS, preterpasu ĉi tiun sekcion tial, ke Nixpkgs jam iras kun ĝi. Por instali Nixpkgs ĉe linukso aŭ makintoŝo, rulu:</p><pre><code>$ curl https://nixos.org/nix/install | bash</code></pre><p>Oni invitiĝos al la ensalutilojn por eniri ĉefuzantan aliron per <em>sudo</em> tial, ke ĝi instalos la risurcojn al <code>/nix/</code>. Post la instalo, oni petiĝas por aldoni linion de komando al la ŝela pravaloriza dosiero. Kiam oni generas novajn instancojn de la ŝelo la komandoj specifaj al Nix fariĝos haveblaj.</p><h3><a name="nixpkgsuzado">Uzado</a></h3><p>Estas du manieroj por instali pakojn per Nixpkgs: 1) uzi la gitan kopion, kiu estas la plej ĵusa versio, ĝisdatigita ĝis la lasta minuto, aŭ 2) uzi kanalojn. La <a href='https://github.com/nixos/nixpkgs'>gitdeponejo</a> estas ideala por uzantoj kiuj volas uzi la plej novajn versiojn de pako aŭ por uzantoj kiuj volas eltesti. <a href='https://nixos.org/channels/'>Kanaloj</a>, aliflanke, estas esence kopioj de la gitdeponejo en antaŭa tempo.</p><h4><a name="nixpkgsgito">Gito</a></h4><p>Okazas ofte ĝisdatigoj al la gitdeponejo. Legante ĉi tiun artikolon, <a href='https://github.com/nixos/nixpkgs/pulls/'>novaj ŝanĝoj</a> estas faritaj al la ĉefarbo. Por uzi la gitkopion, klonu la <a href='https://github.com/nixos/nixpkgs'>deponejon</a>:</p><pre><code>$ git clone https://github.com/nixos/nixpkgs &#126;/nixpkgs</code></pre><p>Tiu komando kreas dosierujon <code>nixpkgs/</code> sub la hejmdosierujo. Se la uzanto estas <code>vakelo</code>, la klono de la deponejo troveblas ĉe <code>/home/vakelo/nixpkgs/</code> aŭ <code>/Users/vakelo/nixpkgs/</code>, se oni uzas linukson aŭ makintoŝon respektive.</p><p>Por instali pakon, ekzemple, <em>emem</em>—markdaŭna- al HTML-dosiero konvertilo—per la gitkopio, rulu:</p><pre><code>$ nix-env -f &#126;/nixpkgs/default.nix -iA emem</code></pre><p>Tiu komando elŝutas <em>emem</em> kun ĝiajn dependecojn, kaj la programon ĝi disponebligas al oni. Por certigi, ke emem estas efektive instalita, rulu:</p><pre><code>$ emem --version</code></pre><p>Se la ŝelo ne vomiĝas kaj plendas, kaj oni vidas versinombron, do signifas ke oni sukcese instalis emem.</p><p>Por akiri la plej ĵusajn ŝanĝojn el la gitdeponejo, rulu:</p><pre><code>$ cd &#126;/nixpkgs &amp;&amp; git pull origin master</code></pre><h4><a name="nixpkgskanaloj">Kanaloj</a></h4><p>Instali pakojn per kanaloj pli agrablas tial, ke la komandoj por instali pakojn estas pli oportunaj. La kompromiso, estas, ke la pakoj estas malaktualaj de iom da tagoj. Se oni kontentas pri tio, do uzi kanalojn anstataŭ la gitkopion.</p><p>Kanaloj estas etikeditaj <code>stable</code>, <code>unstable</code>, aŭ per specifa versinombro, ekzemple, <code>18.09</code> aŭ <code>21.11</code>. Por ĉi tiu artikolo, ni uzu <code>unstable</code>—ĝi nek estas tiom malaktuala kiel <code>stable</code> nek tiom ĵuŝa kiel la gitkopio. Por aboni al la <code>unstable</code>-kanalo, rulu:</p><pre><code>$ nix-channel --add https://nixos.org/channels/nixpkgs-unstable nixpkgs</code></pre><p>Ĉi tio irprenas la kanalon etikedita <code>nixpkgs-unstable</code> el nixos.org, tiam instalos ĝin al la uzantprofilo.</p><p>Por esplori la listojn de kanaloj, iru <a href='https://nixos.org/channels/'>ĉi tien</a>.</p><p>Per la ekzemplo ĉi-supre, instali <em>emem</em>, rulu la jenajn komandojn por NixOS kaj aliaj sistemoj, respektive:</p><pre><code>$ nix-env -iA nixos.emem</code></pre><pre><code>$ nix-env -iA nixpkgs.emem</code></pre><p>Por ĝisdatigi la kanalojn, rulu:</p><pre><code>$ nix-channel --update</code></pre><p>Tempe, arboj en <code>/nix/store/</code> kreskiĝas kaj eble ekzistas dosierindikoj kiuj ne plu estas referencitaj per ajna pako. Por purigi ĝin, rulu:</p><pre><code>$ nix-collect-garbage</code></pre><h4><a name="nixpkgsaliaj">Aliaj komandoj</a></h4><p>Por malinstali pakon, rulu:</p><pre><code>$ nix-env -e emem</code></pre><p>Por listigi ĉiom da instalitaj pakoj, rulu:</p><pre><code>$ nix-env -q --installed</code></pre><p>Por listigi ĉiom da instaleblaj pakoj, rulu:</p><pre><code>$ nix-env -q --available</code></pre><h3><a name="nixpkgsagordajxo">Agordaĵo</a></h3><p>La dosiero <code>&#126;/.nixpkgs/config.nix</code> estas Nix-esprimo, kiu estas legita per la Nix-komandoj. Ene, oni povas specifi pakajn transpasojn—agordo kiu uzurpas implicitajn agordojn kaj aliajn alĝustigilojn, inkluzive, sed ne limigataj al, retumilaj kromprogramoj, grafikfasadoaj agordoj, SSL, ktp.</p><p>Ni rigardu malpligrandigitan version de mia <code>config.nix</code>:</p><pre><code>{ pkgs }:

{
  packageOverrides = pkgs: {
    emacs = pkgs.emacs.override {
      withGTK2 = false;
      withGTK3 = false;
      withxwidgets = false;
    };
  };

  firefox = {
    jre = true;
    enableGoogleTalkPlugin = true;
  };

  allowUnfree = true;
}
</code></pre><p>Tiu estas funkcio, kiu akceptas atribuon kiel parametro, kaj liveras alian atributaron kiel liveraĵo. Mia <i>config.nix</i> diras, ke mi ne volas havi GTK por emakso. Por fajrfokso, mi specifas, ke nur mi volas uzi JRE- kaj je Google Talk-kromprogramoj. Laste, mi specifas, ke programaroj kiuj ne havas malfermitkodajn permesilojn, aŭ programoj kiu ne havas la liberprogramaran modelon, mi volas esti kapablaj por instali</p><h3><a name="nixpkgskontribui">Kontribui</a></h3><p>La kunlaborada modelo de Nixpkgs restas ĉe gito kaj GitHub. Por kontribui pakon aŭ ĝisdatigi ekzistantan pakon, forku la <a href='https://github.com/nixos/nixpkgs/'>Nixpkgs</a>-deponejon al la propra GitHub-konto. Kreu novajn ŝanĝojn en nova branĉo, tiam kreu tirpeton.</p><h4><a name="nixpkgsgxisdatigi">Ĝisdatigi ekzistantan pakon</a></h4><p>Forkinte la deponejon, klonu la propran version de la deponejon:</p><pre><code>$ git clone git@github.com:vakelo/nixpkgs.git &#126;/nixpkgs</code></pre><p>Ĉi tiu komando kreas kopion de la forko en la radiko de la hejmdosierujo. Iru al tiu dosierujo, tiam la ni esploru la enhavojn :</p><pre><code class="bash">$ cd &#126;/nixpkgs
$ tree -aFL 1
.
├── COPYING
├── default.nix
├── doc/
├── .editorconfig
├── .git/
├── .github/
├── .gitignore
├── lib/
├── maintainers/
├── .mention-bot
├── nixos/
├── pkgs/
├── README.md
├── .travis.yml
├── .version
└── .version-suffix

7 directories, 9 files
</code></pre><p>Sekve, ni trovu pakon kie ĝi loĝas, ekzemple, <em>GNU Hello</em>.</p><pre><code>$ grep hello pkgs/top-level/all-packages.nix
  hello = callPackage ../applications/misc/hello { };</code></pre><p>Tio diras, ke la pako <em>hello</em> troveblas ĉe <code>../applications/misc/hello</code>. Rilate al la dosiero <code>all-packages.nix</code>, la dosierindiko estas ĉe <code>pkgs/applications/misc/hello</code> aŭ <code>&#126;/nixpkgs/pkgs/applications/misc/hello</code>. Ni iru tien:</p><pre><code>$ cd pkgs/applications/misc/hello
$ ls
default.nix</code></pre><p>Malfermu la dosieron <code>default.nix</code>:</p><pre><code class="nix">{ stdenv, fetchurl }:

stdenv.mkDerivation rec {
  name = &quot;hello-2.10&quot;;

  src = fetchurl {
    url = &quot;mirror://gnu/hello/${name}.tar.gz&quot;;
    sha256 = &quot;0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i&quot;;
  };

  doCheck = true;

  meta = {
    description = &quot;A program that produces a familiar, friendly greeting&quot;;
    longDescription = ''
      GNU Hello is a program that prints &quot;Hello, world!&quot; when you run it.
      It is fully customizable.
    '';
    homepage = http://www.gnu.org/software/hello/manual/;
    license = stdenv.lib.licenses.gpl3Plus;
    maintainers = &#91; stdenv.lib.maintainers.eelco &#93;;
    platforms = stdenv.lib.platforms.all;
  };
}
</code></pre><p>Tio diras al ni, ke la dosiero <code>default.nix</code>, estas dosiero kun parametro kiel atribuo kun du eroj. La funkcio liveras La rezulton de voki <code>stdenv.mkDerivation</code> per enigo de atribua valaro . La valoro por la atribuo <code>name</code> estas signovico kun la formato <em>paknomo-A.B.C</em>, en kiu, <em>paknomo</em> estas la nomo de la pako kaj <em>A.B.C.</em> estas la versinombro. La valoro por la atribuo <code>src</code> estas la valoro liverita per voki la funkcion <code>fetchurl</code>, per alia atribuara argumento. La valoro por la atribuo <code>url</code> devas esti aŭ spegula specifo, kiel priskribite en <code>pkgs/build-support/fetchurl/mirrors.nix</code>, aŭ kutima retejadreso. Tiukaze, ni uzis la GNU-spegulon kaj ni interpolis la variablon <code>name</code> ene tiu signovico. La valoro de la atribuo <code>sha256</code> estas tiu, kiun ni akiris per ruli <code>nix-prefetch-url</code> kontraŭ la retejadreso. Por akiri la kontrolsumon de <code>hello-2.10</code>, rulu:</p><pre><code class="bash">$ nix-prefetch-url http://ftpmirror.gnu.org/hello/hello-2.10.tar.gz
downloading ‘http://ftpmirror.gnu.org/hello/hello-2.10.tar.gz’... &#91;622/709 KiB, 64.6 KiB/s&#93;
path is ‘/nix/store/3x7dwzq014bblazs7kq20p9hyzz0qh8g-hello-2.10.tar.gz’
0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i
</code></pre><p>Ĝi kongruas al la SHA256-specifo ĉi-supre.</p><p>La atribuo <code>doCheck</code> instruas al Nix por ruli la testojn por ĉi tiu pako.</p><p>La valoro de la atribuo <code>meta</code> estas alia atribuara specifo por aliaj detaloj pri la pako. La valoroj specifitaj ĉi tie helpas Nix-programojn por klasi la pakon, inter aliaj aferoj. La mallonga signovico en atribuo <code>description</code> priskribas la celon de pako. La atribuo <code>longDescription</code> estas pli longa atribuo, eble plurlinia signovico por priskribi la pakon en pli da detalo. La atribuo <code>homepage</code> estas retejadreso al la retejo de la pako. Oni ne plu bezonas citi ĝin per unuoblaj aŭ duoblaj citiloj specife—ĝi faras ĝin interne. Oni ankoraŭ devas citi retejadreson se oni uzas variablan interpolado. La atribuo <code>platforms</code> estas grava: ĝi ordas pakon ĝuste—oni ne devas munti pakon ĉe makintoŝo kiu nur rulas ĉe linukso.</p><p>Se aperos nova versio de <em>GNU Hello</em>, ekzemple, versio 2.11, modifu la ĝustajn atribuojn. Tamen, unue, ni kreu apartan branĉon por tio:</p><pre><code>$ git checkout -b hello-2.11</code></pre><p>En <code>default.nix</code>, ŝanĝu la nomon al <code>hello-2.11</code> kaj ankaŭ ĝisdatigu la atribuon <code>sha256</code> . Kaj cetere, se oni estas ĉe NixOS, aldonu la jenan valoron al <code>/etc/nixos/configuration.nix</code>:</p><pre><code>nix.useSandbox = true;</code></pre><p>Se oni uzas alian linuksan sistemon aŭ oni uzas makintoŝon, aldonu la jenan al <code>/etc/nix/nix.conf</code>:</p><pre><code>build-use-sandbox = relaxed</code></pre><p>Tiam, muntu la pakon:</p><pre><code>$ cd &#126;/nixpkgs
$ nix-build -A hello</code></pre><p>Se sukcesis la kunmetaĵo, aperos simbolligilo nomata <code>result</code> en la aktuala dosierujo. Ĉi tiu simbolligilo indikas al dosierindiko en <code>/nix/store</code>. Ni rulu la programon:</p><pre><code>$ ./result/bin/hello
Hello, world!</code></pre><p>Bonege. La enmetu ŝanĝojn.</p><pre><code>$ git add -u
$ git commit -m 'hello: 2.10 -&gt; 2.11'
$ git push origin hello-2.11</code></pre><p>Fine, iru al la GitHub-deponeja <a href='https://github.com/nixos/nixpkgs'>paĝo</a>, tiam kreu tirpeton inter <code>nixos/nixpkgs:master</code> kaj <code>vakelo/nixpkgs:hello-2.11</code>.</p><h4><a name="nixpkgssendi">Sendi novan pakon</a></h4><p>La paŝoj por sendi novan pakon estas preskaŭ simila al ĝisdatigi novan pakon, krom malmultaj aferoj.</p><p>En la komenco, kreu novan branĉon por la pako:</p><pre><code>$ cd &#126;/nixpkgs
$ git checkout -b tthsum-1.3.2</code></pre><p>Tiam, decidu pri kiu kategorio ĝi devas aparteni:</p><pre><code>$ cd pkgs/applications/misc
$ mkdir tthsum</code></pre><p>Tiam, kreu la dosieron <code>default.nix</code>:</p><pre><code class="nix">{ stdenv, fetchurl }:

stdenv.mkDerivation rec {
  name = &quot;tthsum-${version}&quot;;
  version = &quot;1.3.2&quot;;

  src = fetchurl {
    url = &quot;http://tthsum.devs.nu/pkg/tthsum-${version}.tar.bz2&quot;;
    sha256 = &quot;0z6jq8lbg9rasv98kxfs56936dgpgzsg3yc9k52878qfw1l2bp59&quot;;
  };

  installPhase = ''
    mkdir -p $out/bin $out/share/man/man1
    cp share/tthsum.1.gz $out/share/man/man1
    cp obj-unix/tthsum $out/bin
  '';

  meta = with stdenv.lib; {
    description = &quot;An md5sum-alike program that works with Tiger/THEX hashes&quot;;
    longDescription = ''
      tthsum generates or checks TTH checksums &#40;root of the THEX hash
      tree&#41;. The Merkle Hash Tree, invented by Ralph Merkle, is a hash
      construct that exhibits desirable properties for verifying the
      integrity of files and file subranges in an incremental or
      out-of-order fashion. tthsum uses the Tiger hash algorithm for
      both the internal and the leaf nodes.
    '';
    homepage = http://tthsum.devs.nu/;
    license = licenses.gpl3Plus;
    maintainers = &#91; maintainers.ebzzry &#93;;
    platforms = platforms.unix;
  };
}
</code></pre><p>Oni povas rimarki, ke ni uzas la anglan ene tial, ke ĝi estas la devigita lingvo en la tutprojekto.</p><p>Kio novas ĉi tie estas la atribuo <code>installPhase</code>. La implicita kunmetada procedoj de la <em>tthsum</em>-pako malsamas al la maniero, en kiu Nix traktas instalojn, do ni devas esti specifa pri tio. La identigilo <code>$out</code> estas pri la fina dosierujo kie la programo loĝos en <code>/nix/store/</code>. En la uzantmedio, haveblos la programo ĉe <code>&#126;/.nix-profile/bin/tthsum</code>, kaj en la sistemmedio haveblos la programo ĉe <code>/run/current-system/sw/bin/tthsum</code>.</p><p>En ĉi tiu punkto, Nix ne ankoraŭ estas konscia pri <em>tthsum</em>. Ni devas deklari ĝin en la supra nivelo. Por tiel fari, redaktu la dosieron <code>pkgs/top-level/all-packages.nix</code>, kaj aldonu la jenan en la ĝustan kategorion.</p><pre><code class="nix">tthsum = callPackage ../applications/misc/tthsum { };
</code></pre><p>Tiam, muntu la pakon kiel priskribite ĉi-supre:</p><pre><code>$ cd &#126;/nixpkgs
$ nix-build -A tthsum</code></pre><p>Se sukcesis ĉio, enmetu la ŝanĝojn:</p><pre><code>$ git add pkgs/applications/misc/tthsum
$ git add pkgs/top-level/all-packages.nix
$ git commit -m &quot;tthsum: init at 1.3.2&quot;
$ git push origin tthsum-1.3.2</code></pre><p>Fine, iru al la GitHub-deponeja <a href='https://github.com/nixos/nixpkgs'>paĝo</a>, tiam kreu tirpeton inter <code>nixos/nixpkgs:master</code> kaj <code>vakelo/nixpkgs:tthsum-1.3.2</code>.</p><h3><a name="nixpkgsnotoj">Notoj</a></h3><p>En ajna punkto dum la instalo de pako, kaj la procezo estas interrompita, la pako ne fariĝos instalita en duone bakita stato. La plej lasta paŝo de instali pakojn estas atoma. La sekreto, estas, ke la sistemo kreas simbolligilon de <code>/nix/store</code> al <code>&#126;/.nix-profile/</code>, la operacio kiu disponebligas ĝin al uzanto. La kreado de simbolligiloj en linukso kaj makintoŝo estas aŭ sukcesa aŭ ne.</p><p>Ĉe NixOS, la kanalo uzita de la ĉefuzanto estas grava tial, ke ĝi estas tiu, kiun oni uzas kiam la rekunmeti sistemon per <code>nixos-rebuild switch</code> post ŝanĝoj al <code>/etc/nixos/configuration.nix</code> estas faritaj. Por certigi, ke oni uzas la pravan kanalon, listigu ĝin per:</p><pre><code>$ sudo nix-channel --list</code></pre><p>Por ŝanĝi la ĉefuzantan kanalon simila al tiu, kiu estis uzita antaŭe:</p><pre><code>$ sudo nix-channel --add https://nixos.org/channels/nixos-unstable nixos</code></pre><h2><a name="medioj">Medioj</a></h2><p>Medio estas maniero de Nix por provizi komponantan izoladon inter la sistemo kaj uzantoj. En NixOS, ekzistas tri medioj: sistemmedio, uzantmedio, kaj programadmedio.</p><h3><a name="sistemmedio">Sistemmedio</a></h3><p>La sistemmedio estas modifita nur per la ĉefuzanto kiu ĝi deklaras la valorojn en <code>/etc/nixos/configuration.nix</code>. Ĝi estas listo, kiu enhavas la pakojn kiu disponebliĝos al ĉiuj uzantoj de la sistemo. Jen ekzemplo de <code>/etc/nixos/configuration.nix</code> kiu uzas la sistemmedion:</p><pre><code class="nix">{ config, lib, pkgs, ... }:

{
  ...
  environment.systemPackages = with pkgs; &#91; zsh vim &#93;;
  ...
}
</code></pre><p>Tiu deklaras, ke la pakoj nomitaj <em>zsh</em> kaj <em>vim</em> disponeblos por ĉiuj uzantoj de la sistemo. La duumdosieroj disponeblos kiel <code>/run/current-system/sw/bin/zsh</code> kaj <code>/run/current-system/sw/bin/vim</code>, por Ziŝo kaj Vim, respektive.</p><p>Parenteze, la sistemmedio ekzistas nur ĉe NixOS .</p><h3><a name="uzantmedio">Uzantmedio</a></h3><p>La uzantmedio estas tiu, kiu estas uzita kiam ajn la komando <code>nix-env</code> estas uzita. Ekzemple, instali ziŝon per nix-env:</p><pre><code>$ nix-env -iA nixos.zsh</code></pre><p>Ziŝo fariĝos specife disponebla por la uzanto kiu alvokas ĝin. Se <code>johano</code> estas la uzanto kiu rulis tiun komandon, tiam la ziŝa duumdosiero disponebliĝos kiel <code>/home/johano/.nix-profile/bin/zsh</code>. Se la uzanto <code>mario</code> ankoraŭ ne instalis ziŝon en sia profilo, tiam ĝi ne disponeblas por si. Se Mario havas la saman kanalon kiel Johano, kaj ĝi kuris la saman <em>nix-env</em>-komandon, tiam Nix ne plu bezonas elŝuti la ziŝan programan datumon el nulo. Anstataŭe, disponebliĝas por Mario la ziŝa programa datumo, kiu estis kreita de la procezo de Johano antaŭe. Tamen, se Mario uzas gitkopion aŭ alian version de kanaloj kontraŭ tiu kiun Johano uzas, kaj la versio de Ziŝo malsamas al tiu kiun Johano uzas, tiam la alvoko de <code>nix-env</code> per Mario elŝutos novan instancon de ziŝo .</p><h3><a name="programadmedio">Programadmedio</a></h3><p>La tria medio, la programadmedio, estas kreita per la uzo de nix-shell. nix-shell ebligas la uzanton por krei sablujmediojn. La medio kreita estas izolita de la sistemo kaj kutimaj uzantmedioj. la medio kreita ankoraŭ uzos <code>/nix/store</code>, sed nek <code>/run/current-system/sw/</code> nek <code>&#126;/.nix-profile/</code> estos modifita. Kiun nix-shell disponigas estas medio, kiu estas aparta de la cetero de la sistemo, permesante la uzanton por krei porokazajn disponigojn sen maltrankvilo pli la modifado de la sistemstato. Per tio, uzanto gajnas la kapablon por uzi medion por elprovi diversajn disponigojn de apo aŭ por kontrasti eblojn antaŭ liverado.</p><p>Por krei mediojn kiuj estas malkonektitaj al la cetero de la sistemo, ni bezonas havi manieron por apartigi la dependencojn de apo kaj sia datumo mem, de kutima sistema interveno. nix-shell ebligas onin por krei maldikajn nivelojn de abstraktado, ekspluante la determinismon kaj risurcan administradon de Nix mem.</p><p>Por ilustri, ni kontrolu, ke <a href='https://www.gnu.org/software/hello/'>GNU Hello</a> ne fakte estas ankoraŭ instalita:</p><pre><code>$ which hello
hello not found</code></pre><p>Se tio estas la kazo, do bone. Aliokaze, unue forigi la <em>GNU Hello</em>-pakon.</p><p>Nu, por montri nix-shell, ni rulu GNU Hello en nix-shell, tiam ĝi revenos al la kutima uzantŝelo.</p><pre><code>$ nix-shell --packages hello --pure --run hello
Hello, world!
$ which hello
hello not found</code></pre><p>Kion tio faras, estas, ke ĝi elŝutos la duumpakon por GNU Hello, kreante puran ŝelan medion, tiam progresas por ruli la duumdosieron <code>hello</code>, kiu montros la konatan saluton al la ekrano. Se la <code>‑‑run</code> opcio estas forigita, ni faliĝos en ŝelo:</p><pre><code>$ nix-shell --packages hello --pure
&#91;nix-shell:&#126;&#93;$ hello
Hello, world!</code></pre><p>Tiu ŝelinstanco estas speciala tial, ke ĝi enhavas nur sufiĉan informon por igi la komandon <code>hello</code> disponebla. Ni eĉ povas kontroli la valoron de <code>$PATH</code> tie:</p><pre><code class="bash">&#91;nix-shell:&#126;&#93;$ echo $PATH | tr ':' '\n'
/nix/store/kc912zn1ry1xilcm901ip7p8s1iqv0f1-hello-2.10/bin
/nix/store/f9q8k36x9jpi8jmdpwifcywzywpxvhrs-patchelf-0.9/bin
/nix/store/xx2bclrflkcvrddvp6bd3wsasqs7vsp1-paxctl-0.9/bin
/nix/store/4d6f8hg5gv20nsbq7b52qzn6bcs4fvlh-coreutils-8.26/bin
/nix/store/f3vl26f3n18khgq1kybnzvwjbm0r9grg-findutils-4.6.0/bin
/nix/store/mvnjpifk06yjffrsd50rpr3jjfrjsqiv-diffutils-3.5/bin
/nix/store/0xwrn1p8fp8h3cynszpgbmhmydbzhns5-gnused-4.4/bin
/nix/store/avmxym1w34sc17nrilsmgrk469l3ml0z-gnugrep-3.0/bin
/nix/store/2vh4wllg66rw61ffdfwp1xm4r2yns44j-gawk-4.1.3/bin
/nix/store/rhjsykhxrzj3ca8da6b4g6v1yx53xpi3-gnutar-1.29/bin
/nix/store/w1vlvxlavmz39by5xpnhva36q2lbi9hf-gzip-1.8/bin
/nix/store/mgvqw07ssjhf1hb96md97rjkfsrmfmp6-bzip2-1.0.6.0.1-bin/bin
/nix/store/69y0laqzizjycwaqivbsp273n0ag3ayi-gnumake-4.2.1/bin
/nix/store/86blj9iqyxwmdgkn3dyrpib1gkbmz91v-bash-4.4-p5/bin
/nix/store/qjklkl51d6qp98n8nncvbv62p01pp6qf-patch-2.7.5/bin
/nix/store/8pcap19p6qwf06ra4iaja3n6k6p2jzwg-xz-5.2.2-bin/bin
</code></pre><p>La eligo malsamos kontraŭ la mia pro la kradvaloroj en la tenejaj dosierindikoj. Ekster la teneja dosierindiko de <em>GNU Hello</em>, la ceteraj estas la minimumaj komponantoj de nix-shell-instanco. Ĉi tiu sektoraro nomiĝas <em>stdenv</em>.</p><p>nix-shell serĉas la dosierojn <code>shell.nix</code> aŭ <code>default.nix</code> , en tiu ordo, ĉe la aktuala dosierujo dum startigo, por elŝargi la difinojn. Ni kreu ĝin, konservante ĝin kiel <code>default.nix</code>:</p><pre><code class="nix">{ pkgs ? import &lt;nixpkgs&gt; {} }:

with pkgs;
stdenv.mkDerivation {
  name = &quot;shell&quot;;
  buildInputs = &#91; hello emem &#93;;
}
</code></pre><p><em>.nix</em>-dosiero estas Nix-esprimo mem. En ĉi tiu ekzemplo, ĝi estas funkcio kiu akceptas unu argumenton kun implicita valoro. La bizara <code>&lt;nixpkgs&gt;</code>-esprimo indikas la valoron de la atribuo <code>nixpkgs</code>, deklarita en la media variablo <code>NIX&#95;PATH</code>. Ĉe NixOS, ĝi aspektas jene:</p><pre><code>$ echo $NIX&#95;PATH
nixpkgs=/nix/var/nix/profiles/per-user/root/channels/nixos/nixpkgs:nixos-config=/etc/nixos/configuration.nix:/nix/var/nix/profiles/per-user/root/channels</code></pre><p>En la dosierujo kiu estas indikata de la atribuo <code>nixpkgs</code>, ĝi estas la dosiero <code>.git-revision</code>. Ni kontrolu ĝian enhavon:</p><pre><code>$ cat /nix/var/nix/profiles/per-user/root/channels/nixos/nixpkgs/.git-revision
1e8c01784a6a121fc94d111f4af7cc88dd932186</code></pre><p>Ĉi tio diras al ni la version de Nixpkgs-kanaloj uzata en ĉi tiu profilo.</p><p>Iri reen, la deklaro <code>with pkgs</code> metas ĉiom da identigiloj en la lokamplekso, igas ilin videblaj. <code>stdenv</code>, kiu estis menciita antaŭe, estas atribuaro kiu inter multaj aferoj, enhavas la identigilon <code>mkDerivation</code>. <code>mkDerivation</code>, sinsekve, estas funkcio kiu akceptas unu atribuaran argumenton. Memorigu, ke la kunigkrampoj post <code>mkDerivation</code> specifas unu eron da argumento kiu estas atribuaro; ĝi ne havas semantikan similecon al la kunigkrampoj de aliaj programlingvoj por limigi la komencon kaj finon de funkciamplekso. Estas pluraj alĝustigiloj por ĝi, tamen por la celoj de simpleco, nur ni kontrolos <code>name</code> kaj <code>buildInputs</code>—la apenaŭaj atribuaj parametroj.</p><p>Por nia bagatela ekzemplo, la voloro de <code>name</code> povas esti io ajn. La valoro de <code>buildInputs</code>, tamen, estas grava. Ĉi tie, ili estas deklaritaj <code>hello</code> kaj <code>emem</code>. Estas referencoj al valoroj en la <code>nixpkgs</code>-markilo, kiun ni vidis antaŭe. Se ni ne uzis <code>with pkgs</code> , la esprimo estus:</p><pre><code class="nix">{ pkgs ? import &lt;nixpkgs&gt; {} }:

pkgs.stdenv.mkDerivation {
  name = &quot;shell&quot;;
  buildInputs = &#91; pkgs.hello pkgs.emem &#93;;
</code></pre><p>Por manĝigi ĉi tiun esprimon al nix-shell, uzante ambaŭ <em>hello</em> kaj <em>emem</em>, rulu:</p><pre><code>$ nix-shell --pure --run &quot;hello | emem -w&quot;
&lt;p&gt;Hello, world!&lt;/p&gt;</code></pre><p>nix-shell donas al ni fortajn abstraktadajn meĥanismojn kiuj estas rigarditaj tre malfacilaj por fari en aliaj metodoj. Ĝi ekspluatas la determinismajn kvalitojn de Nix, kreante fortan avantaĝon.</p><h2><a name="surmetoj">Surmetoj</a></h2><p>Estos tempoj en kiuj oni devas fari ŝanĝojn al la paksistemo, tamen oni ne pretas por iri tutfreneze kaj fuŝi la gitdeponejon. Ankaŭ estos tempoj en kiuj oni volas havi privatan deponejon, sed oni ne volas publikiĝi. Surmetoj povas helpi onin por tiu celo.</p><p>Kiel la nomo implicas, la surmeto meĥanismo estas maniero por krei abstraktan nivelon super la ekzistantaj esprimoj. Unu uzo estas samkiel porti benkseĝaron por intervjuo—vi ankoraŭ estas vi sube, sed draste ŝanĝiĝis via aspekto. Alia uzo estas samkiel anstataŭigi viajn internajn organojn kibernetike—vi ankoraŭ estas iomete vi, sed draste ŝanĝiĝis pluraj partoj de vi interne. Alia uzado, kiu estas unu el miaj plej ŝatataj, estas krei novan eston el virtuala nenio.</p><p>Surmetaj dosieroj estas viaj konataj Nix-esprimoj kun specifa formato. Ili loĝas ĉe <code>&#126;/.config/nixpkgs/overlays/</code>. Se oni ne havas tiun dosierujon, oni povas krei ĝin per:</p><pre><code>$ mkdir -p &#126;/.config/nixpkgs/overlays</code></pre><p>Mi strukturas miajn surmetajn dosierojn en kiu ĉiu dosiero kongruas al unu pako, kies konduton mi volas ŝanĝi.</p><h3><a name="surmetojtranspasoj">Transpasoj</a></h3><p>Ekzemple, se oni volas certigi ke la dokumentaro por <a href='https://github.com/NixOS/nixpkgs/blob/master/pkgs/development/interpreters/racket/default.nix'>Rakido</a> estos instalitaj, kreu la dosieron <code>&#126;/.config/nixpkgs/overlays/racket.nix</code> per la jena enhavo:</p><pre><code class="nix">self: super: {
  racket = super.racket.override {
    disableDocs = false;
  };
}
</code></pre><p>Tiu estas Nix-funkcio kun du argumentoj—<code>self</code> kaj <code>super</code>. <code>super</code> referencas al la esprimoj kiuj apartenas al la sistemo, dum <code>self</code> referencas al la aro de esprimoj kiujn oni difinas. Estas devige, ke estas nur du argumentoj kaj ili estas <code>self</code> kaj <code>super</code>.</p><p>Sekve, precizigu, ke por la <code>racket</code>-atributo, ĝi vokos la funkcion <code>override</code> el la fonta tavolo, donante al ĝi atributan aron kiu enhavas la transpasojn.</p><p>Kiam oni instalas Racket aŭ Chromium, tiuj agordoj estos legataj kaj efektiviĝos.</p><pre><code>$ nix-env -iA $&#40;nix-channel --list | awk '{print $1}'&#41;.racket</code></pre><h3><a name="surmetojnovajpakoj">Novaj pakoj</a></h3><p>Uzi la surmetan sistemon por krei novajn pakojn estas ideala se oni ne volas doni la pakon al Nixpkgs, oni volas privatigi ĝin, aŭ oni volas aldoni novan infrastukturon sen trakti la ekstran komplekson.</p><p>Ni supozu, ke ekzistas simpla ŝela programo <i>moo</i> kiu loĝas ĉe <a href="https://github.com/ebzzry/moo">https://github.com/ebzzry/moo</a>, kaj oni deziras paki ĝin. Por fari tion, oni skribos du aĵojn:</p><ol><li>la supran surmetan dosieron en <code>&#126;/.config/nixpkgs/overlays/</code>; kaj</li><li>la Nix-esprimon kiu je <i>moo</i> fakte kreas.</li></ol><p>Por #1, kreu la dosieron <code>&#126;/.config/nixpkgs/overlays/moo.nix</code> per la jena enhavo:</p><pre><code>self: super: {
  moo = super.callPackage ./pkgs/moo { };
}
</code></pre><p>Tiam, por #2, kreu la dosierarbon por la esprimo. Memoru, ke ne devigatas la nomo <code>pkgs</code>:</p><pre><code>$ cd &#126;/.config/nixpkgs/overlays
$ mkdir -p pkgs/moo</code></pre><p>Tiam kreu la dosieron <code>&#126;/.config/nixpkgs/overlays/pkgs/moo/default.nix</code> per la jena enhavo:</p><pre><code class="nix">{ stdenv, fetchFromGitHub, bash }:

stdenv.mkDerivation rec {
  name = &quot;moo-${version}&quot;;
  version = &quot;0.0.1&quot;;

  src = fetchFromGitHub {
    owner = &quot;ebzzry&quot;;
    repo = &quot;moo&quot;;
    rev = &quot;abd22b4860f83fe7469e8e40ee50f0db1c7a5f2c&quot;;
    sha256 = &quot;0jh0kdc7z8d632gwpvzclx1bbacpsr6brkphbil93vb654mk16ws&quot;;
  };

  buildPhase = ''
    substituteInPlace moo --replace &quot;/usr/bin/env bash&quot; &quot;${bash}/bin/bash&quot;
  '';

  installPhase = ''
    mkdir -p $out/bin
    cp moo $out/bin
    chmod +x $out/bin/moo
  '';

  meta = with stdenv.lib; {
    description = &quot;Random helper&quot;;
    homepage = https://github.com/ebzzry/moo;
    license = licenses.cc0;
    maintainers = &#91; maintainers.ebzzry &#93;;
    platforms = platforms.all;
  };
}
</code></pre><p>Per tiuj du dosieroj, oni nun povas instali <i>moo</i> :</p><pre><code>$ nix-env -iA $&#40;nix-channel --list | awk '{print $1}'&#41;.moo</code></pre><h2><a name="finrimarkoj">Finrimarkoj</a></h2><p>Nix provizas potencajn ilojn por administri facile sistemojn kaj programadajn agordojn. Ĝi havas fleksajn facilojn por krei rendimentajn laborfluojn kaj distrubuajn modelojn. Se mi devas listigi la plej gravajn eblojn de la Nix-ekosistemo kiuj plaĉas al mi, ili estas la jena:</p><ul><li>determinisma</li><li>reproduktema</li><li>senstata</li><li>deklara</li><li>kohera</li><li>portebla</li><li>fidebla</li><li>pure funkcia</li></ul><p>Alia grava ano de la Nix-familio estas <a href='https://nixos.org/nixops'>NixOps</a>; ĝi ebligas onin por disponigi NixOS ĉe «nudmetalaj» sistemoj, virtualaj sistemoj, aŭ la nubo, per la uzo de deklara aliro kiu estas konata al ni. Ĝi eblas disponigi al <em>VirtualBox</em>, <em>Amazon EC2</em>, <em>Google Compute Engine</em>, <em>Microsoft Azure</em>, <em>Hetzner</em>, <em>Digital Ocean</em>, kaj <em>Libvirtd</em>. Iru al la <a href='https://nixos.org/nixops/manual/'>gvidilo</a> por vidi pli da detalo.</p><p>Fundajn detalojn pri generadoj, derivaĵoj, kaj efektivigadoj estis eliziitaj intence en ĉi tiu artikolo. Ili povas fariĝi sekcio per si mem, aŭ mi eblas ĝisdatigi ĉi tiun artikolon por aldoni tiujn temojn. Estas eble, ke mi skribos novan sekcion pri NixOS .</p><p>Emaksa ĉefregimo por Nix-dosieroj haveblas de la <a href='https://github.com/NixOS/nix-mode'>ĉefdeponejo</a> de NixOS. Ĝi ankaŭ haveblas per <a href='https://melpa.org/#/nix-mode'>MELPA</a>. Oni povas instali ĝin per:</p><pre><code>M-x package-install EN nix-mode EN
</code></pre><p>Ekzistas aliaj pakaj administradaj sistemoj kiuj ankaŭ provas solvi ĉi tiun problemareon. Tiuj, kiujn mi konas estas <a href='http://appimage.org/'>AppImage</a>, <a href='http://0install.net/'>Zero Install</a>, <a href='https://snapcraft.io/'>Snapcraft</a>, kaj <a href='http://flatpak.org/'>Flatpak</a>.</p><p>La <a href='https://www.gnu.org/software/guix/'>Guix System Distribution (GuixSD)</a> estas linuksa distribuo kiu estas bazita sur Nix. Ĝi uzas <a href='https://www.gnu.org/software/guile/'>Guile</a> kiel sia API-lingvo. La kerna kontrasto inter GuixSD kaj NixOS, estas, ke GuixSD uzas <a href='https://www.gnu.org/software/shepherd/'>GNU Shepherd</a> anstataŭ systemd; neliberajn pakojn ĝi ne permesas; kaj ĝi uzas <a href='https://www.fsfla.org/ikiwiki/selibre/linux-libre/'>Linux-libre</a>, malpligrandigita versio de la baza kerno kun ĉiom da komercaj aĵoj forigitaj. Pli da informo pri iliaj kontrastoj troveblas <a href='https://sandervanderburg.blogspot.de/2012/11/on-nix-and-gnu-guix.html'>ĉi tie</a>.</p><p>Ekster GuixSD, ekzistas aliaj projektoj kiujn Nix inspiris. Estas <a href='https://habitat.sh'>Habitat</a>, aplikaĵa aŭtomacia framo; kaj <a href='https://github.com/alexanderGugel/ied'>ied</a>, alterna paka administrilo por Node.js.</p><p>La artikoloj de <a href='https://lethalman.blogspot.com/2014/07/nix-pill-1-why-you-should-give-it-try.html'>Luca BRUNO</a>, <a href='https://jameshfisher.com/2014/09/28/nix-by-example/'>James FISHER</a>, kaj <a href='https://web.archive.org/web/20180610095602/https://ocharles.org.uk/blog/posts/2014-02-04-how-i-develop-with-nixos.html'>Oliver CHARLES</a>, kune la <a href='https://nixos.org/nixos/manual'>NixOS</a>, <a href='https://nixos.org/nixpkgs/manual'>Nixpkgs</a>, kaj <a href='https://nixos.org/nix/manual'>Nix</a> gvidiloj, ege helpis min por kompreni Nix. Apartaj dankoj iras al <a href='https://fare.livejournal.com'>François-René RIDEAU</a> por enkonduki min al Nix antaŭ multaj jaroj.</p><p>La NixOS-fondiĝo estas registrita senprofitcela organizo; la <a href='https://nixos.org/nixos/foundation.html'>oferdonoj</a> ege helpas en la programado de Nix. Aliĝu al la <a href='https://nixos.org/nixos/community.html'>komunumo</a> kaj helpu ĝin kreskiĝi!</p><h2><a name="bonifiko">Bonifiko</a></h2><p>Jen la <a href='/eo/ipsilono/'>ipsilonkombinatoro</a> en Nix, aplikita al la faktoriala funkcio:</p><pre><code class="nix">nix-repl&gt; y = x: &#40;&#40;f: &#40;x &#40;v: &#40;&#40;f f&#41; v&#41;&#41;&#41;&#41; &#40;f: &#40;x &#40;v: &#40;&#40;f f&#41; v&#41;&#41;&#41;&#41;&#41;

nix-repl&gt; b = p: &#40;n: if n == 0 then 1 else &#40;n &#42; &#40;p &#40;n - 1&#41;&#41;&#41;&#41;

nix-repl&gt; f = y b

nix-repl&gt; f 20
2432902008176640000
</code></pre><p>aŭ, en unu esprimo, per <em>let</em>:</p><pre><code class="nix">nix-repl&gt; let y = x: &#40;&#40;f: &#40;x &#40;v: &#40;&#40;f f&#41; v&#41;&#41;&#41;&#41; &#40;f: &#40;x &#40;v: &#40;&#40;f f&#41; v&#41;&#41;&#41;&#41;&#41;;
              b = p: &#40;n: if n == 0 then 1 else &#40;n &#42; &#40;p &#40;n - 1&#41;&#41;&#41;&#41;;
              f = y b;
          in f 20
2432902008176640000
</code></pre><p>Oni povas konduki la ĉefeligujon al nix-repl:</p><pre><code class="nix">$ echo 'let y = x: &#40;&#40;f: &#40;x &#40;v: &#40;&#40;f f&#41; v&#41;&#41;&#41;&#41; &#40;f: &#40;x &#40;v: &#40;&#40;f f&#41; v&#41;&#41;&#41;&#41;&#41;; b = p: &#40;n: if n == 0 then 1 else &#40;n &#42; &#40;p &#40;n - 1&#41;&#41;&#41;&#41;; f = y b; in f 20' | nix-repl
Welcome to Nix version 1.11.8. Type :? for help.

nix-repl&gt; let y = x: &#40;&#40;f: &#40;x &#40;v: &#40;&#40;f f&#41; v&#41;&#41;&#41;&#41; &#40;f: &#40;x &#40;v: &#40;&#40;f f&#41; v&#41;&#41;&#41;&#41;&#41;; b = p: &#40;n: if n == 0 then 1 else &#40;n &#42; &#40;p &#40;n - 1&#41;&#41;&#41;&#41;; f = y b; in f 20
2432902008176640000

nix-repl&gt;
</code></pre><p><i>Dank’ al <a href='https://github.com/dansvo'>Dan SVOBODA</a> pro la korektoj.</i></p><hr/><div class="footer"><p><div class="text-small"> <a href='/eo/'>Hejmo</a> • <a href='/eo/pri/'>Pri</a> • <a href='/eo/citajxoj/'>Citaĵoj</a> • <a href='/eo/pripensoj/'>Pripensoj</a> </div></p><p><div class="text-x-small"> Kreita per ❤️ de Rommel Martínez </div></p><p></div></p></div><script src="/static/js/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></body></html>