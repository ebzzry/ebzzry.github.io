<!DOCTYPE html>
<html lang="eo"><head><title>Ziŝkonsiletoj 4-a: Ĝeneralhelpiloj</title><meta charset="utf-8" /><meta content="width=device-width,initial-scale=1.0,user-scalable=yes" name="viewport" /><meta content="noodp,noydir" name="robots" /><link rel='apple-touch-icon' sizes='180x180' href='/images/ico/apple-touch-icon.png'><link rel='icon' type='image/png' sizes='32x32' href='/images/ico/favicon-32x32.png'><link rel='icon' type='image/png' sizes='16x16' href='/images/ico/favicon-16x16.png'><link rel='manifest' href='/images/ico/site.webmanifest'><link rel='mask-icon' href='/images/ico/safari-pinned-tab.svg' color='#5bbad5'><link rel='shortcut icon' href='/images/ico/favicon.ico'> <meta name='msapplication-TileColor' content='#da532c'> <meta name='msapplication-config' content='/images/ico/browserconfig.xml'> <meta name='theme-color' content='#ffffff'><meta content="Zi��konsiletoj 4-a: ��eneralhelpiloj" name="description" /><meta content="zi��o, zisxo, zsh, konsiletoj, ��elo, sxelo, linukso, agordo, agorda��o, agorda��xo, helpiloj" name="keywords" /><meta content="Zi��konsiletoj 4-a: ��eneralhelpiloj" property="og:title" /><meta content="article" property="og:type" /><meta content="https://ebzzry.io/eo/zisxkonsiletoj-4-a/" property="og:url" /><meta content="https://ebzzry.io/images/ico/android-chrome-512x512.png" property="og:image" /><style media="all" type="text/css">html {    color: #333;    font-size: 1em;    font-family: Georgia, Cambria, Palatino, "Palatino Linotype", "Times New Roman", Times, serif;    line-height: 1.45;    text-align: left:    width: 100%;    max-width: 40em;    margin: 0 auto 0 auto;    padding: 0;}body {    border-top: hidden;    border-bottom: hidden;    padding: 0 1.5em 1em 1.5em;    margin: 0;}#content {    -webkit-column-count: 1;    -moz-column-count: 1;    column-count: 1;}code {    font-size: 0.9em;    font-family: "DejaVu Sans Mono", "Bitstream Vera Sans Mono", "Lucida Console", "Courier New", Courier, monospace;    color: black;    display: inline-block;    font-weight: bold;}pre code {    font-size: 1em;    font-family: monospace;    line-height: 1.3em;    overflow: auto;    font-weight: normal;}kbd {    font-size: 1.1em;    padding: 0.1em 0.6em;    border: 1px solid #ccc;    font-family: monospace;    background-color: #f7f7f7;    color: #333;    -moz-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    -webkit-box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    box-shadow: 0 1px 0px rgba(0, 0, 0, 0.2),0 0 0 2px #ffffff inset;    -moz-border-radius: 3px;    -webkit-border-radius: 3px;    border-radius: 3px;    display: inline-block;    margin: 0 0.1em;    text-shadow: 0 1px 0 #fff;    white-space: nowrap;}h1, h2, h3, h4, h5, h6 {    font-family: Calibri, "Gill Sans", "Gill Sans MT", "Myriad Pro", Myriad, "DejaVu Sans", Tahoma, Geneva, Helvetica, Arial, sans-serif;    margin-bottom: 0;}h1 {    font-size: 2.5em;    text-align: center;    border-bottom: 6px solid black;}h2 {    font-size: 2.0em;    text-align: left;    border-bottom: 2px solid black;}h3 {    font-size: 1.6em;    text-align: left;    border-bottom: 1px solid lightgrey;}h4 {    font-size: 1.5em;    text-align: left;}h5 {    font-size: 1.3em;    text-align: left;}ul, ol {    padding-left: 2em;}ul li {    list-style-type: square;}ul li li {    list-style-type: disc;}ul li li li {    list-style-type: circle;}ol li {    list-style-type: decimal;}p, para, b, strong, i, em, emph {    font-size: 1em;}blockquote {    font-size: 1.2em;    font-style: italic;    margin-left: 2em;}b, strong {    font-weight: bold;}i, em, emph {    font-style: italic;}table {    margin: 0.5em;    border-spacing: 0;    border-collapse: collapse;}th, td {    border: 1px solid lightgray;    padding-top: 0;    padding-bottom: 0;    padding-left: 0.45em;    padding-right: 0.45em;}.text-right {    text-align: right;}.text-small {    font-size: small;}.text-x-small {    font-size: x-small;}.banner {    display: block;    width: 100%;    margin-left: auto;    margin-right: auto;}.footer {    text-align: right;    float: right;    max-width: 18em;}.cc {    border-width: 0}.center {    text-align: center;}</style><style media="all" type="text/css">/* Ewan Themes -- based 99.99% from Tomorrow Night Theme *//* http://jmblog.github.com/color-themes-for-google-code-highlightjs *//* Original theme - https://github.com/chriskempson/tomorrow-theme *//* http://jmblog.github.com/color-themes-for-google-code-highlightjs *//* Tomorrow Comment */.hljs-comment {  color: #969896;}/* Tomorrow Red */.hljs-variable,.hljs-attribute,.hljs-tag,.hljs-regexp,.ruby .hljs-constant,.xml .hljs-tag .hljs-title,.xml .hljs-pi,.xml .hljs-doctype,.html .hljs-doctype,.css .hljs-id,.css .hljs-class,.css .hljs-pseudo {  color: #cc6666;}/* Tomorrow Orange */.hljs-number,.hljs-preprocessor,.hljs-pragma,.hljs-built_in,.hljs-literal,.hljs-params,.hljs-constant {  color: #de935f;}/* Tomorrow Yellow */.ruby .hljs-class .hljs-title,.css .hljs-rule .hljs-attribute {  color: #f0c674;}/* Tomorrow Green */.hljs-string,.hljs-value,.hljs-inheritance,.hljs-header,.hljs-name,.ruby .hljs-symbol,.xml .hljs-cdata {  color: #b5bd68;}/* Tomorrow Aqua */.hljs-title,.css .hljs-hexcolor {  color: #8abeb7;}/* Tomorrow Blue */.hljs-function,.python .hljs-decorator,.python .hljs-title,.ruby .hljs-function .hljs-title,.ruby .hljs-title .hljs-keyword,.perl .hljs-sub,.javascript .hljs-title,.coffeescript .hljs-title {  color: #81a2be;}/* Tomorrow Purple */.hljs-keyword,.javascript .hljs-function {  color: #b294bb;}.hljs {  display: block;  overflow-x: auto;  background: #1d1f21;  color: #c5c8c6;  padding: 0.5em;  -webkit-text-size-adjust: none;}.coffeescript .javascript,.javascript .xml,.tex .hljs-formula,.xml .javascript,.xml .vbscript,.xml .css,.xml .hljs-cdata {  opacity: 0.5;}pre code {    font-size: 1.1em;    font-family: monospace;    line-height: 1.3em;    overflow: auto;}</style></head><body><div id="content"><h1>Ziŝkonsiletoj 4-a: Ĝeneralhelpiloj</h1><p><div class="center">Esperanto · <a href='/en/zsh-tips-4/'>English</a></div> <div class="center">la 26-an de septembro 2018</div> <div class="center">Laste ĝisdatigita: la 8-an de marto 2019</div></p><blockquote><p>Vidpunkto meritas okdek poentojn da inteligentecaj kvocientoj.<br> ―Alan KAY </p></blockquote><p>Lastfoje, mi parolis pri la helpilaj funkcioj por asisti en la mastrumado de radikigmedioj. En ĉi tiu artikolo, mi parolos pri ĝeneralaj helpiloj por labori sur la komandlinio. Mi ankaŭ parolos pri helpemaj klavkombinoj por maŝinskribadon plirapidigi.</p><h2><a name="et"></a>Enhavotabelo</h2><ul><li><a href='#funkcioj'>Funkcioj</a><ul><li><a href='#map'>map</a></li><li><a href='#rmap'>rmap</a></li><li><a href='#fp'>fp</a></li><li><a href='#d'>d</a></li><li><a href='#d_krisigno'>d!</a></li><li><a href='#rm_krisigno'>rm!</a></li><li><a href='#rm_pluso'>rm+</a></li><li><a href='#rm_heliko'>rm@</a></li><li><a href='#defmk'>def_mk</a></li><li><a href='#cp_krisigno'>cp!</a></li><li><a href='#mv_krisigno'>mv!</a></li></ul></li><li><a href='#klavkombinoj'>Klavkombinoj</a><ul><li><a href='#insertlastword'>insert-last-word</a></li><li><a href='#copyprevshellword'>copy-prev-shell-word</a></li><li><a href='#anstatauxigoj'>Anstataŭigoj</a></li><li><a href='#citiloj'>Citiloj</a></li></ul></li><li><a href='#cxio'>Ĉion rikolti</a></li><li><a href='#finrimarkoj'>Finrimarkoj</a></li></ul><h2><a name="funkcioj"></a>Funkcioj</h2><p>Bela afero pri funkcioj, estas, ke ili estas tiel facile por skribi kaj uzi. Jen kelkaj funkcioj kiujn mi uzas ofte.</p><h3><a name="map"></a>map</h3><p>Kiam komandon kiu nur unu argumenton akceptas oni havas, plurajn uzojn de tiu komando oni volas simuli per ĉi tiu funkcio. Ĝi estas difinita jene:</p><pre><code class="bash">function map &#40;&#41; {
  for i &#40;${argv&#91;2,-1&#93;}&#41; { ${&#40;ps: :&#41;${1}} $i }
}
</code></pre><p>Ekzemple, je <code>map</code> oni povas uzi por plurajn gitaj deponejon, serie:</p><pre><code>% map 'git clone' git@github.com:nixos/nixpkgs.git git@github.com:tmux/tmux.git</code></pre><h3><a name="rmap"></a>rmap</h3><p>Kiel la nomo implicas, <code>rmap</code> funkcias kiel la inverso de <code>map</code>—la cetaraj argumentoj estas aplikitaj kiel komandoj al la unua argumento. Ĝi estas difinita jene:</p><pre><code class="bash">function rmap &#40;&#41; {
  for i &#40;${argv&#91;2,-1&#93;}&#41; { ${&#40;ps: :&#41;${i}} $1 }
}
</code></pre><p>Ĝi oni povas uzi, ekzemple, por diskuzadon kontroli, dosierinformon vidi, kaj la malfermajn dosiernumerojn de dosiero aŭ dosierujo vidi:</p><pre><code>% rmap iudosierujo 'du -h' stat 'sudo lsof'</code></pre><h3><a name="fp"></a>fp</h3><p>Rapidan manieron por la realan kaj absolutan dosierindikon de dosiero aŭ dosierujo precizigi mi volas havi. Min ĉi tio helpas multe en skriptado. Ĝi estas difinita jene:</p><pre><code class="bash">function fp &#40;&#41; {
  echo &quot;${1:A}&quot;
}
</code></pre><p>Se mi estas en simbolligita dosierujo, kaj la realdosierindikon de <code>.</code> mi volas precizigi, la jenan mi povas plenumi:</p><pre><code>% fp .</code></pre><p>Ĉi tiu funkcio estos grava en la sekva sekcio.</p><h3><a name="d"></a>d</h3><p>Ofte, kiam mi iras al dosierujo, serion de komandoj mi bezonas plenumi. Tempon por maŝinskribado mi volas savi, do anstataŭ du komandojn plenumi, nur unu mi nur devas plenumi. Manieron por dosierujon rapide ŝanĝigi tra la dosierujstakoj per <code>pushd</code> mi volas havi. Ĝi estas difinita jene:</p><pre><code class="bash">function d &#40;&#41; {
  if &#40;&#40; ! $#@ &#41;&#41;; then
      builtin cd
  elif &#91;&#91; -d $argv&#91;1&#93; &#93;&#93;; then
      builtin cd &quot;$&#40;fp $argv&#91;1&#93;&#41;&quot;
      $argv&#91;2,-1&#93;
  elif &#91;&#91; &quot;$1&quot; = -&lt;-&gt; &#93;&#93;; then
      builtin cd $1 &gt; /dev/null 2&gt;&amp;1
      $argv&#91;2,-1&#93;
  else
    echo &quot;$0: no such file or directory: $1&quot;
  fi
}
</code></pre><p>Kiam je <code>d</code> mi plenumas sole:</p><pre><code>% d</code></pre><p>Mi iros al la hejmdosierujo, samkiel kion memstara <code>cd</code> devus fari:</p><p>Kiam je <code>d</code> mi plenumas kun dosierujo kaj komando:</p><pre><code>% d &#126;/Downloads ls -l</code></pre><p>La aktuala dosierujo ŝanĝiĝos al <code>&#126;/Downloads</code>, tiam je <code>ls -l</code> mi plenumas por la enhavon de tiu dosierujo montri.</p><p>Se la eligo de <code>dirs -v</code> estas la jena:</p><pre><code>0       /usr/local
1       /tmp
</code></pre><p>Tiam, je <code>d</code> mi plenumu, kaj la dua enskribo estas uzota kun komando:</p><pre><code>% d -1 date</code></pre><p>La dosierujo ŝanĝiĝos al <code>/tmp/</code>, tiam la komando <code>date</code> kuros.</p><h3><a name="d_krisigno"></a>d!</h3><p>Kiel la nomo implicas, <code>d!</code> similas al sia kuzo nur, ke se la cela dosierujo ne ekzistas, ĝin ĝi kreas, kaj la saman konduton de <code>d</code> ĝi faras poste. Ĝi estas difinita jene:</p><pre><code class="bash">function d! &#40;&#41; {
  mkdir -p $argv&#91;1&#93;
  d &quot;$@&quot;
}
</code></pre><p>Ekzemple, je <code>d!</code> mi povas uzi por dosierujon scenigi antaŭ ISO-dosieron elŝuti:</p><pre><code>% d! &#126;/Downloads/iso https://www.hundo.kato/muso/ve/ve.iso</code></pre><h3><a name="rm_krisigno"></a>rm!</h3><p>Kiam mi certas, ke dosieron aŭ dosierujon mi volas forviŝi, mi ne volos ĝenita per invitoj, dum samtempe escepton por la hejmdosieron ne akcidente forviŝi mi volas havi. Ĝi estas difinita jene:</p><pre><code class="bash">function rm! &#40;&#41; {
  if &#91;&#91; &quot;$1&quot; == &quot;$HOME&quot; || &quot;$1&quot; == &quot;$HOME/&quot; || &quot;$1&quot; == &quot;&#126;&quot; || &quot;$1&quot; == &quot;&#126;/&quot; &#93;&#93;; then
      return 1
  else
    command rm -rf $@
  fi
}
</code></pre><p>La komando <code>commando</code> certigas, ke la sistemduumdosieron <code>rm</code> mi alvokas anstataŭ ia ŝela alinomo aŭ funkcio.</p><h3><a name="rm_pluso"></a>rm+</h3><p>Kiam arbon kiu multe da dosiero kaj dosierujo havas mi volas rapide forviŝi, la komandon <code>parallel</code> mi uzas por la forviŝadon plenumi paralele, anstataŭ serie. Ĝi estas difinita jene:</p><pre><code class="bash">function rm+ &#40;&#41; {
  parallel 'rm -rf {}' ::: $@
}
</code></pre><p>La pakmastrumilon de la sistemo kontrolu kiel je <code>parallel</code> instali.</p><h3><a name="rm_heliko"></a>rm@</h3><p>Kelkfoje, dosieron aŭ dosierujon mi bezonas forviŝi sen la ŝancoj de retrovado. Por tion fari, la komandon <code>shred</code> mi uzas. Ĝi estas difinita jene:</p><pre><code class="bash">function rm@ &#40;&#41; {
  if &#91;&#91; -d $1 &#93;&#93;; then
      find $1 -type f -exec shred -vfzun 10 {} \;
      command rm -rf $1
  else
    shred -vfzun 10 $1
  fi
}
</code></pre><p>La pakmastrumilon de la sistemo kontrolu kiel je <code>shred</code> instali.</p><h3><a name="defmk"></a>def_mk</h3><p>Helpilojn ci tiu helpilo generas. Onin ĝi permesas por funkciojn krei kiuj antaŭproduktajn dosierojn kreas antaŭ la vera komando estas plenumita. Ĝi estas difinita kiel:</p><pre><code class="bash">function def&#95;mk &#40;&#41; {
  eval &quot;function ${argv&#91;1&#93;} &#40;&#41; {
            if &#91;&#91; \$# -ge 2 &#93;&#93;; then
                if &#91;&#91; ! -e \${@: -1} &#93;&#93;; then
                     mkdir -p \${@: -1}
                fi

                command ${argv&#91;2,-1&#93;} \$@
            fi
        }&quot;
}
</code></pre><p>Por ĝin uzi, la nomon de la funkcio kiu estos uzita kiel komando donu, kaj la malvolvo mem. Ĉi tiuj alvokoj estas ideale difinita en la agorddosiero.</p><h3><a name="cp_krisigno"></a>cp!</h3><p>Por je <code>def&#95;mk</code> uzi kun <code>cp</code> ĝin alvoku jene:</p><pre><code>def&#95;mk cp! cp -rf</code></pre><p>kiu malvolvas al:</p><pre><code>function cp! &#40;&#41; {
  if &#91;&#91; $# -ge 2 &#93;&#93;; then
    if &#91;&#91; ! -e ${@: -1} &#93;&#93;; then
      mkdir -p ${@: -1}
    fi
    command cp -rf $@
  fi
}
</code></pre><p>Onin la komando <code>cp!</code> permasas por dosierojn kaj dosierujojn kopii, la celan dosierujon kreante kiel necese:</p><pre><code class="bash">%  tree
.
├── bar.txt
└── foo.txt

0 directories, 2 files

%  cp! &#42; a

%  tree
.
├── a
│   ├── bar.txt
│   └── foo.txt
├── bar.txt
└── foo.txt

1 directory, 4 files
</code></pre><h3><a name="mv_krisigno"></a>mv!</h3><p>Por je <code>def&#95;mk</code> uzi kun <code>mv</code> ĝin alvoku jene:</p><pre><code>def&#95;mk mv! mv -f</code></pre><p>kiu malvolvas al:</p><pre><code>function mv! &#40;&#41; {
  if &#91;&#91; $# -ge 2 &#93;&#93;; then
    if &#91;&#91; ! -e ${@: -1} &#93;&#93;; then
      mkdir -p ${@: -1}
    fi
    command mv -f $@
  fi
}
</code></pre><p>Onin la komando <code>mv!</code> permasas por dosierojn movi al dosierujo, la celan dosirujon kreante kiel necese:</p><pre><code class="bash">%  tree
.
├── bar.txt
└── foo.txt

0 directories, 2 files

%  mv! &#42; b

%  tree
.
└── b
    ├── bar.txt
    └── foo.txt

1 directory, 2 files
</code></pre><h2><a name="klavkombinoj"></a>Klavkombinoj</h2><p>Ekster la komandoj kiuj estas maŝinskribitaj, klavkombinoj oni ankaŭ povas alvoki por ajnajn komandojn fari. Jen kelkaj, kiujn mi uzas ofte:</p><h3><a name="insertlastword"></a>insert-last-word</h3><p>Kiam la lastan vorton de la lasta komando mi volas enmeti, je <code>insert-last-word</code> mi vokas. Ekzemple, se la jenan oni havas, en kiu la ĉapelo estas la kursoro:</p><pre><code>% dig hundo12345.kato.muzo.io
% mtr
      &#94;</code></pre><p>Kiam je <code>M-x insert-last-word EN</code> mi plenumas, la lastan vorton de la lasta komando ĝi enmetas, ĝin fari al:</p><pre><code>% dig hundo12345.kato.muzo.io
% mtr hundo12345.kato.muzo.io
                             &#94;</code></pre><p>Ĉi tio certigas, ke la argumento estas ĝuste kopiita.</p><p>La klavo estas defaŭlte bindita al <kbd>M-.</kbd>. Se oni volas certigi, ke tiun klavkombinon oni havas, la jenan metu en la agordo:</p><pre><code>bindkey &quot;\e.&quot; insert-last-word</code></pre><h3><a name="copyprevshellword"></a>copy-prev-shell-word</h3><p>Se la lastan vorton en la aktuala komandlinio mi volas ripeti, je <code>copy-prev-shell-word</code> mi alvokas. Ekzemple, se la jenan oni havas:</p><pre><code>% cp cxi.tio.estas.tre.longa.nomo
                                  &#94;</code></pre><p>Kiam je <code>M-x copy-prev-shell-word EN</code> mi plenumas, la lastan vorton ziŝo enmetas, gin fari al:</p><pre><code>% cp cxi.tio.estas.tre.longa.nomo cxi.tio.estas.tre.longa.nomo
                                                              &#94;</code></pre><p>Ĝin mi bindis al <kbd>M-=</kbd>. Por ĝin bindi al la agorddosiero:</p><pre><code>bindkey &quot;\e=&quot; copy-prev-shell-word</code></pre><h3><a name="anstatauxigoj"></a>Anstataŭigoj</h3><p>Krome la plenumado de <code>M-x</code> komandoj, onin ziŝo permesas por klavkombinojn difini kiu ajnan tekston enmeti sur la komandlinion, inkluzive stirsignoj.</p><p>La eligon de komandoj mi ofte bezonis akiri. Kutime la jenan mi faras:</p><pre><code>% foo `some command`</code></pre><p>aŭ</p><pre><code>% foo $&#40;some command&#41;</code></pre><p>La antaŭa pli facilas por maŝinskribi, tamen ĝi ne povas nestiĝi; la ĉi tiu estas tro malfacila por maŝinskribi. Por tio, la klavkombinon <kbd>M-`</kbd> mi bindis jene:</p><pre><code>% bindkey -s '\e`' '$&#40;&#41;\C-b'</code></pre><p>Do, se la jenan mi havas:</p><pre><code>% foo
      &#94;</code></pre><p>Kiam je <kbd>M-`</kbd> mi premas, la jenan mi akiros:</p><pre><code>% foo $&#40;&#41;
        &#94;</code></pre><h3><a name="citiloj"></a>Citiloj</h3><p>La bezonon por la argumenton de komandon citi mi ofte havas, precipe se metaesprimojn ĝi havas. Ofta kazo estas de jutubaj retadresoj, kiu la <code>?</code> signon havas:</p><p>Por tio, je <kbd>M-'</kbd> bindis kiel jene:</p><pre><code>% bindkey -s &quot;\e'&quot; &quot;''\C-b&quot;</code></pre><p>Do, kiam la jenan mi havas:</p><pre><code>% youtube-dl
             &#94;</code></pre><p>Kiam je <kbd>M-'</kbd> mi premas, la jenan mi akiros:</p><pre><code>% youtube-dl ''
              &#94;</code></pre><p>Anstataŭ tri klavojn premi sur mia klavaro, nur du mi nur devas premi, kaj ĝi certigas, ke paron de citiloj mi akiras.</p><h2><a name="cxio"></a>Ĉion rikolti</h2><p>Jen ĉiom da difinoj, kun kelkaj aldonaj helpiloj, en unu loko:</p><pre><code class="bash">function map &#40;&#41; {
  for i &#40;${argv&#91;2,-1&#93;}&#41; { ${&#40;ps: :&#41;${1}} $i }
}

function rmap &#40;&#41; {
  for i &#40;${argv&#91;2,-1&#93;}&#41; { ${&#40;ps: :&#41;${i}} $1 }
}

function fp &#40;&#41; {
  echo &quot;${1:A}&quot;
}

function d &#40;&#41; {
  if &#40;&#40; ! $#@ &#41;&#41;; then
      builtin cd
  elif &#91;&#91; -d $argv&#91;1&#93; &#93;&#93;; then
      builtin cd &quot;$&#40;fp $argv&#91;1&#93;&#41;&quot;
      $argv&#91;2,-1&#93;
  elif &#91;&#91; &quot;$1&quot; = -&lt;-&gt; &#93;&#93;; then
      builtin cd $1 &gt; /dev/null 2&gt;&amp;1
      $argv&#91;2,-1&#93;
  else
    echo &quot;$0: no such file or directory: $1&quot;
  fi
}

function d! &#40;&#41; {
  mkdir -p $argv&#91;1&#93;
  d &quot;$@&quot;
}

function rm! &#40;&#41; {
  if &#91;&#91; &quot;$1&quot; == &quot;$HOME&quot; || &quot;$1&quot; == &quot;$HOME/&quot; || &quot;$1&quot; == &quot;&#126;&quot; || &quot;$1&quot; == &quot;&#126;/&quot; &#93;&#93;; then
      return 1
  else
    command rm -rf $@
  fi
}

function rm+ &#40;&#41; {
  parallel 'rm -rf {}' ::: $@
}

function rm@ &#40;&#41; {
  if &#91;&#91; -d $1 &#93;&#93;; then
      find $1 -type f -exec shred -vfzun 10 {} \;
      command rm -rf $1
  else
    shred -vfzun 10 $1
  fi
}

function def&#95;mk &#40;&#41; {
  eval &quot;function ${argv&#91;1&#93;} &#40;&#41; {
            if &#91;&#91; \$# -ge 2 &#93;&#93;; then
                if &#91;&#91; ! -e \${@: -1} &#93;&#93;; then
                     mkdir -p \${@: -1}
                fi

                command ${argv&#91;2,-1&#93;} \$@
            fi
        }&quot;
}

def&#95;mk cp! cp -rf
def&#95;mk mv! mv -f

function def&#95;key &#40;&#41; {
  while &#91;&#91; $# -ge 2 &#93;&#93;; do
    bindkey &quot;$1&quot; &quot;$2&quot;
    shift 2
  done
}

function def&#95;keys &#40;&#41; {
  def&#95;key $keys
  unset keys
}

function def&#95;out&#95;key &#40;&#41; {
  while &#91;&#91; $# -ge 2 &#93;&#93;; do
    bindkey -s &quot;$1&quot; &quot;$2&quot;
    shift 2
  done
}

function def&#95;out&#95;keys &#40;&#41; {
  def&#95;out&#95;key $out&#95;keys
  unset out&#95;keys
}

keys=&#40;
  &quot;\e.&quot; insert-last-word
  &quot;\e=&quot; copy-prev-shell-word
&#41;; def&#95;keys

out&#95;keys=&#40;
  '\e`' '$&#40;&#41;\C-b'
  &quot;\e'&quot; &quot;''\C-b&quot;
&#41;; def&#95;out&#95;keys
</code></pre><h2><a name="finrimarkoj"></a>Finrimarkoj</h2><p>La komandlinion uzante, precipe per ŝelo tiel potenca kiel ziŝo, estas devige por esti konscie, kiun la ŝelon povas fari. Pakojn kiuj la ŝelon tajloras ne blinde uzu, sen kompreni kiujn ili faras.</p><p>Bonan ziŝigadon!</p><hr/><div class="footer"><p><div class="text-small"> <a href='/eo/'>Hejmo</a> · <a href='/eo/pri/'>Pri</a> · <a href='/eo/citajxoj/'>Citaĵoj</a> · <a href='/eo/pripensoj/'>Pripensoj</a> · <a href='https://github.com/ebzzry/ebzzry.github.io'>Fonto</a> </div> <div class="text-x-small"> Kreite per <a href='https://github.com/ebzzry/emem'>emem</a> </div></p><p><div class="text-x-small"> <a rel="license" href="https://creativecommons.org/publicdomain/zero/1.0/deed.eo"><img alt="CC0 1.0 Universala (CC0 1.0) Publikaĵiga Dediĉo" class="cc" src="/bil/cc0-88x31.png" /></a><br> Ĉi tiu verko estas <a rel="license" href="https://creativecommons.org/publicdomain/zero/1.0/deed.eo">publika havaĵo.</a><br> </div></p><p></div></p></div><script src="/static/js/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create', 'UA-93746003-1', 'auto');ga('send', 'pageview');</script></body></html>